import { CommonModule } from '@angular/common';
import { IdService, CommonUtils, FarrisCommonModule } from '@farris/ui-common';
import ResizeObserver from 'resize-observer-polyfill';
import { NG_VALUE_ACCESSOR, NgControl, FormsModule } from '@angular/forms';
import { MessagerService, MessagerModule } from '@farris/ui-messager';
import { EventManager } from '@angular/platform-browser';
import { Component, Input, Output, EventEmitter, forwardRef, Optional, ElementRef, HostBinding, ViewEncapsulation, Injector, Directive, HostListener, Renderer2, ViewContainerRef, NgZone, NgModule } from '@angular/core';
import { LocaleService, LocaleModule } from '@farris/ui-locale';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RadioGroupComponent {
    /**
     * @param {?} idSer
     */
    constructor(idSer) {
        this.idSer = idSer;
        this.modelChange = new EventEmitter();
        // tslint:disable-next-line:ban-types
        this.subscriber = [];
        this.controlChange = (/**
         * @return {?}
         */
        () => { });
        this.controlTouch = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.idSer.generate().replace(/-/g, '_');
    }
    /**
     * @param {?} value
     * @return {?}
     */
    changeModel(value) {
        this.model = value;
        this.modelChange.emit(this.model);
        this.controlChange(value);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.model = value;
        this.changeModel(this.model);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.controlChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.controlTouch = fn;
    }
}
RadioGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-radio-group',
                template: `
    <div class="farris-radio-group btn-group"
    [class.farris-input-wrap]="type!=='button'"
    [class.btn-group-toggle]="type==='button'"
    [class.farris-checkradio-hor]="horizontal">
      <ng-content></ng-content>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => RadioGroupComponent)),
                        multi: true,
                    }],
                styles: [`
    `]
            }] }
];
/** @nocollapse */
RadioGroupComponent.ctorParameters = () => [
    { type: IdService }
];
RadioGroupComponent.propDecorators = {
    type: [{ type: Input }],
    model: [{ type: Input }],
    name: [{ type: Input }],
    horizontal: [{ type: Input }],
    modelChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RadioComponent {
    /**
     * @param {?} radioGroup
     * @param {?} el
     */
    constructor(radioGroup, el) {
        this.radioGroup = radioGroup;
        this.el = el;
        /* radio 值 */
        this.label = '';
        this.name = '';
        this.modelChange = new EventEmitter();
        this.blockClass = true;
        this.controlChange = (/**
         * @return {?}
         */
        () => { });
        this.controlTouch = (/**
         * @return {?}
         */
        () => { });
    }
    /* radio 原生name 用于多个radio单选使用 */
    // get name() {
    //   if (this.hasParent(this.el.nativeElement)) {
    //     return this.radioGroup.name;
    //   }
    // }
    /* radio 值 */
    /**
     * @return {?}
     */
    get model() {
        if (this.hasParent(this.el.nativeElement)) {
            return this.radioGroup.model;
        }
        return this.nyModel;
    }
    /**
     * @param {?} model
     * @return {?}
     */
    set model(model) {
        this.nyModel = model;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.radioGroup.name;
    }
    /**
     * @return {?}
     */
    changeModelHandler() {
        // 父元素获取label  子元素再从父元素获取model
        if (this.hasParent(this.el.nativeElement)) {
            return this.radioGroup.changeModel(this.label);
        }
        this.model = this.label;
        this.modelChange.emit(this.model);
        this.controlChange(this.label);
    }
    /* 是否存在父元素  存在即单选组*/
    /**
     * @param {?} element
     * @return {?}
     */
    hasParent(element) {
        return element.parentElement.classList.contains('farris-radio-group');
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.model = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.controlChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.controlTouch = fn;
    }
}
RadioComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-radio',
                template: "<label class=\"custom-control custom-radio\">\r\n    <input class=\"custom-control-input\" [name]=\"name\" [value]=\"label\" \r\n    [ngModel]=\"model\" (ngModelChange)=\"changeModelHandler()\" type=\"radio\" [disabled]=\"disabled\">\r\n    <span class=\"custom-control-label\">\r\n      <ng-content>\r\n      </ng-content>\r\n    </span>\r\n</label>",
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => RadioComponent)),
                        multi: true,
                    }]
                // changeDetection: ChangeDetectionStrategy.OnPush,
                ,
                styles: [".btn-group .btn{margin-left:-1px}"]
            }] }
];
/** @nocollapse */
RadioComponent.ctorParameters = () => [
    { type: RadioGroupComponent, decorators: [{ type: Optional }] },
    { type: ElementRef }
];
RadioComponent.propDecorators = {
    model: [{ type: Input }],
    id: [{ type: Input }],
    label: [{ type: Input }],
    disabled: [{ type: Input }],
    modelChange: [{ type: Output }],
    blockClass: [{ type: HostBinding, args: ['class.d-block',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RadioButtonComponent {
    /**
     * @param {?} radioGroup
     * @param {?} el
     */
    constructor(radioGroup, el) {
        this.radioGroup = radioGroup;
        this.el = el;
        /* radio 原生name 用于多个radio单选使用 */
        // get name() {
        // }
        this.name = '';
        /* 按钮类型 */
        this.type = 'secondary';
        /* radio 值 */
        this.label = '';
        this.modelChange = new EventEmitter();
        this.controlChange = (/**
         * @return {?}
         */
        () => { });
        this.controlTouch = (/**
         * @return {?}
         */
        () => { });
    }
    /* radio 值 */
    /**
     * @return {?}
     */
    get model() {
        if (this.hasParent(this.el.nativeElement)) {
            return this.radioGroup.model;
        }
        return this.nyModel;
    }
    /**
     * @param {?} model
     * @return {?}
     */
    set model(model) {
        this.nyModel = model;
    }
    /**
     * @return {?}
     */
    get farrisRadioButtonClass() { return true; }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.hasParent(this.el.nativeElement) ? this.radioGroup.name : '';
    }
    /**
     * @return {?}
     */
    isGroupModel() {
        return this.label === this.radioGroup.model;
    }
    /**
     * @return {?}
     */
    changeModelHandler() {
        // 父元素获取label  子元素再从父元素获取model
        if (this.hasParent(this.el.nativeElement)) {
            return this.radioGroup.changeModel(this.label);
        }
        this.model = this.label;
        this.modelChange.emit(this.model);
        this.controlChange(this.label);
    }
    /* 是否存在父元素  存在即单选组*/
    /**
     * @param {?} element
     * @return {?}
     */
    hasParent(element) {
        return element.parentElement.classList.contains('farris-input-wrap') || element.parentElement.classList.contains('btn-group');
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.model = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.controlChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.controlTouch = fn;
    }
}
RadioButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-radio-button',
                template: `
    <label [class]="'btn btn-'+type" [class.active]="isGroupModel()" [class.disabled]="disabled">
        <input class="custom-control-input" [name]="name" [value]="label"
        [ngModel]="model" (ngModelChange)="changeModelHandler()" type="radio" [disabled]="disabled">
          <ng-content>
          </ng-content>
    </label>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => RadioButtonComponent)),
                        multi: true,
                    }],
                encapsulation: ViewEncapsulation.None,
                styles: [`
        .farris-radio-button>.btn{
            margin-left:-1px
          }
          .farris-radio-button>.btn.active, .farris-radio-button>.btn:hover{
            position: relative;
          }
      `]
            }] }
];
/** @nocollapse */
RadioButtonComponent.ctorParameters = () => [
    { type: RadioGroupComponent, decorators: [{ type: Optional }] },
    { type: ElementRef }
];
RadioButtonComponent.propDecorators = {
    type: [{ type: Input }],
    model: [{ type: Input }],
    id: [{ type: Input }],
    label: [{ type: Input }],
    disabled: [{ type: Input }],
    modelChange: [{ type: Output }],
    farrisRadioButtonClass: [{ type: HostBinding, args: ['class.farris-radio-button',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FarrisRadioGroupComponent {
    /**
     * @param {?} idSer
     * @param {?} inject
     */
    constructor(idSer, inject) {
        this.idSer = idSer;
        this.inject = inject;
        /* radio 数组 */
        this.data = [];
        this.textField = 'name';
        this.valueField = 'value';
        /* 点击事件 */
        this.changeValue = new EventEmitter();
        this.controlChange = (/**
         * @return {?}
         */
        () => { });
        this.controlTouch = (/**
         * @return {?}
         */
        () => { });
        if (this.inject) {
            this.commonUtils = this.inject.get(CommonUtils);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.idSer.generate().replace(/-/g, '_');
    }
    /**
     * @param {?} item
     * @return {?}
     */
    clickHandler(item) {
        /** @type {?} */
        let val = this._getValue(item);
        if (this.value == val)
            return;
        // 更改control的值
        this.value = val;
        this.controlChange(this.value);
        this.controlTouch(this.value);
        this.changeValue.emit(this.value);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    _getText(item) {
        if (item) {
            if (this.commonUtils && this.commonUtils.getValue) {
                return this.commonUtils.getValue(this.textField, item);
            }
            else {
                return item[this.textField];
            }
        }
        else {
            return '';
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    _getValue(item) {
        if (item) {
            if (this.commonUtils && this.commonUtils.getValue) {
                return this.commonUtils.getValue(this.valueField, item);
            }
            else {
                return item[this.valueField];
            }
        }
        else {
            return '';
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.controlChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.controlTouch = fn;
    }
}
FarrisRadioGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-radiogroup',
                template: "<div class=\"farris-input-wrap\" [class.farris-checkradio-hor]=\"horizontal\">\r\n    <div class=\"custom-control custom-radio\" *ngFor=\"let item of data; let i=index\">\r\n        <input #input class=\"custom-control-input\" [name]=\"name\" id=\"{{'radio_'+name+i}}\" type=\"radio\"\r\n        [value]=\"_getValue(item)\" (click)=\"clickHandler(item)\" [checked]=\"_getValue(item) == value\" \r\n        [disabled]=\"disabled\" tabindex=\"{{tabIndex}}\">\r\n        <label class=\"custom-control-label\" for=\"{{'radio_'+name+i}}\">{{_getText(item)}}</label>\r\n    </div>\r\n</div>\r\n\r\n\r\n",
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => FarrisRadioGroupComponent)),
                        multi: true,
                    }],
                exportAs: 'FarrisRadioGroupComponent'
            }] }
];
/** @nocollapse */
FarrisRadioGroupComponent.ctorParameters = () => [
    { type: IdService },
    { type: Injector, decorators: [{ type: Optional }] }
];
FarrisRadioGroupComponent.propDecorators = {
    tabIndex: [{ type: Input, args: ['tab-index',] }],
    data: [{ type: Input }],
    type: [{ type: Input }],
    name: [{ type: Input }],
    horizontal: [{ type: Input }],
    disabled: [{ type: Input }],
    value: [{ type: Input }],
    textField: [{ type: Input }],
    valueField: [{ type: Input }],
    changeValue: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckboxGroupComponent {
    /**
     * @param {?} idSer
     */
    constructor(idSer) {
        this.idSer = idSer;
        /* 初始化 checkbox 的值 */
        this.model = [];
        /*  */
        this.modelChange = new EventEmitter();
        this.controlChange = (/**
         * @return {?}
         */
        () => { });
        this.controlTouch = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.idSer.generate();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    changeModel(value) {
        /** @type {?} */
        const index = this.model.findIndex((/**
         * @param {?} ele
         * @return {?}
         */
        ele => {
            return ele === value;
        }));
        // 如果已经选中  则设置为不选中
        if (index > -1) {
            this.model.splice(index, 1);
            return this.modelChange.emit(this.model);
        }
        // 如果没有选中  设置为选中
        this.model.push(value);
        // control的值设置为逗号分隔的字符串  便于存储和传递
        this.controlChange(this.model.join());
        this.modelChange.emit(this.model);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.model = value;
        this.changeModel(this.model);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.controlChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.controlTouch = fn;
    }
}
CheckboxGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-checkbox-group',
                template: `
    <div class="farris-input-wrap" [class.farris-checkradio-hor]="horizontal">
      <ng-content></ng-content>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => CheckboxGroupComponent)),
                        multi: true,
                    }]
            }] }
];
/** @nocollapse */
CheckboxGroupComponent.ctorParameters = () => [
    { type: IdService }
];
CheckboxGroupComponent.propDecorators = {
    model: [{ type: Input }],
    name: [{ type: Input }],
    horizontal: [{ type: Input }],
    modelChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CheckboxComponent {
    /**
     * @param {?} checkbox
     * @param {?} el
     */
    constructor(checkbox, el) {
        this.checkbox = checkbox;
        this.el = el;
        this.modelChange = new EventEmitter();
        this.controlChange = (/**
         * @return {?}
         */
        () => { });
        this.controlTouch = (/**
         * @return {?}
         */
        () => { });
    }
    /* radio 原生name 用于多个radio单选使用 */
    /**
     * @return {?}
     */
    get name() {
        if (this.hasParent(this.el.nativeElement)) {
            return this.checkbox.name;
        }
        return '';
    }
    /* model */
    /**
     * @return {?}
     */
    get model() {
        if (this.hasParent(this.el.nativeElement)) {
            return this.checkbox.model.find((/**
             * @param {?} ele
             * @return {?}
             */
            ele => {
                return ele === this.label;
            }));
        }
        return this.nyModel;
    }
    /**
     * @param {?} model
     * @return {?}
     */
    set model(model) {
        this.nyModel = model;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /* 值传递 */
    /**
     * @return {?}
     */
    changeModelHandler() {
        // 父元素获取label  子元素再从父元素获取model
        if (this.hasParent(this.el.nativeElement)) {
            return this.checkbox.changeModel(this.label);
        }
        this.model = this.label;
        this.modelChange.emit(this.model);
        this.controlChange(this.label);
    }
    /* 是否存在父元素  存在即单选组*/
    /**
     * @param {?} element
     * @return {?}
     */
    hasParent(element) {
        return element.parentElement.classList.contains('farris-input-wrap');
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.model = value;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.controlChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.controlTouch = fn;
    }
}
CheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-checkbox',
                template: "<label class=\"custom-control custom-checkbox\">\r\n  <input class=\"custom-control-input\" [name]=\"name\" [value]=\"label\" [ngModel]=\"model\"\r\n    (ngModelChange)=\"changeModelHandler()\" type=\"checkbox\" [disabled]=\"disabled\">\r\n  <span class=\"custom-control-label\">\r\n    <ng-content>\r\n    </ng-content>\r\n  </span>\r\n</label>",
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => CheckboxComponent)),
                        multi: true,
                    }],
                styles: ['./checkbox.component.css']
            }] }
];
/** @nocollapse */
CheckboxComponent.ctorParameters = () => [
    { type: CheckboxGroupComponent },
    { type: ElementRef }
];
CheckboxComponent.propDecorators = {
    model: [{ type: Input }],
    label: [{ type: Input }],
    disabled: [{ type: Input }],
    modelChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FarrisCheckboxGroupComponent {
    /**
     * @param {?} idSer
     * @param {?} inject
     */
    constructor(idSer, inject) {
        this.idSer = idSer;
        this.inject = inject;
        this.tabIndex = 0;
        /* radio 数组 */
        this.data = [];
        /* 分隔符 默认逗号*/
        this.separator = ',';
        /* 值类型是否是string */
        this.isStringValue = true;
        this.textField = 'name';
        this.valueField = 'value';
        this.changeValue = new EventEmitter();
        /* checkbox赋值事件 */
        this.setCheckboxData = new EventEmitter();
        this.controlChange = (/**
         * @return {?}
         */
        () => { });
        this.controlTouch = (/**
         * @return {?}
         */
        () => { });
        if (this.inject) {
            this.commonUtils = this.inject.get(CommonUtils);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // 初始化name
        this.name = this.idSer.generate().replace(/-/g, '_');
        this.setCheckboxData.emit(this);
        // todo 取值可以实现promise
        if (this.loadData) {
            this.loadDataSubscription = this.loadData().subscribe((/**
             * @param {?} res
             * @return {?}
             */
            res => this.data = res.data));
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.loadDataSubscription) {
            this.loadDataSubscription.unsubscribe();
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    _getText(item) {
        if (item) {
            if (this.commonUtils && this.commonUtils.getValue) {
                return this.commonUtils.getValue(this.textField, item);
            }
            else {
                return item[this.textField];
            }
        }
        else {
            return '';
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    _getValue(item) {
        if (item) {
            if (this.commonUtils && this.commonUtils.getValue) {
                return this.commonUtils.getValue(this.valueField, item);
            }
            else {
                return item[this.valueField];
            }
        }
        else {
            return '';
        }
    }
    /* 选中input值 */
    /**
     * @param {?} item
     * @param {?} index
     * @return {?}
     */
    clickHandler(item, index) {
        /** @type {?} */
        let arrValue = this.transformToArr(this.value) || [];
        /** @type {?} */
        const val = String(this._getValue(item));
        if (!arrValue || !arrValue.length) {
            arrValue.push(val);
        }
        else {
            if (arrValue.some((/**
             * @param {?} item
             * @return {?}
             */
            item => item == val))) {
                arrValue = arrValue.filter((/**
                 * @param {?} n
                 * @return {?}
                 */
                n => n !== val));
            }
            else {
                arrValue.push(val);
            }
        }
        // 更新value值
        this.value = this.transformToStr(arrValue);
        // 传值formcontrol
        this.controlChange(this.value);
        this.controlTouch(this.value);
        this.changeValue.emit(this.value);
    }
    /* 被选中 */
    /**
     * @param {?} item
     * @return {?}
     */
    checked(item) {
        /** @type {?} */
        const val = String(this._getValue(item));
        /** @type {?} */
        const checkedValue = this.transformToArr(this.value);
        // 多值
        return checkedValue.some((/**
         * @param {?} item
         * @return {?}
         */
        item => item == val));
    }
    /* 值到数组值的转换 */
    /**
     * @param {?} value
     * @return {?}
     */
    transformToArr(value) {
        if (!value) {
            return [];
        }
        if (!this.isStringValue) {
            return value;
        }
        return value.split(this.separator);
    }
    /* 值到字符串值的转换 */
    /**
     * @param {?} value
     * @return {?}
     */
    transformToStr(value) {
        /** @type {?} */
        const allVals = this.data.map((/**
         * @param {?} n
         * @return {?}
         */
        n => this._getValue(n)));
        /** @type {?} */
        const r = [];
        allVals.forEach((/**
         * @param {?} n
         * @return {?}
         */
        n => {
            if (value.some((/**
             * @param {?} item
             * @return {?}
             */
            item => item == n))) {
                r.push(n);
            }
        }));
        if (!this.isStringValue) {
            return r;
        }
        return r.join(this.separator);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
    /* change操作值变化  方法重写*/
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.controlChange = fn;
    }
    /* blur值变化  方法重写*/
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.controlTouch = fn;
    }
}
FarrisCheckboxGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'farris-checkboxgroup',
                template: "<div class=\"farris-input-wrap\" [class.farris-checkradio-hor]=\"horizontal\">\r\n    <div class=\"custom-control custom-checkbox\" *ngFor=\"let item of data; let i = index\">\r\n        <input #input class=\"custom-control-input\" [name]=\"name\" id=\"{{ 'checkbox_' + name + i }}\"\r\n            type=\"checkbox\" [value]=\"_getValue(item)\" [checked]=\"checked(item)\" [disabled]=\"disable\" (click)=\"clickHandler(item, i)\" \r\n            tabindex=\"{{ tabIndex + i }}\" />\r\n        <label class=\"custom-control-label\" for=\"{{ 'checkbox_' + name + i }}\" title=\"{{_getText(item)}}\">{{ _getText(item) }}</label>\r\n    </div>\r\n</div>\r\n",
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => FarrisCheckboxGroupComponent)),
                        multi: true,
                    }],
                exportAs: 'FarrisCheckboxGroupComponent'
            }] }
];
/** @nocollapse */
FarrisCheckboxGroupComponent.ctorParameters = () => [
    { type: IdService },
    { type: Injector, decorators: [{ type: Optional }] }
];
FarrisCheckboxGroupComponent.propDecorators = {
    tabIndex: [{ type: Input, args: ['tab-index',] }],
    data: [{ type: Input }],
    type: [{ type: Input }],
    name: [{ type: Input }],
    horizontal: [{ type: Input }],
    separator: [{ type: Input }],
    disable: [{ type: Input }],
    value: [{ type: Input }],
    isStringValue: [{ type: Input }],
    textField: [{ type: Input }],
    valueField: [{ type: Input }],
    loadData: [{ type: Input }],
    changeValue: [{ type: Output }],
    setCheckboxData: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TextareaAutoSizeDirective {
    /**
     * @param {?} el
     * @param {?} ngControl
     * @param {?} injector
     */
    constructor(el, ngControl, injector) {
        this.el = el;
        this.ngControl = ngControl;
        this.injector = injector;
        this.enable = true;
        this.previousValue = null;
        this.isUserResized = false;
        this.textarea = this.el.nativeElement;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.init();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.enable && !changes.enable.isFirstChange()) {
            this.sizeToFit();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.minHeight = this.textarea.getBoundingClientRect().height;
    }
    /**
     * @private
     * @return {?}
     */
    init() {
        if (this.enable) {
            this.document = this.textarea.ownerDocument;
            this.documentElement = this.document.documentElement;
            if (this.textarea) {
                if (this.textarea.value) {
                    this.sizeToFit();
                }
            }
            if (this.ngControl) {
                this.ngControl.valueChanges.subscribe((/**
                 * @param {?} v
                 * @return {?}
                 */
                v => {
                    if (v !== this.previousValue) {
                        this.sizeToFit();
                    }
                }));
            }
        }
    }
    /**
     * @return {?}
     */
    onInput() {
        this.sizeToFit();
    }
    /**
     * @return {?}
     */
    onValueChange() {
        this.sizeToFit();
    }
    /**
     * @private
     * @return {?}
     */
    overflowOffset() {
        /** @type {?} */
        let offsetTop = 0;
        /** @type {?} */
        let el = this.textarea;
        while (el !== document.body && el !== null) {
            offsetTop += el.offsetTop || 0;
            el = el.offsetParent;
        }
        /** @type {?} */
        const top = offsetTop - document.defaultView.pageYOffset;
        /** @type {?} */
        const bottom = this.documentElement.clientHeight - (top + this.textarea.offsetHeight);
        return { top, bottom };
    }
    /**
     * @private
     * @return {?}
     */
    sizeToFit() {
        if (!this.enable) {
            return;
        }
        /** @type {?} */
        const textarea = this.textarea;
        if (this.isUserResized) {
            return;
        }
        if (this.textarea.value === this.previousValue) {
            return;
        }
        if (this.textarea.offsetWidth <= 0 && this.textarea.offsetHeight <= 0) {
            return;
        }
        // const { top, bottom } = this.overflowOffset();
        // if (top < 0 || bottom < 0) {
        //     return;
        // }
        /** @type {?} */
        const textareaStyle = getComputedStyle(textarea);
        /** @type {?} */
        const topBorderWidth = Number(textareaStyle.borderTopWidth.replace(/px/, ''));
        /** @type {?} */
        const bottomBorderWidth = Number(textareaStyle.borderBottomWidth.replace(/px/, ''));
        /** @type {?} */
        const isBorderBox = textareaStyle.boxSizing === 'border-box';
        /** @type {?} */
        const borderAddOn = isBorderBox ? topBorderWidth + bottomBorderWidth : 0;
        // const maxHeight = Number(textareaStyle.height.replace(/px/, '')) + bottom;
        // const adjustedViewportMarginBottom = bottom < viewportMarginBottom ? bottom : viewportMarginBottom;
        // textarea.style.maxHeight = `${maxHeight - adjustedViewportMarginBottom}px`;
        if (this.maxHeight) {
            textarea.style.maxHeight = `${this.maxHeight}px`;
        }
        /** @type {?} */
        const container = textarea.parentElement;
        if (container instanceof HTMLElement) {
            /** @type {?} */
            const containerHeight = container.style.height;
            container.style.height = getComputedStyle(container).height;
            textarea.style.height = 'auto';
            /** @type {?} */
            let h = textarea.scrollHeight + borderAddOn;
            if (this.minHeight > h) {
                h = this.minHeight;
            }
            textarea.style.height = `${h}px`;
            container.style.height = containerHeight;
        }
        this.previousValue = textarea.value;
    }
}
TextareaAutoSizeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[auto-size]',
            },] }
];
/** @nocollapse */
TextareaAutoSizeDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgControl },
    { type: Injector }
];
TextareaAutoSizeDirective.propDecorators = {
    enable: [{ type: Input, args: ['auto-size',] }],
    maxHeight: [{ type: Input }],
    onInput: [{ type: HostListener, args: ['input',] }],
    onValueChange: [{ type: HostListener, args: ['change',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TextareaWordcountDirective {
    /**
     * @param {?} el
     * @param {?} render
     * @param {?} injector
     */
    constructor(el, render, injector) {
        this.el = el;
        this.render = render;
        this.injector = injector;
        this.useWordCount = true;
        /**
         * 统计字数的方式； surplus 剩余可输入字数; length: 当前已输入字数；
         *
         * 默认为 surplus
         */
        this.countType = 'surplus';
        this.onlyShowInDialog = false;
        this.wordCountElement = null;
        // 当前字数
        this.currentLengthElement = null;
        this.onInput = null;
        this.ro = null;
        this.eventManager = this.injector.get(EventManager);
        this.localeSer = this.injector.get(LocaleService);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ngControl = this.injector.get(NgControl, null);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.initWordCount();
        if (this.ngControl && this.useWordCount) {
            this.ngControl.control.valueChanges.subscribe((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                this.updateWordsCount();
            }));
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.useWordCount && !changes.useWordCount.isFirstChange()) {
            if (this.useWordCount) {
                this.initWordCount();
            }
            else {
                this.destroy();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy();
        if (this.ro) {
            this.ro.disconnect();
            this.ro.unobserve(this.el.nativeElement.parentElement);
        }
    }
    /**
     * @private
     * @return {?}
     */
    destroy() {
        if (this.onInput) {
            this.onInput();
        }
        if (this.wordCountElement) {
            this.wordCountElement.remove();
        }
    }
    /**
     * @return {?}
     */
    initWordCount() {
        if (this.useWordCount && !this.onlyShowInDialog) {
            this.createWordCountElement();
        }
    }
    /**
     * @private
     * @return {?}
     */
    createWordCountID() {
        /** @type {?} */
        const tagName = this.el.nativeElement.tagName;
        if (this.ngControl) {
            /** @type {?} */
            const ctrlName = this.ngControl.name;
            return `${tagName}_WORDCOUNT_${ctrlName}`;
        }
        else {
            if (this.el.nativeElement.id) {
                return `${tagName}_WORDCOUNT_${this.el.nativeElement.id}`;
            }
        }
        return '';
    }
    /**
     * @private
     * @return {?}
     */
    createWordCountElement() {
        /** @type {?} */
        const max = this.el.nativeElement.maxLength;
        if (!max || max < 0) {
            // console.info('未设置最大字符数，计数功能失效。');
            return;
        }
        /** @type {?} */
        const wordCountSPAN = this.render.createElement('span');
        wordCountSPAN.className = 'textarea-wordcount';
        /** @type {?} */
        const id = this.createWordCountID();
        if (id) {
            wordCountSPAN.id = id;
        }
        this.render.setStyle(wordCountSPAN, 'position', 'absolute');
        this.render.setStyle(wordCountSPAN, 'bottom', '10px');
        const { width, right } = this.el.nativeElement.getBoundingClientRect();
        const { width: parentWidth } = this.el.nativeElement.parentElement.getBoundingClientRect();
        if (parentWidth !== width) {
            this.render.setStyle(wordCountSPAN, 'right', `${parentWidth - width + 10}px`);
            this.ro = new ResizeObserver((/**
             * @param {?} entries
             * @param {?} observer
             * @return {?}
             */
            (entries, observer) => {
                if (entries && entries[0]) {
                    /** @type {?} */
                    const _pw = entries[0].contentRect.width;
                    this.render.setStyle(wordCountSPAN, 'right', `${_pw - width + 10}px`);
                }
            }));
            this.ro.observe(this.el.nativeElement.parentElement);
        }
        else {
            this.render.setStyle(wordCountSPAN, 'right', '10px');
        }
        this.render.setStyle(wordCountSPAN, 'cursor', 'pointer');
        this.el.nativeElement.after(wordCountSPAN);
        this.wordCountElement = wordCountSPAN;
        /** @type {?} */
        const currentLengthSPAN = this.render.createElement('span');
        wordCountSPAN.appendChild(currentLengthSPAN);
        this.currentLengthElement = currentLengthSPAN;
        currentLengthSPAN.after(` / ${max}`);
        this.updateWordsCount();
        this.onInput = this.render.listen(this.el.nativeElement, 'input', (/**
         * @return {?}
         */
        () => {
            // value.replace(/\n|\r/gi, '') // 移除换行符
            this.updateWordsCount();
        }));
    }
    /**
     * @return {?}
     */
    updateWordsCount() {
        if (!this.useWordCount || !this.currentLengthElement) {
            return;
        }
        /** @type {?} */
        const max = this.el.nativeElement.maxLength;
        /** @type {?} */
        const val = this.countType === 'surplus' ? max - this.el.nativeElement.value.length : this.el.nativeElement.value.length;
        /** @type {?} */
        const tip = 'messager.prompt.tips.' + this.countType;
        this.currentLengthElement.innerText = val;
        this.wordCountElement.title = this.localeSer.getValue(tip).replace('{0}', val);
    }
}
TextareaWordcountDirective.decorators = [
    { type: Directive, args: [{
                selector: '[word-count]',
                exportAs: 'WordCountRef'
            },] }
];
/** @nocollapse */
TextareaWordcountDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: Injector }
];
TextareaWordcountDirective.propDecorators = {
    useWordCount: [{ type: Input, args: ['word-count',] }],
    countType: [{ type: Input }],
    onlyShowInDialog: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TextareaZoomDirective {
    /**
     * @param {?} el
     * @param {?} render
     * @param {?} injector
     * @param {?} wordCountRef
     */
    constructor(el, render, injector, wordCountRef) {
        this.el = el;
        this.render = render;
        this.injector = injector;
        this.wordCountRef = wordCountRef;
        this.useZoom = true;
        this.dialogWidth = 500;
        this.dialogHeight = 400;
        this.fullscreen = false;
        this.title = '';
        this.value = '';
        this.onMouseEnter = null;
        this.onMouseLeave = null;
        this.onClick = null;
        this.altEnterHandler = null;
        this.zoomButtonElement = null;
        this.messagerService = this.injector.get(MessagerService);
        this.eventManager = this.injector.get(EventManager);
        this.localeSer = this.injector.get(LocaleService, null);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.ngControl = this.injector.get(NgControl, null);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.useZoom && !changes.useZoom.isFirstChange()) {
            if (this.useZoom) {
                this.createZoomButton();
            }
            else {
                this.destroy();
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.useZoom) {
            this.createZoomButton();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy();
    }
    /**
     * @private
     * @return {?}
     */
    destroy() {
        if (this.onMouseEnter) {
            this.onMouseEnter();
        }
        if (this.onMouseLeave) {
            this.onMouseLeave();
        }
        if (this.onClick) {
            this.onClick();
        }
        if (this.altEnterHandler) {
            this.altEnterHandler();
        }
        if (this.zoomButtonElement) {
            this.zoomButtonElement.remove();
        }
    }
    /**
     * @private
     * @return {?}
     */
    bindEventHandler() {
        this.altEnterHandler = this.eventManager.addEventListener(this.el.nativeElement, 'keydown.alt.enter', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            /** @type {?} */
            const target = ((/** @type {?} */ (event.target)));
            /** @type {?} */
            const val = target.value + '\n';
            target.value = val;
            event.preventDefault();
            event.stopPropagation();
            return false;
        }));
    }
    /**
     * @private
     * @return {?}
     */
    createZoombarID() {
        /** @type {?} */
        const tagName = this.el.nativeElement.tagName;
        if (this.ngControl) {
            /** @type {?} */
            const ctrlName = this.ngControl.name;
            return `${tagName}_ZOOMBAR_${ctrlName}`;
        }
        else {
            if (this.el.nativeElement.id) {
                return `${tagName}_ZOOMBAR_${this.el.nativeElement.id}`;
            }
        }
        return '';
    }
    /**
     * @private
     * @return {?}
     */
    createZoomButton() {
        /** @type {?} */
        const zoomSPAN = this.render.createElement('span');
        zoomSPAN.className = 'f-icon modal_maximize textarea-zoom';
        zoomSPAN.title = this.localeSer.getValue('text.zoom') || '点击后弹出进行编辑';
        /** @type {?} */
        const id = this.createZoombarID();
        if (id) {
            zoomSPAN.id = id;
        }
        this.render.setStyle(zoomSPAN, 'position', 'absolute');
        this.render.setStyle(zoomSPAN, 'top', '2px');
        const { width } = this.el.nativeElement.getBoundingClientRect();
        const { width: parentWidth } = this.el.nativeElement.parentElement.getBoundingClientRect();
        if (parentWidth !== width) {
            this.render.setStyle(zoomSPAN, 'left', `${width - 18}px`);
        }
        else {
            this.render.setStyle(zoomSPAN, 'right', '2px');
        }
        this.render.setStyle(zoomSPAN, 'cursor', 'pointer');
        this.el.nativeElement.after(zoomSPAN);
        this.zoomButtonElement = zoomSPAN;
        this.onMouseEnter = this.render.listen(zoomSPAN, 'mouseenter', (/**
         * @return {?}
         */
        () => {
            this.render.setStyle(zoomSPAN, 'fontSize', '22px');
        }));
        this.onMouseLeave = this.render.listen(zoomSPAN, 'mouseleave', (/**
         * @return {?}
         */
        () => {
            this.render.setStyle(zoomSPAN, 'fontSize', '1rem');
        }));
        this.onClick = this.render.listen(zoomSPAN, 'click', (/**
         * @return {?}
         */
        () => {
            this.zoomTextarea();
        }));
    }
    /**
     * @private
     * @return {?}
     */
    zoomTextarea() {
        /** @type {?} */
        const opts = {
            width: this.dialogWidth || 500,
            height: this.dialogHeight || 400,
            showFontSize: true,
            inputType: 'textarea',
            saveSize: true // 启用个性化存储，localStorage
        };
        if (window.localStorage) {
            /** @type {?} */
            const key = this.messagerService.getKeyString();
            /** @type {?} */
            const val = localStorage.getItem(key);
            if (val) {
                /** @type {?} */
                const lastSetting = JSON.parse(val);
                opts.fontSize = lastSetting.fontSize || 18;
                opts.width = lastSetting.width || opts.width;
                opts.height = lastSetting.height || opts.height;
            }
        }
        /** @type {?} */
        const tagName = this.el.nativeElement.tagName;
        /** @type {?} */
        let showText = this.el.nativeElement.value;
        if (this.ngControl) {
            showText = this.ngControl.value;
        }
        else {
            showText = this.el.nativeElement.value;
        }
        showText = this.value || showText;
        if (tagName === 'FARRIS-TEXT' || this.el.nativeElement.readOnly || this.el.nativeElement.disabled) {
            opts.readonly = true;
            opts.showOkButton = false;
            this.messagerService.prompt2(this.title, showText, opts).subscribe();
        }
        else {
            opts.maxLength = this.el.nativeElement.maxLength;
            opts.enableWordCount = this.wordCountRef ? this.wordCountRef.useWordCount : false;
            opts.countType = this.wordCountRef ? this.wordCountRef.countType : 'length';
            this.messagerService.prompt2(this.title, showText, opts).subscribe((/**
             * @param {?} v
             * @return {?}
             */
            v => {
                if (typeof v === 'boolean' && !v) {
                    return;
                }
                else {
                    this.ngControl.control.setValue(v);
                    if (this.wordCountRef) {
                        this.wordCountRef.updateWordsCount();
                    }
                }
            }));
        }
    }
}
TextareaZoomDirective.decorators = [
    { type: Directive, args: [{
                selector: '[textarea-zoom]',
            },] }
];
/** @nocollapse */
TextareaZoomDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: Injector },
    { type: TextareaWordcountDirective, decorators: [{ type: Optional }] }
];
TextareaZoomDirective.propDecorators = {
    useZoom: [{ type: Input, args: ['textarea-zoom',] }],
    dialogWidth: [{ type: Input }],
    dialogHeight: [{ type: Input }],
    fullscreen: [{ type: Input }],
    title: [{ type: Input }],
    value: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class InputAppendDirective {
    // private ngControl: NgControl;
    /**
     * @param {?} viewRef
     * @param {?} el
     * @param {?} render
     * @param {?} injector
     */
    constructor(viewRef, el, render, injector) {
        this.viewRef = viewRef;
        this.el = el;
        this.render = render;
        this.injector = injector;
        this._enableAppend = true;
        // 追加到哪个类型下 TextBox、MultiTextBox、 StaticText
        this.inputAppendControlType = 'InputGroup';
        // 根据类型不一样，在控件处于禁用、只读时，决定颜色是否可用
        // 有两种：按钮 button 文本 text
        this._appendType = 'button';
        // 追加的文本
        this._inputAppendText = '';
        // 模板
        // @Input() inputAppendTmpl: TemplateRef<any>;
        this._disabled = false;
        /*
            * 文本点击事件
            */
        this.inputAppendClickEvent = new EventEmitter();
        // 标记native的外层
        this.elWrapElement = null;
        // 标记元素
        this.appendWrapElement = null;
        // 暂时不用
        this.appendTextElement = null;
        this.clickHandler = null;
        this.disabledCls = 'f-state-disabled';
        this.ngZone = null;
        this.ngZone = this.injector.get(NgZone);
    }
    // 相当于启用禁用此功能
    /**
     * @param {?} value
     * @return {?}
     */
    set enableAppend(value) {
        if (value === '' || value) {
            this._enableAppend = true;
            // 需要
            if (!this.appendWrapElement) {
                this.createStruct();
            }
        }
        else {
            this._enableAppend = false;
            if (this.appendWrapElement) {
                this.resetStruct();
            }
        }
    }
    /**
     * @return {?}
     */
    get enableAppend() {
        return this._enableAppend;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set inputAppendType(value) {
        if (value) {
            if (['button', 'text'].findIndex((/**
             * @param {?} item
             * @return {?}
             */
            item => item == value)) < 0) {
                // 类型在支持范围内
                value = 'button';
            }
            if (value != this._appendType) {
                if (this.appendWrapElement) {
                    // 移除原来，追加新的
                    this.render.removeClass(this.appendWrapElement, 'input-append-' + this._appendType);
                    this.render.addClass(this.appendWrapElement, 'input-append-' + value);
                    if (this._appendType == 'button') {
                        // 原来是按钮
                        if (this.clickHandler) {
                            this.clickHandler();
                            this.clickHandler = null;
                        }
                    }
                    else {
                        this.clickHandler = this.render.listen(this.appendWrapElement, 'click', (/**
                         * @param {?} ev
                         * @return {?}
                         */
                        (ev) => {
                            this.inputAppendClickEvent.emit(ev);
                        }));
                    }
                }
                this._appendType = value;
            }
        }
    }
    /**
     * @return {?}
     */
    get inputAppendType() {
        return this._appendType;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set inputAppendText(value) {
        if (value != this._inputAppendText) {
            this._inputAppendText = value;
            if (this.appendWrapElement && this._enableAppend) {
                this.render.removeChild(this.appendWrapElement, this.appendTextElement);
                this.appendTextElement.innerHTML = value;
                this.render.appendChild(this.appendWrapElement, this.appendTextElement);
            }
            else {
                this.createStruct();
            }
        }
    }
    /**
     * @return {?}
     */
    get inputAppendText() {
        return this._inputAppendText;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set inputAppendDisabled(value) {
        if (value != this._disabled) {
            this._disabled = value;
            if (this.appendWrapElement) {
                value && this.render.addClass(this.appendWrapElement, this.disabledCls);
                !value && this.render.removeClass(this.appendWrapElement, this.disabledCls);
            }
        }
    }
    /**
     * @return {?}
     */
    get inputAppendDisabled() {
        return this._disabled;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        //this.ngControl = this.injector.get(NgControl, null);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.createStruct();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        //this.resetStruct();
        if (this.clickHandler) {
            this.clickHandler();
            this.clickHandler = null;
        }
        if (this.appendWrapElement) {
            this.appendWrapElement.remove();
            this.appendWrapElement = null;
        }
        if (this.elWrapElement) {
            this.elWrapElement.remove();
            this.elWrapElement = null;
        }
    }
    /**
     * 重置
     * @private
     * @return {?}
     */
    resetStruct() {
        if (this.clickHandler) {
            this.clickHandler();
            this.clickHandler = null;
        }
        // 分类型移除不同新增加的结构或样式
        switch (this.inputAppendControlType) {
            case 'StaticText':
                this.render.removeClass(this.el.nativeElement, 'f-cmp-static-text-input-append');
                break;
            case 'TextBox':
            case 'MultiTextBox':
                if (this.elWrapElement) {
                    /** @type {?} */
                    let wrapParent = this.render.parentNode(this.elWrapElement);
                    this.render.appendChild(wrapParent, this.el.nativeElement);
                    this.elWrapElement.remove();
                    this.elWrapElement = null;
                }
                break;
        }
        if (this.appendWrapElement) {
            this.appendWrapElement.remove();
            this.appendWrapElement = null;
        }
    }
    /**
     * 创建
     * @private
     * @return {?}
     */
    createStruct() {
        if (!this.inputAppendText || !this.enableAppend || this.appendWrapElement) {
            return;
        }
        /** @type {?} */
        const buttonWrap = this.render.createElement('div');
        buttonWrap.className = 'input-group-append input-append-wrapper';
        buttonWrap.className += ' input-append-' + this.inputAppendType;
        if (this._disabled) {
            buttonWrap.className += ' ' + this.disabledCls;
        }
        /** @type {?} */
        const buttonTextWrap = this.render.createElement('div');
        buttonTextWrap.className = 'input-group-text';
        buttonTextWrap.innerHTML = this.inputAppendText;
        this.appendTextElement = buttonTextWrap;
        this.appendWrapElement = buttonWrap;
        this.render.appendChild(buttonWrap, buttonTextWrap);
        switch (this.inputAppendControlType) {
            case 'StaticText':
                // 此时还没有生成内部的样式
                // let textareaEl = this.el.nativeElement.querySelector('.f-form-control-textarea');
                this.render.addClass(this.el.nativeElement, 'f-cmp-static-text-input-append' + (this._disabled ? ' ' + this.disabledCls : ''));
                this.render.appendChild(this.el.nativeElement, buttonWrap);
                break;
            case 'TextBox':
            case 'MultiTextBox':
                /** @type {?} */
                let textParent = this.render.parentNode(this.el.nativeElement);
                /** @type {?} */
                const inputWrap = this.render.createElement('div');
                inputWrap.className = 'f-cmp-text-input-append' + (this._disabled ? ' ' + this.disabledCls : '');
                if (this.el.nativeElement.outerHTML.indexOf('textarea') > -1) {
                    inputWrap.className = 'f-cmp-textarea-input-append' + (this._disabled ? ' ' + this.disabledCls : '');
                }
                this.elWrapElement = inputWrap;
                this.render.appendChild(inputWrap, this.el.nativeElement);
                this.render.appendChild(inputWrap, buttonWrap);
                this.render.appendChild(textParent, inputWrap);
                break;
            default:
                // 存在类似下拉这样的控件，内部调用input-group结构还没有初始化
                /** @type {?} */
                let inputGroupEl = this.el.nativeElement.querySelector('.input-group');
                if (inputGroupEl) {
                    this.render.appendChild(inputGroupEl, buttonWrap);
                }
                else {
                    if (this.ngZone) {
                        this.ngZone.runOutsideAngular((/**
                         * @return {?}
                         */
                        () => {
                            setTimeout((/**
                             * @return {?}
                             */
                            () => {
                                /** @type {?} */
                                let inputGroupEl2 = this.el.nativeElement.querySelector('.input-group');
                                this.render.appendChild(inputGroupEl2, buttonWrap);
                            }));
                        }));
                    }
                }
        }
        if (this.inputAppendType == 'button') {
            this.clickHandler = this.render.listen(this.appendWrapElement, 'click', (/**
             * @param {?} ev
             * @return {?}
             */
            (ev) => {
                this.inputAppendClickEvent.emit(ev);
            }));
        }
    }
}
InputAppendDirective.decorators = [
    { type: Directive, args: [{
                selector: '[input-append]',
            },] }
];
/** @nocollapse */
InputAppendDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ElementRef },
    { type: Renderer2 },
    { type: Injector }
];
InputAppendDirective.propDecorators = {
    enableAppend: [{ type: Input, args: ['input-append',] }],
    inputAppendControlType: [{ type: Input }],
    inputAppendType: [{ type: Input }],
    inputAppendText: [{ type: Input }],
    inputAppendDisabled: [{ type: Input }],
    inputAppendClickEvent: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ShortCutTabKeyDirective {
    /**
     * @param {?} el
     * @param {?} injector
     * @param {?} eventManager
     */
    constructor(el, injector, eventManager) {
        this.el = el;
        this.injector = injector;
        this.eventManager = eventManager;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.eventManager.addEventListener(this.el.nativeElement, 'keydown', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            e.stopPropagation();
            if (e.key === 'Tab') {
                this.onTabKeydownHandler(e.target);
            }
        }));
    }
    /**
     * @private
     * @param {?} currentTarget
     * @return {?}
     */
    onTabKeydownHandler(currentTarget) {
        /** @type {?} */
        let allInputs = this.el.nativeElement.querySelectorAll('input,textarea');
        allInputs = Array.from(allInputs);
        /** @type {?} */
        const currentInputIndex = allInputs.findIndex((/**
         * @param {?} n
         * @return {?}
         */
        n => n === currentTarget));
        /** @type {?} */
        let nextInputIndex = currentInputIndex + 1;
        if (nextInputIndex >= allInputs.length) {
            nextInputIndex = 0;
        }
        /** @type {?} */
        const nextInputTarget = allInputs[nextInputIndex];
        if (nextInputTarget) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                nextInputTarget.focus();
            }));
        }
    }
}
ShortCutTabKeyDirective.decorators = [
    { type: Directive, args: [{
                selector: 'shortcut-tab',
            },] }
];
/** @nocollapse */
ShortCutTabKeyDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Injector },
    { type: EventManager }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FarrisFormsModule {
}
FarrisFormsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    RadioComponent,
                    RadioGroupComponent,
                    CheckboxComponent,
                    CheckboxGroupComponent,
                    RadioButtonComponent,
                    FarrisRadioGroupComponent,
                    FarrisCheckboxGroupComponent,
                    TextareaAutoSizeDirective,
                    TextareaZoomDirective,
                    ShortCutTabKeyDirective,
                    TextareaWordcountDirective,
                    InputAppendDirective
                ],
                imports: [
                    CommonModule,
                    FormsModule,
                    MessagerModule.forRoot(),
                    FarrisCommonModule.forRoot(),
                    LocaleModule
                ],
                exports: [
                    RadioComponent,
                    RadioGroupComponent,
                    CheckboxComponent,
                    CheckboxGroupComponent,
                    RadioButtonComponent,
                    FarrisRadioGroupComponent,
                    FarrisCheckboxGroupComponent,
                    TextareaAutoSizeDirective,
                    TextareaZoomDirective,
                    ShortCutTabKeyDirective,
                    TextareaWordcountDirective,
                    InputAppendDirective
                ],
                providers: [IdService],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { TextareaAutoSizeDirective, TextareaZoomDirective, ShortCutTabKeyDirective, TextareaWordcountDirective, InputAppendDirective, FarrisFormsModule, RadioComponent, RadioGroupComponent, FarrisRadioGroupComponent, RadioButtonComponent, CheckboxGroupComponent, CheckboxComponent, FarrisCheckboxGroupComponent };

//# sourceMappingURL=farris-ui-forms.js.map