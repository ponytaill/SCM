/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * @Author: 疯狂秀才(Lucas Huang)
 * @Date: 2019-08-15 17:31:08
 * @LastEditors: 疯狂秀才(Lucas Huang)
 * @LastEditTime: 2019-09-04 15:01:15
 * @QQ: 1055818239
 * @Version: v0.0.1
 */
import { Component, EventEmitter, Input, Output, ViewEncapsulation } from '@angular/core';
import { UtilService } from '../../services/public-api';
import { KeyCode } from '../../enums/public-api';
import { OPTS, MONTHS } from '../../constants/constants';
var MonthViewComponent = /** @class */ (function () {
    function MonthViewComponent(utilService) {
        this.utilService = utilService;
        this.months = [];
        this.monthCellClicked = new EventEmitter();
        this.monthCellKeyDown = new EventEmitter();
        this.onMouseEnter = new EventEmitter();
        this.onMouseLeave = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    MonthViewComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.hasOwnProperty(OPTS)) {
            this.opts = changes[OPTS].currentValue;
        }
        if (changes.hasOwnProperty(MONTHS)) {
            this.months = changes[MONTHS].currentValue;
        }
    };
    /**
     * @param {?} event
     * @param {?} cell
     * @return {?}
     */
    MonthViewComponent.prototype.onMonthCellClicked = /**
     * @param {?} event
     * @param {?} cell
     * @return {?}
     */
    function (event, cell) {
        event.stopPropagation();
        if (cell.disabled) {
            return;
        }
        this.monthCellClicked.emit(cell);
    };
    /**
     * @param {?} event
     * @param {?} cell
     * @return {?}
     */
    MonthViewComponent.prototype.onMonthCellKeyDown = /**
     * @param {?} event
     * @param {?} cell
     * @return {?}
     */
    function (event, cell) {
        /** @type {?} */
        var keyCode = this.utilService.getKeyCodeFromEvent(event);
        if (keyCode !== KeyCode.tab) {
            event.preventDefault();
            if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {
                this.onMonthCellClicked(event, cell);
            }
            else if (this.opts.moveFocusByArrowKeys) {
                this.monthCellKeyDown.emit(cell);
            }
        }
    };
    /**
     * @param {?} cell
     * @return {?}
     */
    MonthViewComponent.prototype.onMonthCellMouseEnter = /**
     * @param {?} cell
     * @return {?}
     */
    function (cell) {
        if (this.utilService.isInitializedDate(this.selectedDateRange.begin) &&
            !this.utilService.isInitializedDate(this.selectedDateRange.end)) {
            for (var i = 0; i < this.months.length; i++) {
                /** @type {?} */
                var row = this.months[i].row;
                for (var j = 0; j < row.length; j++) {
                    /** @type {?} */
                    var month = row[j];
                    month.range =
                        (this.utilService.isDateSameOrEarlier(this.selectedDateRange.begin, month.monthObj) &&
                            this.utilService.isDateSameOrEarlier(month.monthObj, cell.monthObj)) ||
                            (this.utilService.isDateSameOrEarlier(month.monthObj, this.selectedDateRange.begin) &&
                                this.utilService.isDateSameOrEarlier(cell.monthObj, month.monthObj));
                }
            }
            this.onMouseEnter.emit(cell);
        }
    };
    /**
     * @return {?}
     */
    MonthViewComponent.prototype.onMonthCellMouseLeave = /**
     * @return {?}
     */
    function () {
        for (var i = 0; i < this.months.length; i++) {
            /** @type {?} */
            var row = this.months[i].row;
            for (var j = 0; j < row.length; j++) {
                /** @type {?} */
                var month = row[j];
                month.range = false;
            }
        }
        this.onMouseLeave.emit();
    };
    /**
     * @param {?} date
     * @return {?}
     */
    MonthViewComponent.prototype.isMonthInRange = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return this.utilService.isDateInRange(date, this.selectedDateRange);
    };
    /**
     * @param {?} date
     * @return {?}
     */
    MonthViewComponent.prototype.isMonthSame = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return this.utilService.isDateSame({
            year: this.visibleMonth.year,
            month: this.visibleMonth.monthNbr
        }, date);
    };
    /**
     * @param {?} date
     * @return {?}
     */
    MonthViewComponent.prototype.isMonthRangeBeginOrEndSame = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return this.utilService.isDateRangeBeginOrEndSame(this.selectedDateRange, date);
    };
    MonthViewComponent.decorators = [
        { type: Component, args: [{
                    selector: 'lib-month-view',
                    template: "<div class=\"f-datepicker-table-wrapper\">\r\n    <table class=\"f-datepicker-table\">\r\n        <tbody>\r\n            <tr *ngFor=\"let mr of months; let mi = index\">\r\n                <td\r\n                    id=\"m_{{ mi }}_{{ i }}\"\r\n                    class=\"m_{{ mi }}_{{ i }}\"\r\n                    *ngFor=\"let m of mr.row; let i = index\"\r\n                    (click)=\"onMonthCellClicked($event, m)\"\r\n                    (keydown)=\"onMonthCellKeyDown($event, m)\"\r\n                    (mouseenter)=\"onMonthCellMouseEnter(m)\"\r\n                    (mouseleave)=\"onMonthCellMouseLeave()\"\r\n                    tabindex=\"0\"\r\n                    style=\"width: 33.3%\"\r\n                >\r\n                    <div class=\"f-datepicker-month\">\r\n                        <span\r\n                            class=\"f-datepicker-month-cell\"\r\n                            [ngClass]=\"{\r\n                                'f-datepicker-current':\r\n                                    m.currMonth && opts.markCurrentMonth,\r\n                                'f-datepicker-selected':\r\n                                    (!this.opts.dateRange &&\r\n                                        isMonthSame(m.monthObj)) ||\r\n                                    (this.opts.dateRange &&\r\n                                        isMonthRangeBeginOrEndSame(m.monthObj)),\r\n                                'f-datepicker-disabled': m.disabled,\r\n                                'f-datepicker-range':\r\n                                    isMonthInRange(m.monthObj) || m.range\r\n                            }\"\r\n                            >{{ m.name }}</span\r\n                        >\r\n                    </div>\r\n                </td>\r\n            </tr>\r\n        </tbody>\r\n    </table>\r\n</div>\r\n",
                    providers: [UtilService],
                    encapsulation: ViewEncapsulation.None
                }] }
    ];
    /** @nocollapse */
    MonthViewComponent.ctorParameters = function () { return [
        { type: UtilService }
    ]; };
    MonthViewComponent.propDecorators = {
        opts: [{ type: Input }],
        months: [{ type: Input }],
        selectedDate: [{ type: Input }],
        selectedDateRange: [{ type: Input }],
        visibleMonth: [{ type: Input }],
        monthCellClicked: [{ type: Output }],
        monthCellKeyDown: [{ type: Output }],
        onMouseEnter: [{ type: Output }],
        onMouseLeave: [{ type: Output }]
    };
    return MonthViewComponent;
}());
export { MonthViewComponent };
if (false) {
    /** @type {?} */
    MonthViewComponent.prototype.opts;
    /** @type {?} */
    MonthViewComponent.prototype.months;
    /** @type {?} */
    MonthViewComponent.prototype.selectedDate;
    /** @type {?} */
    MonthViewComponent.prototype.selectedDateRange;
    /** @type {?} */
    MonthViewComponent.prototype.visibleMonth;
    /** @type {?} */
    MonthViewComponent.prototype.monthCellClicked;
    /** @type {?} */
    MonthViewComponent.prototype.monthCellKeyDown;
    /** @type {?} */
    MonthViewComponent.prototype.onMouseEnter;
    /** @type {?} */
    MonthViewComponent.prototype.onMouseLeave;
    /**
     * @type {?}
     * @private
     */
    MonthViewComponent.prototype.utilService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9udGgtdmlldy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZmFycmlzL3VpLWRhdGVwaWNrZXIvIiwic291cmNlcyI6WyJsaWIvY29tcG9uZW50cy9tb250aC12aWV3L21vbnRoLXZpZXcuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQVFBLE9BQU8sRUFDSCxTQUFTLEVBQ1QsWUFBWSxFQUNaLEtBQUssRUFFTCxNQUFNLEVBRU4saUJBQWlCLEVBQ3BCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQVN4RCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDakQsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUV6RDtJQWtCSSw0QkFBb0IsV0FBd0I7UUFBeEIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFWbkMsV0FBTSxHQUF1QixFQUFFLENBQUM7UUFJL0IscUJBQWdCLEdBQW1DLElBQUksWUFBWSxFQUFvQixDQUFDO1FBQ3hGLHFCQUFnQixHQUFtQyxJQUFJLFlBQVksRUFBb0IsQ0FBQztRQUV4RixpQkFBWSxHQUFzQixJQUFJLFlBQVksRUFBTyxDQUFDO1FBQzFELGlCQUFZLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7SUFFcEIsQ0FBQzs7Ozs7SUFFakQsd0NBQVc7Ozs7SUFBWCxVQUFZLE9BQXNCO1FBQzlCLElBQUksT0FBTyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUM5QixJQUFJLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxZQUFZLENBQUM7U0FDMUM7UUFDRCxJQUFJLE9BQU8sQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDaEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMs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QixrQ0FBMEI7O0lBQzFCLG9DQUF5Qzs7SUFDekMsMENBQStCOztJQUMvQiwrQ0FBeUM7O0lBQ3pDLDBDQUFnQzs7SUFDaEMsOENBQWtHOztJQUNsRyw4Q0FBa0c7O0lBRWxHLDBDQUFvRTs7SUFDcEUsMENBQW9FOzs7OztJQUV4RCx5Q0FBZ0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG4gKiBAQXV0aG9yOiDnlq/ni4Lnp4DmiY0oTHVjYXMgSHVhbmcpXHJcbiAqIEBEYXRlOiAyMDE5LTA4LTE1IDE3OjMxOjA4XHJcbiAqIEBMYXN0RWRpdG9yczog55av54uC56eA5omNKEx1Y2FzIEh1YW5nKVxyXG4gKiBATGFzdEVkaXRUaW1lOiAyMDE5LTA5LTA0IDE1OjAxOjE1XHJcbiAqIEBRUTogMTA1NTgxODIzOVxyXG4gKiBAVmVyc2lvbjogdjAuMC4xXHJcbiAqL1xyXG5pbXBvcnQge1xyXG4gICAgQ29tcG9uZW50LFxyXG4gICAgRXZlbnRFbWl0dGVyLFxyXG4gICAgSW5wdXQsXHJcbiAgICBPbkNoYW5nZXMsXHJcbiAgICBPdXRwdXQsXHJcbiAgICBTaW1wbGVDaGFuZ2VzLFxyXG4gICAgVmlld0VuY2Fwc3VsYXRpb25cclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgVXRpbFNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9wdWJsaWMtYXBpJztcclxuaW1wb3J0IHtcclxuICAgIElNeUNhbGVuZGFyTW9udGgsXHJcbiAgICBJTXlPcHRpb25zLFxyXG4gICAgSU15RGF0ZSxcclxuICAgIElNeURhdGVSYW5nZSxcclxuICAgIElNeU1vbnRoUm93LFxyXG4gICAgSU15TW9udGhcclxufSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL3B1YmxpYy1hcGknO1xyXG5pbXBvcnQgeyBLZXlDb2RlIH0gZnJvbSAnLi4vLi4vZW51bXMvcHVibGljLWFwaSc7XHJcbmltcG9ydCB7IE9QVFMsIE1PTlRIUyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9jb25zdGFudHMnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ2xpYi1tb250aC12aWV3JyxcclxuICAgIHRlbXBsYXRlVXJsOiAnLi9tb250aC12aWV3LmNvbXBvbmVudC5odG1sJyxcclxuICAgIHByb3ZpZGVyczogW1V0aWxTZXJ2aWNlXSxcclxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcclxufSlcclxuZXhwb3J0IGNsYXNzIE1vbnRoVmlld0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XHJcbiAgICBASW5wdXQoKSBvcHRzOiBJTXlPcHRpb25zO1xyXG4gICAgQElucHV0KCkgbW9udGhzOiBBcnJheTxJTXlNb250aFJvdz4gPSBbXTtcclxuICAgIEBJbnB1dCgpIHNlbGVjdGVkRGF0ZTogSU15RGF0ZTtcclxuICAgIEBJbnB1dCgpIHNlbGVjdGVkRGF0ZVJhbmdlOiBJTXlEYXRlUmFuZ2U7XHJcbiAgICBASW5wdXQoKSB2aXNpYmxlTW9udGg6IElNeU1vbnRoO1xyXG4gICAgQE91dHB1dCgpIG1vbnRoQ2VsbENsaWNrZWQ6IEV2ZW50RW1pdHRlcjxJTXlDYWxlbmRhck1vbnRoPiA9IG5ldyBFdmVudEVtaXR0ZXI8SU15Q2FsZW5kYXJNb250aD4oKTtcclxuICAgIEBPdXRwdXQoKSBtb250aENlbGxLZXlEb3duOiBFdmVudEVtaXR0ZXI8SU15Q2FsZW5kYXJNb250aD4gPSBuZXcgRXZlbnRFbWl0dGVyPElNeUNhbGVuZGFyTW9udGg+KCk7XHJcblxyXG4gICAgQE91dHB1dCgpIG9uTW91c2VFbnRlcjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcclxuICAgIEBPdXRwdXQoKSBvbk1vdXNlTGVhdmU6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XHJcblxyXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB1dGlsU2VydmljZTogVXRpbFNlcnZpY2UpIHsgfVxyXG5cclxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkIHtcclxuICAgICAgICBpZiAoY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eShPUFRTKSkge1xyXG4gICAgICAgICAgICB0aGlzLm9wdHMgPSBjaGFuZ2VzW09QVFNdLmN1cnJlbnRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoYW5nZXMuaGFzT3duUHJvcGVydHkoTU9OVEhTKSkge1xyXG4gICAgICAgICAgICB0aGlzLm1vbnRocyA9IGNoYW5nZXNbTU9OVEhTXS5jdXJyZW50VmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uTW9udGhDZWxsQ2xpY2tlZChldmVudDogYW55LCBjZWxsOiBJTXlDYWxlbmRhck1vbnRoKTogdm9pZCB7XHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgIGlmIChjZWxsLmRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMubW9udGhDZWxsQ2xpY2tlZC5lbWl0KGNlbGwpO1xyXG4gICAgfVxyXG5cclxuICAgIG9uTW9udGhDZWxsS2V5RG93bihldmVudDogS2V5Ym9hcmRFdmVudCwgY2VsbDogSU15Q2FsZW5kYXJNb250aCkge1xyXG4gICAgICAgIGNvbnN0IGtleUNvZGU6IG51bWJlciA9IHRoaXMudXRpbFNlcnZpY2UuZ2V0S2V5Q29kZUZyb21FdmVudChldmVudCk7XHJcbiAgICAgICAgaWYgKGtleUNvZGUgIT09IEtleUNvZGUudGFiKSB7XHJcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5Q29kZS5lbnRlciB8fCBrZXlDb2RlID09PSBLZXlDb2RlLnNwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uTW9udGhDZWxsQ2xpY2tlZChldmVudCwgY2VsbCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRzLm1vdmVGb2N1c0J5QXJyb3dLZXlzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vbnRoQ2VsbEtleURvd24uZW1pdChjZWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uTW9udGhDZWxsTW91c2VFbnRlcihjZWxsOiBhbnkpOiB2b2lkIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHRoaXMudXRpbFNlcnZpY2UuaXNJbml0aWFsaXplZERhdGUodGhpcy5zZWxlY3RlZERhdGVSYW5nZS5iZWdpbikgJiZcclxuICAgICAgICAgICAgIXRoaXMudXRpbFNlcnZpY2UuaXNJbml0aWFsaXplZERhdGUodGhpcy5zZWxlY3RlZERhdGVSYW5nZS5lbmQpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tb250aHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCByb3cgPSB0aGlzLm1vbnRoc1tpXS5yb3c7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBtb250aCA9IHJvd1tqXTtcclxuICAgICAgICAgICAgICAgICAgICBtb250aC5yYW5nZSA9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLnV0aWxTZXJ2aWNlLmlzRGF0ZVNhbWVPckVhcmxpZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZVJhbmdlLmJlZ2luLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGgubW9udGhPYmpcclxuICAgICAgICAgICAgICAgICAgICAgICAgKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51dGlsU2VydmljZS5pc0RhdGVTYW1lT3JFYXJsaWVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoLm1vbnRoT2JqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwubW9udGhPYmpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLnV0aWxTZXJ2aWNlLmlzRGF0ZVNhbWVPckVhcmxpZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb250aC5tb250aE9iaixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlUmFuZ2UuYmVnaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51dGlsU2VydmljZS5pc0RhdGVTYW1lT3JFYXJsaWVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwubW9udGhPYmosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGgubW9udGhPYmpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub25Nb3VzZUVudGVyLmVtaXQoY2VsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIG9uTW9udGhDZWxsTW91c2VMZWF2ZSgpOiB2b2lkIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubW9udGhzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCByb3cgPSB0aGlzLm1vbnRoc1tpXS5yb3c7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbW9udGggPSByb3dbal07XHJcbiAgICAgICAgICAgICAgICBtb250aC5yYW5nZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub25Nb3VzZUxlYXZlLmVtaXQoKTtcclxuICAgIH1cclxuICAgIGlzTW9udGhJblJhbmdlKGRhdGU6IElNeURhdGUpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51dGlsU2VydmljZS5pc0RhdGVJblJhbmdlKGRhdGUsIHRoaXMuc2VsZWN0ZWREYXRlUmFuZ2UpO1xyXG4gICAgfVxyXG4gICAgaXNNb250aFNhbWUoZGF0ZTogSU15RGF0ZSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnV0aWxTZXJ2aWNlLmlzRGF0ZVNhbWUoXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHllYXI6IHRoaXMudmlzaWJsZU1vbnRoLnllYXIsXHJcbiAgICAgICAgICAgICAgICBtb250aDogdGhpcy52aXNpYmxlTW9udGgubW9udGhOYnJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGF0ZVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbiAgICBpc01vbnRoUmFuZ2VCZWdpbk9yRW5kU2FtZShkYXRlOiBJTXlEYXRlKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXRpbFNlcnZpY2UuaXNEYXRlUmFuZ2VCZWdpbk9yRW5kU2FtZShcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGVSYW5nZSxcclxuICAgICAgICAgICAgZGF0ZVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuIl19