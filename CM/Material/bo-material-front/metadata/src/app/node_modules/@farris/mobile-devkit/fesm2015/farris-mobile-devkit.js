import { of, from, Subject, Observable, BehaviorSubject, EMPTY as EMPTY$1 } from 'rxjs';
import { switchMap, map, concatMap, tap, every, take, throwIfEmpty, takeLast } from 'rxjs/operators';
import axios from 'axios';
import 'reflect-metadata';
import { format, parseISO, isDate, isEqual as isEqual$1, compareAsc } from 'date-fns';
import dayjs from 'dayjs';
import IsBetween from 'dayjs/plugin/IsBetween';
import relativeTime from 'dayjs/plugin/relativeTime';
import Calendar from 'dayjs/plugin/calendar';
import 'dayjs/locale/zh-cn';

const Type = Function;
var DataChangeType;
(function (DataChangeType) {
    DataChangeType[DataChangeType["Add"] = 0] = "Add";
    DataChangeType[DataChangeType["Delete"] = 1] = "Delete";
})(DataChangeType || (DataChangeType = {}));

function isType(v) {
    return typeof v === 'function';
}
var InjectFlags;
(function (InjectFlags) {
    InjectFlags[InjectFlags["Default"] = 0] = "Default";
    InjectFlags[InjectFlags["Self"] = 1] = "Self";
    InjectFlags[InjectFlags["SkipSelf"] = 2] = "SkipSelf";
    InjectFlags[InjectFlags["Optional"] = 4] = "Optional";
})(InjectFlags || (InjectFlags = {}));

const EMPTY = [];
const IDENT = function (value) {
    return value;
};
const CIRCULAR = IDENT;
const MULTI_PROVIDER_FN = function () {
    return Array.prototype.slice.call(arguments);
};
const NEW_LINE = /\n/gm;
const NO_NEW_LINE = 'ɵ';
const _THROW_IF_NOT_FOUND = {};
const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
const NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';

function stringify(token) {
    if (typeof token === 'string') {
        return token;
    }
    if (Array.isArray(token)) {
        return '[' + token.map(stringify).join(', ') + ']';
    }
    if (token == null) {
        return '' + token;
    }
    if (token.overriddenName) {
        return `${token.overriddenName}`;
    }
    if (token.name) {
        return `${token.name}`;
    }
    const res = token.toString();
    if (res == null) {
        return '' + res;
    }
    const newLineIndex = res.indexOf('\n');
    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
}
function getClosureSafeProperty(objWithPropertyToExtract) {
    for (const key in objWithPropertyToExtract) {
        if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
            return key;
        }
    }
    throw Error('Could not find renamed property on target object.');
}
function formatError(text, obj, injectorErrorName, source = null) {
    text = text && text.charAt(0) === '\n' && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;
    let context = stringify(obj);
    if (Array.isArray(obj)) {
        context = obj.map(stringify).join(' -> ');
    }
    else if (typeof obj === 'object') {
        const parts = [];
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                const value = obj[key];
                parts.push(key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));
            }
        }
        context = `{${parts.join(', ')}}`;
    }
    return `${injectorErrorName}${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\n  ')}`;
}
function staticError(text, obj) {
    return new Error(formatError(text, obj, 'StaticInjectorError'));
}

function ɵɵdefineInjectable(opts) {
    return {
        token: opts.token,
        providedIn: opts.providedIn || null,
        factory: opts.factory,
        value: undefined,
    };
}
const NG_PROV_DEF = getClosureSafeProperty({ ɵprov: getClosureSafeProperty });
const NG_INJ_DEF = getClosureSafeProperty({ ɵinj: getClosureSafeProperty });
const NG_INJECTABLE_DEF = getClosureSafeProperty({ ngInjectableDef: getClosureSafeProperty });
function getOwnDefinition(type, def) {
    return def && def.token === type ? def : null;
}
function getInjectableDef(type) {
    return getOwnDefinition(type, type[NG_PROV_DEF]) ||
        getOwnDefinition(type, type[NG_INJECTABLE_DEF]);
}

class InjectionToken {
    constructor(_desc, options) {
        this._desc = _desc;
        this.ngMetadataName = 'InjectionToken';
        this.ɵprov = undefined;
        if (typeof options === 'number') {
            this.__NG_ELEMENT_ID__ = options;
        }
        else if (options !== undefined) {
            this.ɵprov = ɵɵdefineInjectable({
                token: this,
                providedIn: options.providedIn || 'root',
                factory: options.factory,
            });
        }
    }
    toString() {
        return `InjectionToken ${this._desc}`;
    }
}
function createInjectionToken(token) {
    return new InjectionToken(token);
}

/**
 * 注入器抽象类
 */
class Injector {
}

class NullInjector {
    get(token, notFoundValue = THROW_IF_NOT_FOUND) {
        if (notFoundValue === THROW_IF_NOT_FOUND) {
            const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
            error.name = 'NullInjectorError';
            throw error;
        }
        return notFoundValue;
    }
}
const NULL_INJECTOR = new NullInjector();

const __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });
function resolveForwardRef(type) {
    return isForwardRef(type) ? type() : type;
}
function forwardRef(forwardRefFn) {
    forwardRefFn.__forward_ref__ = forwardRef;
    forwardRefFn.toString = function () {
        return stringify(this());
    };
    return forwardRefFn;
}
function isForwardRef(fn) {
    return typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) &&
        fn.__forward_ref__ === forwardRef;
}

const INJECTOR = new InjectionToken('INJECTOR', -1);
const ɵ0 = getClosureSafeProperty;
const USE_VALUE = getClosureSafeProperty({ provide: String, useValue: ɵ0 });
let _currentInjector = undefined;
function setCurrentInjector(injector) {
    const former = _currentInjector;
    _currentInjector = injector;
    return former;
}
class StaticInjector {
    constructor(providers, parent = NULL_INJECTOR, source = null) {
        parent = parent ? parent : NULL_INJECTOR;
        this.parent = parent;
        this.source = source;
        const records = this._records = new Map();
        records.set(Injector, { token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false });
        records.set(INJECTOR, { token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false });
        this.scope = recursivelyProcessProviders(records, providers);
    }
    get(token, notFoundValue, flags = InjectFlags.Default) {
        const records = this._records;
        let record = records.get(token);
        if (record === undefined) {
            const injectableDef = getInjectableDef(token);
            if (injectableDef) {
                const providedIn = injectableDef && injectableDef.providedIn;
                if (providedIn === 'any' || providedIn != null && providedIn === this.scope) {
                    records.set(token, record = resolveProvider({ provide: token, useFactory: injectableDef.factory, deps: EMPTY }));
                }
            }
            if (record === undefined) {
                records.set(token, null);
            }
        }
        const lastInjector = setCurrentInjector(this);
        try {
            return tryResolveToken(token, record, records, this.parent, notFoundValue, flags);
        }
        catch (e) {
            throw e;
        }
        finally {
            setCurrentInjector(lastInjector);
        }
    }
    toString() {
        const tokens = [];
        const records = this._records;
        records.forEach((v, token) => tokens.push(stringify(token)));
        return `StaticInjector[${tokens.join(', ')}]`;
    }
}
function multiProviderMixError(token) {
    return staticError('Cannot mix multi providers and regular providers', token);
}
const INJECTOR_SCOPE = new InjectionToken('Set Injector scope.');
/**
 * 递归处理Provider
 */
function recursivelyProcessProviders(records, provider) {
    let scope = null;
    if (provider) {
        provider = resolveForwardRef(provider);
        if (Array.isArray(provider)) {
            for (let i = 0; i < provider.length; i++) {
                scope = recursivelyProcessProviders(records, provider[i]) || scope;
            }
        }
        else if (typeof provider === 'function') {
            throw staticError('Function/Class not supported', provider);
        }
        else if (provider && typeof provider === 'object' && provider.provide) {
            let token = resolveForwardRef(provider.provide);
            const resolvedProvider = resolveProvider(provider);
            // multi
            if (provider.multi === true) {
                let multiProvider = records.get(token);
                if (multiProvider) {
                    if (multiProvider.fn !== MULTI_PROVIDER_FN) {
                        throw multiProviderMixError(token);
                    }
                }
                else {
                    records.set(token, multiProvider = {
                        token: provider.provide,
                        deps: [],
                        useNew: false,
                        fn: MULTI_PROVIDER_FN,
                        value: EMPTY
                    });
                }
                token = provider;
                multiProvider.deps.push({ token, options: 6 /* Default */ });
            }
            const record = records.get(token);
            if (record && record.fn === MULTI_PROVIDER_FN) {
                throw multiProviderMixError(token);
            }
            if (token === INJECTOR_SCOPE) {
                scope = resolvedProvider.value;
            }
            records.set(token, resolvedProvider);
        }
        else {
            throw staticError('Unexpected provider', provider);
        }
    }
    return scope;
}
function resolveProvider(provider) {
    const deps = computeDeps(provider);
    let fn = IDENT;
    let value = EMPTY;
    let useNew = false;
    const provide = resolveForwardRef(provider.provide);
    if (USE_VALUE in provider) {
        value = provider.useValue;
    }
    else if (provider.useFactory) {
        fn = provider.useFactory;
    }
    else if (provider.useExisting) {
        // Just use IDENT
    }
    else if (provider.useClass) {
        // 静态类型
        useNew = true;
        fn = resolveForwardRef(provider.useClass);
    }
    else if (typeof provide === 'function') {
        // 构造函数
        useNew = true;
        fn = provide;
    }
    else {
        throw staticError('StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable', provider);
    }
    return { deps, fn, useNew, value };
}
/**
 * 计算依赖
 */
function computeDeps(provider) {
    let deps = EMPTY;
    const providerDeps = provider.deps;
    if (providerDeps && providerDeps.length) {
        deps = [];
        for (let i = 0; i < providerDeps.length; i++) {
            const options = 6 /* Default */;
            const token = resolveForwardRef(providerDeps[i]);
            deps.push({ token, options });
        }
    }
    else if (provider.useExisting) {
        const token = resolveForwardRef(provider.useExisting);
        deps = [{ token, options: 6 /* Default */ }];
    }
    else if (!providerDeps && !(USE_VALUE in provider)) {
        // useValue & useExisting are the only ones which are exempt from deps all others need it.
        throw staticError('\'deps\' required', provider);
    }
    return deps;
}
function tryResolveToken(token, record, records, parent, notFoundValue, flags) {
    try {
        return resolveToken(token, record, records, parent, notFoundValue, flags);
    }
    catch (e) {
        if (!(e instanceof Error)) {
            e = new Error(e);
        }
        const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
        path.unshift(token);
        // 清空循环引用的值
        if (record && record.value === CIRCULAR) {
            record.value = EMPTY;
        }
        throw e;
    }
}
function resolveToken(token, record, records, parent, notFoundValue, flags) {
    let value;
    if (record && !(flags & InjectFlags.SkipSelf)) {
        value = record.value;
        if (value === CIRCULAR) {
            throw Error(NO_NEW_LINE + 'Circular dependency');
        }
        else if (value === EMPTY) {
            record.value = CIRCULAR;
            const useNew = record.useNew;
            const fn = record.fn;
            const depRecords = record.deps;
            let deps = EMPTY;
            if (depRecords.length) {
                deps = [];
                for (let i = 0; i < depRecords.length; i++) {
                    const depRecord = depRecords[i];
                    const options = depRecord.options;
                    const childRecord = options & 2 /* CheckSelf */ ? records.get(depRecord.token) : undefined;
                    deps.push(tryResolveToken(depRecord.token, childRecord, records, !childRecord && !(options & 4 /* CheckParent */) ? NULL_INJECTOR : parent, options & 1 /* Optional */ ? null : THROW_IF_NOT_FOUND, InjectFlags.Default));
                }
            }
            record.value = value = useNew ? new fn(...deps) : fn.apply(undefined, deps);
        }
    }
    else if (!(flags & InjectFlags.Self)) {
        value = parent.get(token, notFoundValue, InjectFlags.Default);
    }
    else if (!(flags & InjectFlags.Optional)) {
        value = NULL_INJECTOR.get(token, notFoundValue);
    }
    else {
        value = NULL_INJECTOR.get(token, typeof notFoundValue !== 'undefined' ? notFoundValue : null);
    }
    return value;
}

function INJECTOR_IMPL__PRE_R3__(providers, parent, name) {
    return new StaticInjector(providers, parent, name);
}
const INJECTOR_IMPL = INJECTOR_IMPL__PRE_R3__;
function createInjector(options, parent) {
    if (Array.isArray(options)) {
        return INJECTOR_IMPL(options, parent, '');
    }
    else {
        return INJECTOR_IMPL(options.providers, options.parent, options.name || '');
    }
}

const ANNOTATIONS = '__annotations__';
const PARAMETERS = '__parameters__';
const PROP_METADATA = '__prop__metadata__';
/**
 * @suppress {globalThis}
 */
function makeDecorator(name, props, parentClass, chainFn, typeFn) {
    const metaCtor = makeMetadataCtor(props);
    function DecoratorFactory(...args) {
        if (this instanceof DecoratorFactory) {
            metaCtor.call(this, ...args);
            return this;
        }
        const annotationInstance = new DecoratorFactory(...args);
        const typeDecorator = function createTypeDecorator(cls) {
            typeFn && typeFn(cls, ...args);
            // Use of Object.defineProperty is important since it creates non-enumerable property which
            // prevents the property is copied during subclassing.
            const annotations = cls.hasOwnProperty(ANNOTATIONS) ?
                cls[ANNOTATIONS] :
                Object.defineProperty(cls, ANNOTATIONS, { value: [] })[ANNOTATIONS];
            annotations.push(annotationInstance);
            return cls;
        };
        if (chainFn) {
            chainFn(typeDecorator);
        }
        return typeDecorator;
    }
    if (parentClass) {
        DecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    DecoratorFactory.prototype.ngMetadataName = name;
    DecoratorFactory.annotationCls = DecoratorFactory;
    return DecoratorFactory;
}
function makeMetadataCtor(props) {
    return function ctor(...args) {
        if (props) {
            const values = props(...args);
            // tslint:disable-next-line:forin
            for (const propName in values) {
                this[propName] = values[propName];
            }
        }
    };
}
function makeParamDecorator(name, props, parentClass) {
    const metaCtor = makeMetadataCtor(props);
    function ParamDecoratorFactory(...args) {
        if (this instanceof ParamDecoratorFactory) {
            metaCtor.apply(this, args);
            return this;
        }
        const annotationInstance = new ParamDecoratorFactory(...args);
        ParamDecorator.annotation = annotationInstance;
        return ParamDecorator;
        function ParamDecorator(cls, unusedKey, index) {
            // Use of Object.defineProperty is important since it creates non-enumerable property which
            // prevents the property is copied during subclassing.
            const parameters = cls.hasOwnProperty(PARAMETERS) ?
                cls[PARAMETERS] :
                Object.defineProperty(cls, PARAMETERS, { value: [] })[PARAMETERS];
            // there might be gaps if some in between parameters do not have annotations.
            // we pad with nulls.
            while (parameters.length <= index) {
                parameters.push(null);
            }
            (parameters[index] = parameters[index] || []).push(annotationInstance);
            return cls;
        }
    }
    if (parentClass) {
        ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    ParamDecoratorFactory.prototype.ngMetadataName = name;
    ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
    return ParamDecoratorFactory;
}
function makePropDecorator(name, props, parentClass) {
    const metaCtor = makeMetadataCtor(props);
    function PropDecoratorFactory(...args) {
        if (this instanceof PropDecoratorFactory) {
            metaCtor.apply(this, args);
            return this;
        }
        const decoratorInstance = new PropDecoratorFactory(...args);
        // tslint:disable-next-line:no-shadowed-variable
        return function PropDecorator(target, name) {
            const constructor = target.constructor;
            // Use of Object.defineProperty is important since it creates non-enumerable property which
            // prevents the property is copied during subclassing.
            const meta = constructor.hasOwnProperty(PROP_METADATA) ?
                constructor[PROP_METADATA] :
                Object.defineProperty(constructor, PROP_METADATA, { value: {} })[PROP_METADATA];
            meta[name] = meta.hasOwnProperty(name) && meta[name] || [];
            meta[name].unshift(decoratorInstance);
        };
    }
    if (parentClass) {
        PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
    }
    PropDecoratorFactory.prototype.ngMetadataName = name;
    PropDecoratorFactory.annotationCls = PropDecoratorFactory;
    return PropDecoratorFactory;
}

/**
 * 元数据解析
 * 约束：
 * 1、类型装饰器：在某个类型上，某种类型的装饰器，只使用一次，不重复添加；
 * 2、属性装饰器：在某个属性上，某种类型的装饰器，只使用一次，不重复添加
 */
class MetadataUtil {
    // ----------------------------------------
    // 类型元数据
    // ----------------------------------------
    /**
     * 获取类元数据
     * 返回结果形如：
     * [
     *   Injectable
     *   NgViewModel
     *   NgViewModel
     * ]
     */
    static getClassMetadatas(constructor) {
        const metadatas = constructor[ANNOTATIONS];
        return metadatas;
    }
    /**
     * 获取某个class上的某种装饰器
     * 返回结果：NgViewModel
     */
    static getClassMetadataByName(constructor, metadataName) {
        const metadata = this.getClassMetadataByNameWithTranslate(constructor, metadataName, null, null);
        return metadata;
    }
    static getClassMetadataByNameWithTranslate(constructor, metadataName, translateService, keysToTranslate) {
        const allClassMetadatas = this.getClassMetadatas(constructor);
        if (!allClassMetadatas) {
            return null;
        }
        const metadata = allClassMetadatas.find((classMetadata) => {
            return classMetadata.ngMetadataName === metadataName;
        });
        if (metadata && translateService && keysToTranslate) {
            keysToTranslate.forEach((metadataPropKey) => {
                const propertyVariable = metadata[metadataPropKey];
                if (propertyVariable && propertyVariable.startsWith('{{') && propertyVariable.endsWith('}}')) {
                    const translateKey = propertyVariable.replace('{{', '').replace('}}', '').trim();
                    metadata[metadataPropKey] = translateService.transform(translateKey, null);
                }
            });
        }
        return metadata;
    }
    // ----------------------------------------
    // 属性元数据
    // ----------------------------------------
    /**
     * 获取所有属性的所有元数据
     * 返回格式：
     * {
     *   propName1: [ NgDefaultValue, NgMaxLength, NgMinLength],
     *   propName2: [ NgDefaultValue, NgMaxLength, NgMinLength]
     * }
     */
    static getPropsMetadatas(constructor) {
        const allPropMetadatas = constructor[PROP_METADATA];
        return allPropMetadatas;
    }
    /**
     * 获取所有属性的某一类型的元数据
     * 如果同一属性
     * 返回结果：
     * {
     *    propName1: NgDefaultValue,
     *    propName2: NgDefaultValue
     * }
     */
    static getPropsMetadatasByName(constructor, metadataName) {
        const metadatas = this.getPropsMetadatasByNameWithTranslate(constructor, metadataName);
        return metadatas;
    }
    static getPropsMetadatasByNameWithTranslate(constructor, metadataName, translateService, keysToTranslate) {
        const metadatas = {};
        // 读取构造函数中存储的类属性注解。
        const allPropMetadatas = this.getPropsMetadatas(constructor);
        if (!allPropMetadatas) {
            return metadatas;
        }
        // 遍历所有属性提取注解信息。
        Object.keys(allPropMetadatas).forEach((propName) => {
            // 提取当前属性注解对象
            const propMetadatas = allPropMetadatas[propName];
            // 提取指定类型的注解项
            const metadata = propMetadatas.find((propMetadata) => {
                return propMetadata.ngMetadataName === metadataName;
            });
            if (translateService && keysToTranslate) {
                keysToTranslate.forEach((metadataPropKey) => {
                    const propertyVariable = metadata[metadataPropKey];
                    if (propertyVariable && propertyVariable.startsWith('{{') && propertyVariable.endsWith('}}')) {
                        const translateKey = propertyVariable.replace('{{', '').replace('}}', '').trim();
                        metadata[metadataPropKey] = translateService.transform(translateKey, null);
                    }
                });
            }
            if (metadata) {
                metadatas[propName] = metadata;
            }
        });
        return metadatas;
    }
    /**
     * 获取某个属性的所有元数据
     * 返回格式：[ NgDefaultValue, NgMaxLength, NgMinLength]
     */
    static getPropMetadatasByName(constructor, propName) {
        // 暂不实现
        return null;
    }
    /**
     * 获取某个属性的某种元数据
     * 返回格式：NgDefaultValue
     */
    static getPropMetadataByName(constructor, propName, metadataName) {
        // 暂不实现
        return null;
    }
}

/**
 * HttpMethods
 */
class HttpMethods {
}
HttpMethods.GET = 'GET';
HttpMethods.DELETE = 'DELETE';
HttpMethods.HEAD = 'HEAD';
HttpMethods.OPTIONS = 'OPTIONS';
HttpMethods.POST = 'POST';
HttpMethods.PUT = 'PUT';
HttpMethods.PATCH = 'PATCH';
HttpMethods.LINK = 'LINK';
HttpMethods.UNLINK = 'UNLINK';

class HttpUtil {
    /**
     * 追加Header
     */
    static appendHeader(headers, key, value) {
        headers = Object.assign({}, headers, { [key]: value });
        return headers;
    }
    /**
     * 向RequestConfig中追加body
     */
    static appendBodyToRequestConfig(body, requestConfig) {
        if (!requestConfig) {
            requestConfig = {};
        }
        requestConfig = Object.assign({}, requestConfig, { body: body });
        return requestConfig;
    }
    /**
     * 构造AxiosReqeustConfig
     */
    static buildAxiosRequestConfig(method, url, requestConfig) {
        requestConfig = requestConfig || {};
        const axiosRequestConfig = {
            url: url,
            method: method,
            params: requestConfig.params || null,
            headers: requestConfig.headers || null,
            responseType: requestConfig.responseType || 'json',
            data: requestConfig.body || null
        };
        return axiosRequestConfig;
    }
    /**
     * 构造Http响应信息
     */
    static buildHttpResponse(axiosResponse) {
        const httpResponse = {
            body: axiosResponse.data,
            headers: axiosResponse.headers,
            status: axiosResponse.status,
            statusText: axiosResponse.statusText
        };
        return httpResponse;
    }
}

/**
 * HttpClient
 */
class HttpClient {
    /**
     * 构造函数
     */
    constructor() {
        this.axiosInstance = axios.create();
    }
    /**
     * 发送GET请求
     */
    get(url, requestConfig) {
        return this.request('GET', url, requestConfig);
    }
    /**
     * 发送POST请求
     */
    post(url, body, requestConfig) {
        requestConfig = HttpUtil.appendBodyToRequestConfig(body, requestConfig);
        return this.request('POST', url, requestConfig);
    }
    /**
     * 发送PUT请求
     */
    put(url, body, requestConfig) {
        requestConfig = HttpUtil.appendBodyToRequestConfig(body, requestConfig);
        return this.request('PUT', url, requestConfig);
    }
    /**
     * 发送PATCH请求
     */
    patch(url, body, requestConfig) {
        requestConfig = HttpUtil.appendBodyToRequestConfig(body, requestConfig);
        return this.request('PATCH', url, requestConfig);
    }
    /**
     * 发送DELETE请求
     */
    delete(url, requestConfig) {
        return this.request('DELETE', url, requestConfig);
    }
    /**
     * 发送请求
     */
    request(method, url, requestConfig) {
        const request$ = of(true).pipe(switchMap(() => {
            const axiosRequestConfig = HttpUtil.buildAxiosRequestConfig(method, url, requestConfig);
            return from(this.axiosInstance.request(axiosRequestConfig));
        }));
        return request$.pipe(map((axiosResponse) => {
            const httpResponse = HttpUtil.buildHttpResponse(axiosResponse);
            return requestConfig.observe === 'response' ? httpResponse : axiosResponse.data;
        }));
    }
}

const HTTP_PROVIDERS = [
    { provide: HttpClient, useClass: HttpClient, deps: [] }
];

/**
 * 变更记录
 */
class Modification {
    /**
     * 构造函数
     * @param value 新值
     * @param modifyType 变更类型
     * @param path 变更路径
     * @param preValue 旧值
     */
    constructor(value, modifyType, path, preValue) {
        this.type = modifyType;
        this.value = value;
        this.preValue = preValue;
        this.path = path;
    }
}
/**
 * 变更类型
 */
var ModifyType;
(function (ModifyType) {
    /**
     * 添加
     */
    ModifyType["Add"] = "ADD";
    /**
     * 删除
     */
    ModifyType["Remove"] = "REMOVE";
    /**
     * 修改
     */
    ModifyType["ValueChange"] = "VALUE_CHANGE";
    /**
     * 加载
     */
    ModifyType["Load"] = "LOAD";
    /**
     * 未改变
     */
    ModifyType["UnChanged"] = "UNCHANGED";
    /**
     * 分页信息变更
     */
    ModifyType["PaginationInfoChange"] = "PAGINATION_INFO_CHANGE";
})(ModifyType || (ModifyType = {}));

/*
 * @Author: Lucus, Witt
 * @Date: 2018-10-30 15:53:59
 * @Last Modified by: Witt
 * @Last Modified time: 2018-11-08 17:25:08
 */
function isEqual(value, other) {
    return JSON.stringify(value) === JSON.stringify(other);
}
/**
 * 实体数据变更集
 */
class ChangeSet {
    constructor() {
        /**
         * 变更集合
         */
        this.modifications = [];
    }
    /**
     *  获取所有的变更记录
     */
    get changes() {
        return this.modifications;
    }
    /**
     * 将变更集添加到集合中
     * ### 使用示例
     * ```
     * const changeSet = new ChangeSet();
     * const modify = new Modification('newValue', ModifyType.ValueChange, [1, 'title'], 'oldValue');
     * changeSet.append(modify)
     * ```
     * @param changeItem 变更数据
     */
    append(modification) {
        switch (modification.type) {
            case ModifyType.ValueChange:
                this.appendValueChangeModification(modification);
                break;
            case ModifyType.Add:
                this.appendAddModification(modification);
                break;
            case ModifyType.Remove:
                this.appendRemoveModification(modification);
                break;
            case ModifyType.Load:
                break;
            default:
                throw new Error('不支持此类型的变更');
        }
    }
    /**
     * 添加值变化变更
     */
    appendValueChangeModification(modification) {
        const value = modification.value;
        const existedModification = this.findModifyItemsPath(modification.path);
        if (existedModification) {
            // 如果存在相同路径的ValueChange类型的变更集，则更新值；
            existedModification.value = value;
        }
        else {
            const existedAddModification = this.findNewAddItemsPath(modification.path);
            if (existedAddModification) {
                // @todo：
                // 1、此处逻辑有问题，value是个字符串，不能直接assign；
                // 2、之所以没有出现问题，是因为都是服务器端新增，新增后，客户端清空了所有变更。
                // 如果存在涵盖该ValueChange变更的Add变更，则更新Add变更对应的数据；
                existedAddModification.value = Object.assign({}, existedAddModification.value, value);
            }
            else {
                // 其他情况，新增一条ValueChange变更。
                this.modifications.push(modification);
            }
        }
    }
    /**
     * 添加新增变更
     */
    appendAddModification(modification) {
        const value = modification.value;
        const existedModification = this.findNewAddItemsPath(modification.path);
        if (existedModification) {
            // 1、如果已经存在相同路径的Add变更，则合并Value。
            existedModification.value = existedModification.value.concat(value);
        }
        else {
            // 2、如果没有，则新增一条Add变更。
            this.modifications.push(modification);
        }
    }
    /**
     * 添加删除变更
     */
    appendRemoveModification(modification) {
        const path = modification.path;
        const primaryKey = Object.keys(modification.value)[0];
        const primaryKeyValue = modification.value[primaryKey];
        // 1、存在相同path的新增变更，移除新增变更，不需要添加删除变更；
        // @todo：待重构（1、只考虑了主从情况，2、临时用多重循环实现）
        this.modifications.forEach((addModification) => {
            // 只处理新增变更
            if (addModification.type !== ModifyType.Add) {
                return;
            }
            // @todo 只考虑主从结构，再深的层次暂不考虑
            if (isEqual(addModification.path, path) === false) {
                return;
            }
            // 遍历新增新增变更的value（value是个数组），移除相匹配的新增删除
            addModification.value = addModification.value.filter((addDataItem) => {
                return addDataItem[primaryKey] !== primaryKeyValue;
            });
        });
        // 2、移除对应的修改变更
        const fullRemovePath = path.concat(`${primaryKey}:${primaryKeyValue}`);
        this.modifications = this.modifications.filter((valueModification) => {
            if (valueModification.type !== ModifyType.ValueChange) {
                return true;
            }
            const valueChangePath = Array.from(valueModification.path);
            valueChangePath.pop();
            // 路径相同进行移除
            const isToRemove = isEqual(valueChangePath, fullRemovePath);
            return !isToRemove;
        });
        // 先删除下级删除变更，再插入
        // 主要针对从从表删除之后，又删除子表时，根实体上还存在从从表删除变更的场景
        this.removeDescendantRemoveModifications(modification);
        this.modifications.push(modification);
    }
    /**
     * 清空变更集合
     */
    clear() {
        this.modifications = [];
    }
    /**
     * 根据path获取Add类型的变更记录
     * @param path 变更路径
     */
    findNewAddItemsPath(path) {
        return this.modifications.find((value, index) => {
            return isEqual(path, value.path) && value.type === ModifyType.Add;
        });
    }
    /**
     * 根据path获取ValueChange类型的变更记录
     * @param path 变更路径
     */
    findModifyItemsPath(path) {
        return this.modifications.find((value, index) => {
            return isEqual(path, value.path) && value.type === ModifyType.ValueChange;
        });
    }
    /**
     * 删除后代（包括自己）所有的删除变更
     * @todo：临时做一个最小化修改
     */
    removeDescendantRemoveModifications(parentRemoveModification) {
        const parentPathWithId = this.createRemovePathWithId(parentRemoveModification);
        // 删除后代修改变更
        this.modifications = this.modifications.filter((modification) => {
            if (modification.type !== ModifyType.Remove) {
                return true;
            }
            const descendantPathWithId = this.createRemovePathWithId(modification);
            const isDescendant = this.isDescendantPath(parentPathWithId, descendantPathWithId);
            return !isDescendant;
        });
    }
    /**
     * 获取删除路径的完整格式
     * @summary
     * 1、目前删除变更的路径标记到父集合；
     * 2、为了方便比较，将被删除的数据id加入到路径中
     */
    createRemovePathWithId(modification) {
        const path = modification.path;
        const primaryKey = Object.keys(modification.value)[0];
        const primaryKeyValue = modification.value[primaryKey];
        const pathWithId = path.concat([`${primaryKey}:${primaryKeyValue}`]);
        return pathWithId;
    }
    /**
     * 判断是否是后代节点路径
     * @param parentPath 父节点路径
     * @param descendantPath 后代节点
     */
    isDescendantPath(parentPath, descendantPath) {
        if (parentPath.length > descendantPath.length) {
            return false;
        }
        let isDescendantPath = true;
        parentPath.forEach((parentPathItem, parentPathItemIndex) => {
            if (parentPathItem !== descendantPath[parentPathItemIndex]) {
                isDescendantPath = false;
                return;
            }
        });
        return isDescendantPath;
    }
}

/*
 * @Author: Witt
 * @Date: 2018-12-27 09:25:38
 * @Last Modified by: Witt
 * @Last Modified time: 2018-12-27 09:39:10
 */
/**
 * 路径类型
 */
var DataPathNodeType;
(function (DataPathNodeType) {
    /**
     * 标记该节点是一个实体主键值，用来在列表上定位一个实体
     */
    DataPathNodeType["DataId"] = "DataId";
    /**
     * 标记该节点是一个属性名，用来在对象上定位一个属性
     */
    DataPathNodeType["PropName"] = "PropName";
})(DataPathNodeType || (DataPathNodeType = {}));
/**
 * 路径节点
 */
class DataPathNode {
    /**
     * 构造函数
     */
    constructor(type, data) {
        this.type = type;
        this.value = data;
        this.prev = null;
        this.next = null;
    }
}

/*
 * @Author: Witt
 * @Date: 2018-12-27 09:26:41
 * @Last Modified by: Witt
 * @Last Modified time: 2019-01-15 22:00:45
 */
/**
 * 变更路径（简单双向列表）
 */
class DataPath {
    /**
     * 构造函数
     */
    constructor() {
        this.head = new DataPathNode(null, null);
        this.length = 0;
    }
    /**
     * 添加一个节点到头部
     */
    unshift(type, data) {
        const newNode = new DataPathNode(type, data);
        newNode.next = this.head.next;
        newNode.prev = this.head;
        this.head.next = newNode;
        if (newNode.next) {
            newNode.next.prev = newNode;
        }
        this.length++;
    }
    /**
     * 在链表最后追加一个节点
     */
    push(type, data) {
        const tailNode = this.getTail();
        const newNode = new DataPathNode(type, data);
        tailNode.next = newNode;
        this.length++;
    }
    /**
     * 获取链表尾部节点
     */
    getTail() {
        let lastNode = this.head;
        while (lastNode.next) {
            lastNode = lastNode.next;
        }
        return lastNode;
    }
    /**
     * 转换为数组格式
     */
    toArray() {
        const pathArray = [];
        let currentNode = this.head.next;
        while (currentNode) {
            pathArray.push(`${currentNode.type}:${currentNode.value}`);
            currentNode = currentNode.next;
        }
        return pathArray;
    }
    /**
     * 转换为字符串格式
     */
    toString() {
        const pathArray = this.toArray();
        const pathString = pathArray.join(', ');
        return `[${pathString}]`;
    }
    /**
     * 拷贝
     */
    clone() {
        const newDataPath = new DataPath();
        let curDataNode = this.head.next;
        while (curDataNode) {
            newDataPath.push(curDataNode.type, curDataNode.value);
            curDataNode = curDataNode.next;
        }
        return newDataPath;
    }
}

/*
 * @Author: Witt
 * @Date: 2019-08-14 14:11:51
 * @Last Modified by: Witt
 * @Last Modified time: 2019-08-14 16:11:51
 */
/**
 * 实体属性分组
 */
var DataPropGroup;
(function (DataPropGroup) {
    /**
     * 简单类型
     */
    DataPropGroup["Primitive"] = "Primitive";
    /**
     * 实体类型
     */
    DataPropGroup["Object"] = "Object";
    /**
     * 动态实体类型
     */
    DataPropGroup["Dynamic"] = "Dynamic";
    /**
     * 列表类型
     */
    DataPropGroup["List"] = "List";
})(DataPropGroup || (DataPropGroup = {}));
/**
 * 实体属性信息
 */
class DataPropInfo {
}

/**
 * 元数据名称
 */
const PRIMITIVE_PROP_META = 'PrimitivePropMeta';
/**
 * 【简单属性装饰器工厂】的工厂
 */
function makePrimitivePropMetaDecorator(options) {
    let metadata = {
        primary: false,
        foreign: false
    };
    if (options) {
        const paramType = typeof options;
        switch (paramType) {
            case 'boolean':
                metadata.primary = Boolean(options);
                break;
            case 'string':
                metadata.dataField = String(options);
                break;
            case 'object':
                metadata = Object.assign(metadata, options);
                break;
        }
    }
    return metadata;
}
/**
 * 简单属性装饰器工厂
 */
const PrimitivePropMeta = makePropDecorator(PRIMITIVE_PROP_META, makePrimitivePropMetaDecorator);

class StringUtil {
    /**
       * 字符串格式化
       */
    static format(value, options) {
        return value.toString();
    }
}

class NumberUtil {
    /**
       * 数字格式化
       * {
       *   precision: 2,
       *   decimal: true,
       *   thousand: ','
       *   prefix: '',
       *   suffix: ''
       * }
       */
    static format(value, options) {
        // 参数处理
        let decimals = (options.precision || options.precision === 0) ? options.precision : 2;
        let decimalPoint = options.decimal || '.';
        let thousandsSep = options.thousand || '';
        let prefix = options.prefix || '';
        let suffix = options.suffix || '';
        let prefixType = options.prefixType;
        if (prefixType == "dynamic" && options.prefix) {
            // 表示前缀为一个函数  那么执行函数定义
            let prefixFunc = new Function("return " + options.prefix);
            prefix = prefixFunc()(options.sourceData);
        }
        value = (value + '').replace(/[^0-9+-Ee.]/g, '');
        let s;
        // 处理精度
        let toFixedFix = function (n, prec) {
            var k = Math.pow(10, prec);
            return '' + parseFloat(Math.round(parseFloat((n * k).toFixed(prec * 2))).toFixed(prec * 2)) / k;
        };
        s = ((decimals || decimals === 0) ? toFixedFix(value, decimals) : '' + Math.round(value)).split('.');
        // 处理千分位
        if (thousandsSep) {
            let pattern = /(-?\d+)(\d{3})/;
            while (pattern.test(s[0])) {
                s[0] = s[0].replace(pattern, "$1" + thousandsSep + "$2");
            }
            if ((s[1] || '').length < decimals) {
                s[1] = s[1] || '';
                s[1] += new Array(decimals - s[1].length + 1).join('0');
            }
        }
        let formatedValue = s.join(decimalPoint);
        formatedValue = `${prefix}${formatedValue}${suffix}`;
        return formatedValue;
    }
}

/**
 * 布尔工具类
 */
class BoolUtil {
    /**
     * 布尔值格式化
    */
    static format(value, options) {
        if (value === true) {
            return '是';
        }
        else {
            return '否';
        }
    }
}

class EnumUtil {
    /**
     * 枚举格式化
     * {
     *  enumData: [
     *    {value: 'value1', name: 'name1'},
     *    {value: 'value2', name: 'name2'}
     *  ]
     * }
     */
    static format(value, options) {
        const enumOptions = options.enumData;
        const targetEnumOption = enumOptions.find((enumOption) => {
            return enumOption.value === value;
        });
        if (!targetEnumOption) {
            console.error(`找不到${value}对应的枚举选项`);
            return value;
        }
        return targetEnumOption.name;
    }
}

dayjs.locale('zh-cn');
/**
 * 日期处理类
 */
class DateUtil {
    /**
     * 将日期（或日期字符串）转换为完整的的ISO格式的字符串
     */
    static formatISO(dateOrDateString) {
        if (this.isEmptyDateOrDateString(dateOrDateString) === true) {
            return this.emptyISODateTimeString;
        }
        const dateObj = this.parse(dateOrDateString);
        return format(dateObj, this.defaultISOFormat);
    }
    /**
     * 将日期（或日期字符串）转换为指定格式的字符串
     * @param dateOrDateString 日期对象或符合ISO8601规范的日期字符串
     * @param dateFormat 日期格式字符串
     */
    static format(dateOrDateString, dateFormat) {
        if (this.isEmptyDateOrDateString(dateOrDateString) === true) {
            return this.emptyISODateTimeString;
        }
        const dateObj = this.parse(dateOrDateString);
        dateFormat = dateFormat ? dateFormat : this.defaultDisplayFormat;
        return format(dateObj, dateFormat);
    }
    static dateShow(dateOrDateString, type) {
        if (this.isEmptyDateOrDateString(dateOrDateString) === true) {
            return this.emptyISODateTimeString;
        }
        if (!type || "" === type) {
            return;
        }
        return this[type] && this[type](dateOrDateString);
    }
    static dateOperation(dateOrDateString, options) {
        if (this.isEmptyDateOrDateString(dateOrDateString) === true) {
            return this.emptyISODateTimeString;
        }
        const { type = "", option } = options;
        if (!type || "" === type) {
            return;
        }
        if ('isSame' === type) {
            return this[type] && this[type](dateOrDateString, options['targetDate'], options['granularity']);
        }
        if ('isBefore' === type) {
            return this[type] && this[type](dateOrDateString, options['targetDate'], options['granularity']);
        }
        if ('isAfter' === type) {
            return this[type] && this[type](dateOrDateString, options['targetDate'], options['granularity']);
        }
        if ('isBetween' === type) {
            return this[type] && this[type](dateOrDateString, options['targetDate'], options['targetDate2'], options['granularity'], options['contains']);
        }
        if (!option) {
            return this[type] && this[type](dateOrDateString);
        }
        return this[type] && this[type](dateOrDateString, option);
    }
    static relativeTime(dateOrDateString, option) {
        dayjs.extend(relativeTime);
        const dateObj = dayjs(dateOrDateString);
        if (!option) {
            return dayjs(dateObj).fromNow();
        }
        return dayjs(dateObj).fromNow(option);
    }
    static isToday(dateOrDateString) {
        const todayDate = new Date();
        const dateObj = dayjs(dateOrDateString);
        return this.isSame(dateObj, todayDate, 'date');
    }
    static calendar(dateOrDateString, option) {
        const dateObj = dayjs(dateOrDateString);
        dayjs.extend(Calendar);
        if (option) {
            return dayjs().calendar(dateObj, Object.assign({}, option));
        }
        return dayjs().calendar(dateObj, {
            sameDay: '[今天] HH:mm',
            nextDay: '[明天] HH:mm',
            lastDay: '[昨天] HH:mm',
            sameElse: 'YYYY-MM-DD'
        });
    }
    /**
     * 创建日期
     * @param dateOrDateString 日期对象或符合ISO8601规范的日期字符串
     */
    static parse(dateOrDateString) {
        if (this.isEmptyDateOrDateString(dateOrDateString) === true) {
            return null;
        }
        if (this.isDate(dateOrDateString) === true) {
            return dateOrDateString;
        }
        return parseISO(dateOrDateString);
    }
    /**
     * 是否是日期对象
     */
    static isDate(date) {
        return isDate(date);
    }
    /**
     * 是否是空日期或者空日期字符串
     * @param dateOrDateString 日期或日期字符串
     */
    static isEmptyDateOrDateString(dateOrDateString) {
        if (this.isDate(dateOrDateString) === true) {
            return this.isEmptyDate(dateOrDateString);
        }
        return this.isEmptyDateString(dateOrDateString);
    }
    /**
     * 是否为空日期字符串
     * @param date 日期对象
     */
    static isEmptyDate(date) {
        if (!date) {
            return true;
        }
        return false;
    }
    /**
     * 是否是空日期字符串
     * @param dateString 日期字符串
     */
    static isEmptyDateString(dateString) {
        if (!dateString || dateString.startsWith('0001-01-01') === true) {
            return true;
        }
        return false;
    }
    /**
     * 两个日期是否相等
     * @param dateOrDateString1 日期对象或字符串
     * @param dateOrDateString1 日期对象或字符串
     * @return 相等返回true，否则返回false
     */
    static isEqual(dateOrDateString1, dateOrDateString2) {
        const dateObj1 = this.parse(dateOrDateString1);
        const dateObj2 = this.parse(dateOrDateString2);
        if (dateObj1 === dateObj2) {
            return true;
        }
        return isEqual$1(dateObj1, dateObj2);
    }
    /**
     * 两个日期是否相等
     * @param dateOrDateString1 日期对象或字符串
     * @param dateOrDateString1 日期对象或字符串
     * @return 返回-1、0、1
     */
    static compare(dateOrDateString1, dateOrDateString2) {
        const dateObj1 = this.parse(dateOrDateString1);
        const dateObj2 = this.parse(dateOrDateString2);
        if (this.isEqual(dateObj1, dateObj2) === true) {
            return 0;
        }
        // 处理解析后为null的场景，null比所有有效日期小
        if (!dateObj1 && this.isDate(dateObj2) === true) {
            return -1;
        }
        if (!dateObj2 && this.isDate(dateObj1) === true) {
            return 1;
        }
        return compareAsc(dateObj1, dateObj2);
    }
    /**
     *
     * @param currentDate 当前日期
     * @param targetDate 目标日期
     * @param type 比较类型 date	D	天00:00 day	d	星期00:00 month	M	月第一天00:00 year	y	1月1日00点 week	w	周第一天00:00hour	h	00:00:00minute	m	00:00second	s	00millisecond	ms	0
     * @returns
     */
    static isSame(currentDate, targetDate, type) {
        if (type) {
            return dayjs(currentDate).isSame(dayjs(targetDate), type);
        }
        return dayjs(currentDate).isSame(dayjs(targetDate));
    }
    /**
     *
     * @param currentDate 当前日期
     * @param targetDate 目标日期
     * @returns boolean
     */
    static isBefore(currentDate, targetDate, type) {
        if (type) {
            return dayjs(currentDate).isBefore(dayjs(targetDate), type);
        }
        return dayjs(currentDate).isBefore(dayjs(targetDate));
    }
    /**
   *
   * @param currentDate 当前日期
   * @param targetDate 目标日期
   * @returns boolean
   */
    static isAfter(currentDate, targetDate, type) {
        if (type) {
            return dayjs(currentDate).isAfter(dayjs(targetDate), type);
        }
        return dayjs(currentDate).isAfter(dayjs(targetDate));
    }
    /**
     *
     * @param currentDate
     * @param targetDate1
     * @param targetDate2
     * @returns
     */
    static isBetween(currentDate, targetDate1, targetDate2, type, contains) {
        dayjs.extend(IsBetween);
        if (type) {
            return dayjs(currentDate).isBetween(dayjs(targetDate1), dayjs(targetDate2), type, contains);
        }
        return dayjs(currentDate).isBetween(dayjs(targetDate1), dayjs(targetDate2), null, contains);
    }
}
/**
 * 空日期字符串（N版）
 * @todo：兼容服务器端，不应该在devkit体现这种兼容，待移除
 */
// static emptyDateTimeString = '0001-01-01T00:00:00';
DateUtil.emptyDateTimeString = null;
/**
 * 默认空日期字符串（ISO标准格式）
 */
// static emptyISODateTimeString = '0001-01-01T00:00:00+00:00';
DateUtil.emptyISODateTimeString = null;
/**
 * 默认日期听格式
 */
DateUtil.defaultISOFormat = `yyyy-MM-dd'T'HH:mm:ssxxx`;
DateUtil.defaultDisplayFormat = 'yyyy-MM-dd HH:mm:ss';
DateUtil.defaultDateFormat = 'yyyy-MM-dd';
DateUtil.defaultTimeFormat = 'HH:mm:ss';

class ArrayUtil {
    /**
     * 从数组中删除一项
     */
    static remove(arr, itemToRemove) {
        const indexToRemove = arr.findIndex((item) => {
            return item === itemToRemove;
        });
        this.removeByIndex(arr, indexToRemove);
    }
    /**
     * 从数组中删除indexToRemove对应的项
     * @param index
     */
    static removeByIndex(arr, indexToRemove) {
        if (!arr || arr[indexToRemove] !== undefined) {
        }
        arr.splice(indexToRemove, 1);
    }
}

class ObjectUtil {
    /**
     * 检查是否是简单对象
     */
    static isPlainObject(value) {
        if (!(typeof value === 'object' && value !== null) || Object.prototype.toString.call({}) !== '[object Object]') {
            return false;
        }
        if (Object.getPrototypeOf(value) === null) {
            return true;
        }
        let proto = value;
        while (Object.getPrototypeOf(proto) !== null) {
            proto = Object.getPrototypeOf(proto);
        }
        return Object.getPrototypeOf(value) === proto;
    }
}

/**
 * 数据路径处理
 */
class BindingPathConverter {
    /**
     * (BindingPathString | BindingPathArray) => BindingPathArray
     * @param bindingPath BindingPath的字符串或者数组格式
     * @return BindingPath数组
     */
    static toBindingPathArray(bindingPath) {
        let bindingPathArray;
        if (typeof bindingPath === 'string') {
            bindingPathArray = bindingPath.split('/').filter((part) => {
                return part !== '';
            });
            return bindingPathArray;
        }
        else {
            bindingPathArray = bindingPath.concat([]);
        }
        return bindingPathArray;
    }
    /**
     * BindingPathArray => BindingPathString
     */
    static toBindingPathString(bindingPathArray) {
        return '/' + bindingPathArray.join('/');
    }
}

/**
 * BindingPath比较器
 */
class BindingPathComparer {
    /**
     * 是否相等
     */
    static isEqual(srcPath, dstPath) {
        const srcPathArray = BindingPathConverter.toBindingPathArray(srcPath);
        const dstPathArray = BindingPathConverter.toBindingPathArray(dstPath);
        const isEqual = srcPathArray.every((srcPathItem, srcPathIndex) => {
            return srcPathItem === dstPathArray[srcPathIndex];
        });
        return isEqual;
    }
    /**
     * 是否是父路径
     */
    static isParent(childPath, parentPath) {
        const childPathArray = BindingPathConverter.toBindingPathArray(childPath);
        const parentPathArray = BindingPathConverter.toBindingPathArray(parentPath);
        // 长度差1个
        if (childPathArray.length !== parentPathArray.length + 1) {
            return;
        }
        return this.isAncestor(childPath, parentPath);
    }
    /**
     * 是否是祖先路径
     */
    static isAncestor(descendantPath, ancestorPath) {
        const descendantPathArray = BindingPathConverter.toBindingPathArray(descendantPath);
        const ancestorPathArray = BindingPathConverter.toBindingPathArray(ancestorPath);
        if (descendantPath.length <= ancestorPathArray.length) {
            return false;
        }
        const isAncestor = ancestorPathArray.every((ancestorPathItem, ancestorPathIndex) => {
            return ancestorPathItem === descendantPathArray[ancestorPathIndex];
        });
        return isAncestor;
    }
}

/**
 * BindingPath遍历器
 */
class BindingPathTraverser {
    /**
     * 获取叶子节点的Path
     */
    static getLeafPathString(bindingPath) {
        const bindingPathArray = BindingPathConverter.toBindingPathArray(bindingPath);
        return bindingPathArray.pop();
    }
    /**
     * 获取父路径
     */
    static getParentPathString(bindingPath) {
        const bindingPathArray = BindingPathConverter.toBindingPathArray(bindingPath);
        bindingPathArray.pop();
        return '/' + bindingPathArray.join('/');
    }
}

/**
 * 变更相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * 绑定数据变更类型
 */
var ChangeType;
(function (ChangeType) {
    ChangeType["Load"] = "Load";
    ChangeType["Append"] = "Append";
    ChangeType["Remove"] = "Remove";
    ChangeType["SelectionChanged"] = "SelectionChanged";
    ChangeType["ValueChanged"] = "ValueChanged";
    ChangeType["UpdateErrors"] = "UpdateErrors";
    ChangeType["GlobalSelectionChanged"] = "GlobalSelectionChanged";
    /**
     * 分页信息变化
     */
    ChangeType["PaginationInfoChange"] = "PaginationInfoChange";
})(ChangeType || (ChangeType = {}));
/**
 * 视图变更类型
 */
var ViewChangeType;
(function (ViewChangeType) {
    ViewChangeType[ViewChangeType["ValueChanged"] = 0] = "ValueChanged";
})(ViewChangeType || (ViewChangeType = {}));

/**
 * 绑定属性相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * 属性类型
 */
var BindingPropertyType;
(function (BindingPropertyType) {
    /**
     * 简单类型
     */
    BindingPropertyType["Plain"] = "Plain";
    /**
     * 对象类型
     */
    BindingPropertyType["Object"] = "Object";
    /**
     * 列表类型
     */
    BindingPropertyType["List"] = "List";
    /**
     * 动态类型
     */
    BindingPropertyType["Dynamic"] = "Dynamic";
})(BindingPropertyType || (BindingPropertyType = {}));

/**
 * 属性工具类
 */
class PropertyUtil {
    /**
     * 获取实体上的属性集合，并将他们转换成BindingProperty集合
     * @param  entityType 实体类型
     * @returns 绑定属性集合
     */
    static getProperties(entityType) {
        const properties = [];
        // Plain
        const ngFieldProperties = FieldMetadataUtil.getNgFields(entityType);
        Object.keys(ngFieldProperties).forEach((propertyName) => {
            const ngFieldProperty = ngFieldProperties[propertyName];
            properties.push({
                name: propertyName,
                type: BindingPropertyType.Plain,
                isPrimaryKey: ngFieldProperty.primary,
                isForeignKey: ngFieldProperty.foreign,
                enableMultiLangInput: ngFieldProperty.enableMultiLangInput
            });
        });
        // Object
        const ngObjectProperties = FieldMetadataUtil.getNgObjects(entityType);
        Object.keys(ngObjectProperties).forEach((propertyName) => {
            const ngObjectProperty = ngObjectProperties[propertyName];
            properties.push({
                name: propertyName,
                type: BindingPropertyType.Object,
                entityType: ngObjectProperty.type
            });
        });
        // List
        const ngListProperties = FieldMetadataUtil.getNgList(entityType);
        Object.keys(ngListProperties).forEach((propertyName) => {
            const ngListProperty = ngListProperties[propertyName];
            properties.push({
                name: propertyName,
                type: BindingPropertyType.List,
                entityType: ngListProperty.type
            });
        });
        // Dynamics
        const ngDynamicProperties = FieldMetadataUtil.getNgDynamic(entityType);
        Object.keys(ngDynamicProperties).forEach((propertyName) => {
            const ngDynamicProperty = ngDynamicProperties[propertyName];
            properties.push({
                name: propertyName,
                type: BindingPropertyType.Dynamic,
                entityType: ngDynamicProperty.type
            });
        });
        return properties;
    }
    static getDynamicProperties(dynamicData) {
        const properties = [];
        Object.keys(dynamicData).forEach((propertyName) => {
            if (dynamicData.hasOwnProperty(propertyName)) {
                if (dynamicData[propertyName] instanceof Object) {
                    properties.push({
                        name: propertyName,
                        type: BindingPropertyType.Dynamic,
                        entityType: null
                    });
                }
                else {
                    properties.push({
                        name: propertyName,
                        type: BindingPropertyType.Plain,
                        isPrimaryKey: false,
                        isForeignKey: false
                    });
                }
            }
        });
        return properties;
    }
    /**
     * 根据属性名获取属性
     */
    static getPropertyByName(properties, propertyName) {
        const targetProperty = properties.find((property) => {
            return property.name === propertyName;
        });
        return targetProperty;
    }
    /**
     * 获取实体主键名
     * @param properties 属性集合
     * @returns 主键名
     */
    static getPrimaryKey(properties) {
        // 实体必须有主键，如果没有主键在构造实体的时候就已经报错，这里不需要再进行检查
        const primaryProperty = properties.find((property) => {
            return property.isPrimaryKey === true;
        });
        return primaryProperty ? primaryProperty.name : '';
    }
}

/**
 * BindingObject相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * BindingObject是Entity在绑定层的一个影射，它将Entity内的数据转换为不可变对象，并用于界面绑定。
 */
class BindingObject {
    /**
     * 构造函数
     * @param properties 属性集合
     */
    constructor(properties) {
        /**
         * 标识是否提交过
         */
        this.isShowValidationMsg = false;
        /**
         * 以{ [propertyName]: FormControl }的形式存放每条数据的control
         */
        this.controlMap = {};
        this.properties = properties;
        this.primaryKey = PropertyUtil.getPrimaryKey(properties);
        this.innerValues = new Map();
        this.changes = new Subject();
        this.viewChanges = new Subject();
    }
    /**
     * 主键值
     */
    get primaryKeyValue() {
        return this.primaryKey ? this.getValue(this.primaryKey) : '';
    }
    /**
     * 设置是否提交过
     */
    setShowValidationMsg(flag) {
        this.isShowValidationMsg = flag;
    }
    /**
     * 根据属性名获取属性值
     * @param   propertyName 属性名
     * @returns 属性值
     */
    getValue(propertyName) {
        return this.innerValues.get(propertyName);
    }
    /**
     * 设置属性值
     * @param propertyName        属性名
     * @param propertyValue       属性值
     * @param emitEventToView     是否通知View层去更新界面，默认为false
     * @param emitEventToEntity   是否通知Entity层去更新值，默认为false
     * @param errors              错误消息
     * @param invokeOnValueChange 值变化事件执行句柄
     */
    setValue(propertyName, propertyValue, emitEventToView = false, emitEventToEntity = false, errors, invokeOnValueChange) {
        const oldPropertyValue = this.getValue(propertyName);
        // 由于特定原因（@邵珠强），无法屏蔽oldPropertyValue === propertyValue
        if (oldPropertyValue === propertyValue) {
            return;
        }
        if (!invokeOnValueChange || oldPropertyValue === propertyValue) {
            // 设定缺省
            invokeOnValueChange = function (preValue, value, entityChanged) {
                return of(true);
            };
        }
        if (emitEventToEntity === true) {
            // BUG 322301，删除@2019.08.10; 如果无对应实体，则中止值传递; 这种情况发生在带从表的单据新增，从表响应Load变化的情况；
            // if(!this.innerValues.has(propertyName)) {
            //   return;
            // }
            // 执行实体值变化前事件
            invokeOnValueChange(oldPropertyValue, propertyValue, false).subscribe((result) => {
                if (result) {
                    // 如果成功，执行变化，并通知实体变化
                    this.innerValues = this.innerValues.set(propertyName, propertyValue);
                    const viewChange = {
                        type: ViewChangeType.ValueChanged,
                        path: [propertyName],
                        value: propertyValue,
                        errors: errors
                    };
                    this.viewChanges.next(viewChange);
                    // 如果需要通知视图，通知视图相应修改
                    if (emitEventToView === true) {
                        this.changes.next({
                            type: ChangeType.ValueChanged,
                            path: [propertyName],
                            value: propertyValue,
                            id: this.primaryKeyValue,
                            errors: errors
                        });
                    }
                    // 执行实体值变化后事件
                    invokeOnValueChange(oldPropertyValue, propertyValue, true).subscribe();
                }
                else {
                    // 如果失败，不再通知实体变化
                    // 并执行界面回滚操作
                    this.changes.next({
                        type: ChangeType.ValueChanged,
                        path: [propertyName],
                        value: oldPropertyValue,
                        id: this.primaryKeyValue,
                        errors: errors
                    });
                }
            });
        }
        else {
            // `emitEventToEntity === false`, 则认定实体值已经发生变化，通知视图变化，并触发实体值变化后事件
            this.innerValues = this.innerValues.set(propertyName, propertyValue);
            if (emitEventToView === true) {
                this.changes.next({
                    type: ChangeType.ValueChanged,
                    path: [propertyName],
                    value: propertyValue,
                    id: this.primaryKeyValue,
                    errors: errors
                });
            }
            // 执行实体值变化后事件
            invokeOnValueChange(oldPropertyValue, propertyValue, true).subscribe();
        }
    }
    /**
     * 将BindingObject实例转换成JSON对象
     */
    toJSON(options) {
        const langCode = window.localStorage.getItem('languageCode') || 'zh-CHS';
        const result = {};
        this.properties.forEach((property) => {
            const propName = property.name;
            if (property.type === BindingPropertyType.List) {
                const list = this[propName];
                result[propName] = list.toJSON(options);
            }
            else if (property.type === BindingPropertyType.Object) {
                const object = this[propName];
                result[propName] = object.toJSON(options);
            }
            else if (property.type === BindingPropertyType.Dynamic) {
                const object = this[propName];
                result[propName] = object.toJSON(options);
            }
            else {
                // 1、对于多语录入字段；
                // 2、传入ignoreMultiLangInput标志，则取当前语言的值给控件。
                if (options && options.ignoreMultiLangInput === true && property.enableMultiLangInput === true) {
                    const multiLangValueObj = this.getValue(propName);
                    if (multiLangValueObj) {
                        result[propName] = multiLangValueObj[langCode];
                    }
                    else {
                        result[propName] = multiLangValueObj;
                    }
                }
                else {
                    result[propName] = this.getValue(propName);
                }
            }
        });
        return result;
    }
}

/**
 * 绑定列表工厂相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * BindingList工厂用于创建一个空的BindingList对象，并将当前行的属性影射到BindingList对象上。
 *
 * **示例代码**
 * ```ts
 * const deptProperties: BindingProperty[] = PropertyUtil.getProperties(DeptEntity);
 * const deptList = BindingListFactory.create(deptProperties);
 * ```
 */
class BindingListFactory {
    /**
     * 创建BindingList实例，并扩展其属性
     * @param bindingProperties 绑定属性集合
     */
    static create(bindingProperties) {
        const bindingList = new BindingList(bindingProperties);
        this.extendProperties(bindingList, bindingProperties);
        return bindingList;
    }
    /**
     * 扩展BindingList属性，将当前行上的属性映射到列表上
     * @param bindingList       要扩展的绑定列表
     * @param bindingProperties 绑定属性集合
     */
    static extendProperties(bindingList, bindingProperties) {
        bindingProperties.forEach((bindingProperty) => {
            const propertyName = bindingProperty.name;
            Object.defineProperty(bindingList, propertyName, {
                get: () => {
                    return bindingList.currentItem[propertyName];
                }
            });
        });
    }
}

/**
 * 绑定对象工厂相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * BindingObject工厂用于创建一个空的BindingObject对象，并对其属性进行扩展。
 *
 * **扩展属性处理**
 *
 * 对于要扩展的属性（BindingProperty）有三种处理：
 * - 普通属性：初始化为一个undefined，并包装get、set方法，通过set方法监听变更；
 * - 对象属性：初始化为一个空的BindingObject对象，并监听子对象的变更；
 * - 列表属性：初始化为一个空的BindingList对象，并监听子列表的变更；
 *
 * **示例代码**
 *
 * ```ts
 *  const empProperties = PropertyUtil.getProperties(EmpEntity);
 * const empBindingObject = BindingObjectFactory.create(properties);
 * ```
 */
class BindingObjectFactory {
    /**
     * 创建BindingObject实例
     * @param properties 要扩展的属性集合
     * @returns 带扩展属性的空BindingObject对象
     * @
     */
    static create(properties) {
        const object = new BindingObject(properties);
        this.extendProperties(object, properties);
        return object;
    }
    static createDynamicBindingObject(data) {
        const properties = PropertyUtil.getDynamicProperties(data);
        const object = new BindingObject(properties);
        this.extendProperties(object, properties);
        return object;
    }
    /**
     * 扩展属性绑定对象的属性
     * @param object     要扩展的绑定对象
     * @param properties 绑定属性集合
     */
    static extendProperties(object, properties) {
        // 扩展BindingObject属性
        properties.forEach((property) => {
            if (property.type === BindingPropertyType.List) {
                this.extendListProperty(object, property);
            }
            else if (property.type === BindingPropertyType.Object) {
                this.extendObjectProperty(object, property);
            }
            else if (property.type === BindingPropertyType.Dynamic) {
                this.extendDynamicObjectProperty(object, property);
            }
            else {
                this.extendPlainProperty(object, property);
            }
        });
    }
    /**
     * 扩展列表类型的绑定属性
     * @param object     要扩展的绑定对象
     * @param properties 列表类型的绑定属性集合
     */
    static extendListProperty(object, property) {
        const propertyName = property.name;
        const childListProperties = PropertyUtil.getProperties(property.entityType);
        const childList = BindingListFactory.create(childListProperties);
        // 指定子List的parent、监听子List的changes事件
        childList.parent = object;
        childList.changes.subscribe((change) => {
            change.path.unshift(propertyName);
            object.changes.next(change);
        });
        // 将子的BindingList实例赋值给当前属性
        Object.defineProperty(object, propertyName, {
            value: childList
        });
    }
    /**
     * 扩展对象类型的绑定属性
     * @param object     要扩展的绑定对象
     * @param properties 对象类型的绑定属性集合
     */
    static extendObjectProperty(object, property) {
        const propertyName = property.name;
        const childObjectProperties = PropertyUtil.getProperties(property.entityType);
        const childObject = this.create(childObjectProperties);
        // 指定子Object的parent、监听子Object的changes事件
        childObject.parent = object;
        childObject.changes.subscribe((change) => {
            change.path.unshift(propertyName);
            object.changes.next(change);
        });
        Object.defineProperty(object, propertyName, {
            value: childObject
        });
    }
    static extendDynamicObjectProperty(object, property) {
        const propertyName = property.name;
        object[propertyName] = null;
    }
    static attachDynamicObjectProperty(object, propertyName, dynamicObject) {
        dynamicObject.parent = object;
        dynamicObject.changes.subscribe((change) => {
            change.path.unshift(propertyName);
            object.changes.next(change);
        });
        Object.defineProperty(object, propertyName, {
            value: dynamicObject
        });
    }
    /**
     * 扩展简单类型的绑定属性
     * @param object     要扩展的绑定对象
     * @param properties 简单类型的绑定属性集合
     */
    static extendPlainProperty(object, property) {
        const propertyName = property.name;
        Object.defineProperty(object, propertyName, {
            get: () => {
                return object.getValue(propertyName);
            },
            set: (value) => {
                const oldValue = object.getValue(propertyName);
                if (value === oldValue) {
                    return;
                }
                object.setValue(propertyName, value, true, true);
            }
        });
    }
}

/**
 * BindingList是一个BindingObject集合
 */
class BindingList {
    /**
     * 构造函数
     */
    constructor(properties) {
        //#region 分页相关
        /**
         * 分页信息
         */
        this._paginationInfo = null;
        this.properties = properties;
        this.primaryKey = PropertyUtil.getPrimaryKey(properties);
        this.changes = new Subject();
        this.innerList = [];
        this.currentId = null;
    }
    set paginationInfo(sPaginationInfo) {
        this._paginationInfo = sPaginationInfo;
        if (this._paginationInfo === sPaginationInfo) {
            return;
        }
        this.changes.next({
            type: ChangeType.PaginationInfoChange,
            path: [],
            value: this._paginationInfo
        });
    }
    get paginationInfo() {
        return this._paginationInfo;
    }
    /**
     * 获取页码
     */
    get pageIndex() {
        if (!!this.paginationInfo && this.paginationInfo.hasOwnProperty("pageIndex")) {
            return this.paginationInfo.pageIndex;
        }
        return 1;
    }
    /**
     * 获取分页大小
     */
    get pageSize() {
        if (!!this.paginationInfo && this.paginationInfo.hasOwnProperty("pageSize")) {
            return this.paginationInfo.pageSize;
        }
        return 0;
    }
    /**
     * 获取数据总项数
     */
    get total() {
        if (!!this.paginationInfo) {
            return this.paginationInfo.total || this.paginationInfo.totalCount;
        }
        return 0;
    }
    /**
     * 获取跳过的数据条数
     */
    get skip() {
        const pageIndex = this.pageIndex;
        const pageSize = this.pageSize;
        return (pageIndex - 1) * pageSize;
    }
    /**
     * 前台设置分页信息
     * @param skip skip
     * @param take take
     */
    setPaginationInfo(skip, take) {
        this.paginationInfo = Object.assign({}, this.paginationInfo, {
            pageSize: take,
            pageIndex: skip / take + 1
        });
        /*this.changes.next({
          type: ChangeType.PaginationInfoChange,
          path: [],
          value: this.paginationInfo
        });*/
    }
    //#endregion
    /**
     * 当前行对应的绑定对象
     * 如果currentId为null，则创建一个空结构，防止绑定报错；
     */
    get currentItem() {
        const currentItem = this.findById(this.currentId);
        if (!currentItem) {
            if (!this.emptyCurrentItem) {
                this.emptyCurrentItem = BindingObjectFactory.create(this.properties);
            }
            return this.emptyCurrentItem;
        }
        return currentItem;
    }
    /**
     * 绑定对象的数量
     */
    get length() {
        return this.innerList.length;
    }
    /**
     * 添加[Symbol.iterator]，使之能通过for of遍历
     */
    [Symbol.iterator]() {
        const self = this;
        let index = -1;
        const size = this.innerList.length;
        return {
            next: function () {
                index++;
                if (index < size) {
                    return {
                        done: false,
                        value: self.innerList[index]
                    };
                }
                return { done: true, value: undefined };
            }
        };
    }
    /**
     * 批量加载绑定对象，加载之前先清空绑定列表，并重置当前行，加载之后将第一行设置为默认当前行。
     * @param objects 要加载绑定对象数组
     */
    load(objects) {
        // 重置列表
        this.innerList = [];
        if (objects.length !== 0) {
            // 加载数据
            objects.forEach((object) => {
                this.add(object);
            });
            // 设置默认当前行
            const currentItem = this.findById(this.currentId);
            if (!currentItem) {
                const firstId = objects[0][this.primaryKey];
                this.setCurrentId(firstId, false, false);
            }
        }
        else {
            this.currentId = null;
        }
        // 触发事件
        this.changes.next({
            type: ChangeType.Load,
            path: [],
            value: objects
        });
    }
    /**
     * 批量追加绑定对象，追加之后将最后一个追加的绑定对象设置为当前行。
     * @param objects 要加载绑定对象数组
     */
    append(objects) {
        if (objects.length === 0) {
            return;
        }
        // 加载BindingObject
        objects.forEach((object) => {
            this.add(object);
        });
        // 当前行为新追加的最后1行
        const lastId = objects[objects.length - 1][this.primaryKey];
        this.setCurrentId(lastId, true, true);
        // 触发事件
        this.changes.next({
            type: ChangeType.Append,
            path: [],
            value: objects
        });
    }
    /**
     * 添加绑定对象，并建立绑定对象和绑定列表之间的关联。
     * @param object 绑定对象
     */
    add(object) {
        this.innerList.push(object);
        object.parent = this;
        // 监听object变更，并继续向上抛，由于list有当前行的概念，不需要在path中追加路径
        object.changes.subscribe((change) => {
            this.changes.next(change);
        });
    }
    /**
     * 删除主键值数组对应的绑定对象。
     * @param ids 主键值数组
     */
    removeByIds(ids) {
        if (!ids || ids.length === 0) {
            return;
        }
        let nextCurrentId = this.currentId;
        ids.forEach((id) => {
            // 如果当前行被删除，计算下一当前行
            if (id === nextCurrentId) {
                nextCurrentId = this.getCurrentIdBeforeDeleting();
            }
            // 删除对象，找不到时跳过
            const index = this.getIndexById(id);
            if (index === -1) {
                return;
            }
            ArrayUtil.removeByIndex(this.innerList, index);
        });
        // 重新设置当前行
        if (this.innerList.length === 0) {
            this.currentId = null;
        }
        else {
            this.setCurrentId(nextCurrentId, false, false);
        }
        // 出发行删除事件
        this.changes.next({
            type: ChangeType.Remove,
            path: [],
            value: ids
        });
    }
    /**
     * 清空
     */
    clear() {
        this.innerList = [];
        this.currentId = null;
        this.changes.next({
            type: ChangeType.Remove,
            path: [],
            value: []
        });
    }
    /**
     * 如果当前行被删除，删除之前重新计算当前行的位置，并返回下一当前行的主键值。
     * - 如果被删除的行是最后1行，则上移1行；
     * - 其他情况，下移1行。
     */
    getCurrentIdBeforeDeleting() {
        let nextIndex = -1;
        const currentIndex = this.getIndexById(this.currentId);
        if (currentIndex === this.length - 1) {
            nextIndex = currentIndex - 1;
        }
        else {
            nextIndex = currentIndex + 1;
        }
        return this.getIdByIndex(nextIndex);
    }
    /**
     * 根据主键值获取对应绑定对象
     * @param   id 要查找的主键值
     * @returns 找到时返回对应BindingObject， 找不到时返回null
     */
    findById(id) {
        let target;
        target = this.innerList.find((item) => {
            return item.getValue(this.primaryKey) === id;
        });
        return target === undefined ? null : target;
    }
    /**
     * 将主键值为id的绑定对象设置为当前行
     * @param  id        要设置的主键值
     * @param  emitEvent 是否发送当前行变更事件
     */
    setCurrentId(id, emitEvent = true, emitGlobalEvent = true) {
        if (this.currentId === id) {
            return;
        }
        // 不存在时设置为null
        // const currentObj = this.findById(id);
        // if (!currentObj) {
        //   this.currentId = null;
        // } else {
        //   this.currentId = id;
        // }
        // @todo：找不到时按理应该设置为null，目前是直接返回，框架部分功能依赖该特性。
        const currentObj = this.findById(id);
        if (!currentObj) {
            return;
        }
        this.currentId = id;
        // 发出行切换事件
        if (emitEvent === true) {
            this.changes.next({
                type: ChangeType.SelectionChanged,
                path: [],
                value: this.currentItem
            });
        }
        // 是否发送全局的行切换事件
        if (emitGlobalEvent === true) {
            this.changes.next({
                type: ChangeType.GlobalSelectionChanged,
                path: [],
                value: this.currentItem
            });
        }
    }
    /**
     * 根据主键值为id的绑定对象的索引
     * @param id 主键值
     * @returns 找到时返回对应的index，找不到时返回-1
     */
    getIndexById(id) {
        return this.innerList.findIndex((obj) => {
            return obj[this.primaryKey] === id;
        });
    }
    /**
     * 根据索引位置获取对应绑定对象的主键值
     * @reutrn 找到时返回对应主键值，找不到返回null
     */
    getIdByIndex(index) {
        if (index < 0 || index > this.length) {
            return null;
        }
        const obj = this.innerList[index];
        if (!obj) {
            return null;
        }
        return obj[this.primaryKey];
    }
    /**
     * 转换为BindingObject数组
     */
    toArray() {
        return this.innerList.concat([]);
    }
    /**
     * 转换为JSON对象
     * @returns 普通对象数组
     */
    toJSON(options) {
        const result = [];
        this.innerList.forEach((obj) => {
            result.push(obj.toJSON(options));
        });
        return result;
    }
    /**
     * 获取分页信息
     * @param path 路径
     * @param defaultValue 默认值
     */
    getPaginationConfigByPath(path, defaultValue) {
        if (!path || path === '/') {
            return this.paginationInfo;
        }
        if (typeof path !== 'string') {
            throw new Error('路径必须为字符串！');
        }
        path = path.substring(1);
        const paths = path.split('/').filter(item => !!item && item.trim().length > 0).map(item => item.trim());
        let config = this.paginationInfo;
        paths.forEach(item => {
            if (config && config.hasOwnProperty(item)) {
                config = config[item];
            }
            else {
                config = null;
            }
        });
        return !!config ? config : typeof defaultValue !== 'undefined' ? defaultValue : undefined;
    }
    /**
     * 对bindingList就行排序
     * @param string 排序字段
     * @param directions 排序规则字段
     * @param options 参数
     */
    sortBy(fields, directions, options) {
        if (!fields || fields.length < 1 || !directions || directions.length < 1) {
            throw new Error('sortBy:argument error');
        }
        // 默认升序
        const arrFields = typeof fields === 'string' ? fields.split(',') : fields || [];
        const arrDirections = typeof directions === 'string' ? directions.split(',') : directions || [];
        // 排序字段和排序方式应一致
        if (arrFields.length !== arrDirections.length || arrFields.length < 1) {
            throw new Error('sortBy:fields and directions not match');
        }
        // nage,age,total
        const comparator = (props, orders) => (item1, item2) => {
            for (const prop of props) {
                const order = ['asc'].includes(orders[props.indexOf(prop)]) ? 1 : -1;
                if (item1.getValue(prop) > item2.getValue(prop)) {
                    return order * 1;
                }
                if (item1.getValue(prop) < item2.getValue(prop)) {
                    return order * -1;
                }
            }
            return 0;
        };
        this.innerList = this.innerList.sort(comparator(arrFields, arrDirections));
    }
}

/**
 * 实体操作工具类
 */
class EntityUtil {
    /**
     * 将entity的数据加载到bindingObject中，并保持两者同步。
     * @param entity        实体对象
     * @param bindingObject 绑定对象
     */
    static loadEntity(entity, bindingObject) {
        // 遍历bindingObject的properties进行赋值
        bindingObject.properties.forEach((property) => {
            const propertyName = property.name;
            if (property.type === BindingPropertyType.List) {
                this.loadEntityList(entity[propertyName] || entity[PARENT_CLASS], bindingObject[propertyName]);
            }
            else if (property.type === BindingPropertyType.Object) {
                if (entity && entity[propertyName]) {
                    this.loadEntity(entity[propertyName], bindingObject[propertyName]);
                }
            }
            else if (property.type === BindingPropertyType.Dynamic) {
                if (entity && entity[propertyName]) {
                    const dynamicObject = BindingObjectFactory.createDynamicBindingObject(entity[propertyName].data);
                    BindingObjectFactory.attachDynamicObjectProperty(bindingObject, propertyName, dynamicObject);
                    this.loadEntity(entity[propertyName], bindingObject[propertyName]);
                }
            }
            else {
                bindingObject.setValue(propertyName, entity[propertyName], false, false);
            }
        });
        this.setUpEntityPipeline(entity, bindingObject);
    }
    /**
     * 建立entity和bindingObject之间的关联
     * @param entity        实体对象
     * @param bindingObject 绑定对象
     */
    static setUpEntityPipeline(entity, bindingObject) {
        // 监听entity变更
        entity.onValueChanged.subscribe((modification) => {
            if (modification.type !== ModifyType.ValueChange || modification.path.length === 0) {
                return;
            }
            const propertyName = modification.path[modification.path.length - 1];
            const primaryKeyPath = modification.path[modification.path.length - 2];
            // 验证主键是否匹配
            // 存在主键并且主键不是id时才检查（值对象、关联对象不检查）
            if (bindingObject.primaryKey && bindingObject.primaryKey === 'id') {
                const primaryKey = bindingObject.primaryKey;
                const primaryKeyValue = bindingObject.getValue(primaryKey);
                if (primaryKeyPath !== `${primaryKey}:${primaryKeyValue}`) {
                    return;
                }
            }
            // 值没有发生变化，不再设置
            // TODO: 通过bindingObject修改entity属性值时，entity总会触发一个变更回来，如果不截获这个重复的变更，会导致重复或死循环
            if (bindingObject.getValue(propertyName) === modification.value) {
                return;
            }
            bindingObject.setValue(propertyName, modification.value, true, false, modification.errors);
        });
        // 监听bindingObject变更
        bindingObject.viewChanges.subscribe((viewChange) => {
            const value = viewChange.value;
            const propertyName = viewChange.path[0];
            let pathPrefix = '';
            const pathData = entity.getPaths();
            const paths = pathData.path;
            let id = bindingObject['id'];
            if (pathData.isUdt) {
                // grid中udt没有id，从父级中取出id，以便存放验证信息
                const getParentId = (target) => {
                    let parentId = '';
                    const findId = (item) => {
                        if (item && item && item['id']) {
                            parentId = item['id'];
                            return;
                        }
                        else if (item['parent']) {
                            findId(item['parent']);
                        }
                    };
                    findId(target);
                    return parentId;
                };
                id = getParentId(bindingObject);
                if (pathData.isGrid) {
                    // grid 将从表主字段去除
                    paths.shift();
                }
                if (paths.length) {
                    pathPrefix = paths.join('.') + '.';
                }
            }
            // 不是主键值字段时，要先检查主键是否存在，并且主键是否相等（防止后代变更冒泡上来）
            // 非主键属性变更时，要先检查主键是否匹配（如果主键也修改了，要求先修改主键再修改其他值）
            if (bindingObject.primaryKey) {
                const primaryKey = bindingObject.primaryKey;
                if (propertyName !== primaryKey) {
                    if (!entity[primaryKey] || entity[primaryKey] !== bindingObject[primaryKey]) {
                        return;
                    }
                }
            }
            // 如果BindingObject上的属性值和Entity上对应属性值一样，则不再设置
            if (entity[propertyName] === value) {
                return;
            }
            // 调用表单验证,通过后调用实体验证
            // bingdingObject变化后，先调用实体上的验证，通过后再设置实体的变动
            entity[propertyName] = value;
        });
    }
    /**
     * 将entityList中的Entity对象转换为BindingObject对象，加载到bindingList中，并保持entityList和bindingList同步。
     * @param entityList  实体列表
     * @param bindingList 绑定列表
     */
    static loadEntityList(entityList, bindingList) {
        this.loadEntities(entityList.items, bindingList);
        this.setUpEntityListPipeline(entityList, bindingList);
    }
    /**
     * 建立entityList和bindingList之间的关联
     * @param entityList  实体列表
     * @param bindingList 绑定列表
     */
    static setUpEntityListPipeline(entityList, bindingList) {
        entityList.onListChanged.subscribe((modification) => {
            switch (modification.type) {
                // 添加实体
                case ModifyType.Add:
                    const entitiesToAdd = modification.value;
                    if (entitiesToAdd.length === 0) {
                        return;
                    }
                    // 检查父id是否一致，冒泡导致的变更不处理
                    const paths = modification.path;
                    const parentPath = paths[paths.length - 2];
                    const parentId = bindingList.parent.primaryKeyValue;
                    if (parentPath.indexOf(parentId) === -1) {
                        return;
                    }
                    this.appendEntities(modification.value, bindingList);
                    break;
                // 删除实体
                case ModifyType.Remove:
                    // 删除实体（value格式待商榷，目前value的格式为 { primaryKey: primaryValue}）
                    const id = modification.value[bindingList.primaryKey];
                    bindingList.removeByIds([id]);
                    // this.removeEntities(<Entity[]>modification.value, bindingList);
                    break;
                // 加载实体
                case ModifyType.Load:
                    const entities = modification.value;
                    this.loadEntities(entities, bindingList);
                    break;
                default:
                    break;
            }
        });
    }
    /**
     * 监听repository变化，保持repository和bindingList同步。
     * @param repository  实体仓库
     * @param bindingList 绑定列表
     */
    static loadRepository(repository, bindingList) {
        // 初次加载
        const entities = Array.from(repository.entityCollection.toArray());
        this.loadEntities(entities, bindingList);
        // 监听变化
        repository.entityCollectionChange.subscribe((modification) => {
            switch (modification.type) {
                case ModifyType.Load:
                    this.loadEntities(modification.value, bindingList);
                    break;
                case ModifyType.Add:
                    this.appendEntities(modification.value, bindingList);
                    break;
                case ModifyType.Remove:
                    this.removeEntities(modification.value, bindingList);
                    break;
                case ModifyType.PaginationInfoChange:
                    bindingList.paginationInfo = modification.value;
                    break;
                default:
                    break;
            }
        });
        // 监听BindingList数据变化
        bindingList.changes.subscribe((change) => {
            if (change.type === ChangeType.PaginationInfoChange) {
                const entityCollection = repository.entityCollection;
                // const entityTypeName = entityCollection.entityTypeName;
                // const original = entityCollection.paginationInfo[entityTypeName];
                // const entityPaginationInfo = Object.assign({}, original, change.value);
                entityCollection.paginationInfo = Object.assign({}, entityCollection.paginationInfo, change.value);
            }
        });
    }
    /**
     * 将entities中的Entity对象转换为BindingObject对象，并加载到bindingList中
     * @param entities    实体数组
     * @param bindingList 绑定列表
     */
    static loadEntities(entities, bindingList) {
        const bindingObjects = this.createBindingObjects(entities, bindingList);
        bindingList.load(bindingObjects);
    }
    /**
     * 将entities中的Entity对象转换为BIndingObject对象，并追加到bindingList中
     * @param entities    实体数组
     * @param bindingList 绑定列表
     */
    static appendEntities(entities, bindingList) {
        const bindingObjects = this.createBindingObjects(entities, bindingList);
        bindingList.append(bindingObjects);
    }
    /**
     * 从bindingList移除entities对应的BindingObject对象
     * @param entities    实体数组
     * @param bindingList 绑定列表
     */
    static removeEntities(entities, bindingList) {
        if (entities === null || entities.length === 0) {
            return;
        }
        // 归集要删除的id数组
        const primaryKey = bindingList.primaryKey;
        const ids = [];
        entities.forEach((entity) => {
            ids.push(entity[primaryKey]);
        });
        bindingList.removeByIds(ids);
    }
    /**
     * 将entities中的Entity对象转换为BindingObject对象
     * @param entities    实体数组
     * @param bindingList 绑定列表
     */
    static createBindingObjects(entities, bindingList) {
        if (entities === null || entities.length === 0) {
            return [];
        }
        const bindingObjects = [];
        entities.forEach((entity) => {
            const bindingObject = BindingObjectFactory.create(bindingList.properties);
            this.loadEntity(entity, bindingObject);
            // // 为bindingObject设置默认值initialData属性
            // if (entity['initialData']) {
            //   bindingObject['initialData'] = entity['initialData'];
            // }
            bindingObjects.push(bindingObject);
        });
        return bindingObjects;
    }
    static watchReposiroty(repository, bindingData) {
        // reposiroty => bindingData
        repository.entityCollectionChange.subscribe((modification) => {
            switch (modification.type) {
                case ModifyType.PaginationInfoChange:
                    bindingData.pagingInfo = modification.value;
                    break;
                default:
                    break;
            }
        });
    }
    /**
     * 查找属性的类型
     * @param entityType 实体类型
     * @param targetPropName 属性名称
     * @return 属性信息，包含属性类型（NgField、NgObject、NgList）和属性对应的实体类型（当NgField类型时为null）
     */
    static getPropInfo(entityType, targetPropName) {
        let propType;
        let propEntityType;
        // NgField
        const ngFieldProperties = FieldMetadataUtil.getNgFields(entityType);
        Object.keys(ngFieldProperties).forEach((propName) => {
            if (propName === targetPropName) {
                propType = 'NgField';
                propEntityType = null;
            }
        });
        // NgObject
        const ngObjectProperties = FieldMetadataUtil.getNgObjects(entityType);
        Object.keys(ngObjectProperties).forEach((propName) => {
            if (propName === targetPropName) {
                propType = 'NgObject';
                propEntityType = ngObjectProperties[propName].type;
            }
        });
        // NgList
        const ngListProperties = FieldMetadataUtil.getNgList(entityType);
        Object.keys(ngListProperties).forEach((propName) => {
            if (propName === targetPropName) {
                propType = 'NgList';
                propEntityType = ngListProperties[propName].type;
            }
        });
        const ngDynamicProperties = FieldMetadataUtil.getNgDynamic(entityType);
        Object.keys(ngDynamicProperties).forEach((propName) => {
            if (propName === targetPropName) {
                propType = 'NgDynamic';
                propEntityType = ngDynamicProperties[propName].type;
            }
        });
        return { propType, propEntityType };
    }
    /**
     * 获取实体的主键名
     * @param entityType 实体类型
     */
    static getPrimaryKey(entityType) {
        const primaryNgFiledProp = FieldMetadataUtil.getPrimaryFieldMetadata(entityType);
        if (primaryNgFiledProp) {
            return primaryNgFiledProp.dataField;
        }
        else {
            return '';
        }
    }
    /**
     * 是否为对象属性
     */
    static isObjectProp(entityType, targetPropName) {
        let isObjectProp = false;
        const ngObjectProperties = FieldMetadataUtil.getNgObjects(entityType);
        Object.keys(ngObjectProperties).forEach((propName) => {
            if (propName === targetPropName) {
                isObjectProp = true;
            }
        });
        return isObjectProp;
    }
    /**
     * 检查是否是动态列属性
     */
    static isDynamicProp(entityType, targetPropName) {
        let isDynamicProp = false;
        const ngDynamicProperties = FieldMetadataUtil.getNgDynamic(entityType);
        Object.keys(ngDynamicProperties).forEach((propName) => {
            if (propName === targetPropName) {
                isDynamicProp = true;
            }
        });
        return isDynamicProp;
    }
    /**
     * 为实体增加initialData属性
     * @param entity 实体实例
     * @param initialData 默认值对象
     */
    static appendInitialData(entity, initialData) {
        const data = Object.assign({}, initialData);
        delete data.id;
        delete data.parentID;
        entity['initialData'] = data;
    }
}

// tslint:disable: max-line-length member-ordering
/**
 * BindingData
 */
class BindingData {
    constructor() {
        this.paginationInfo = null;
    }
    /**
     * 绑定该路径
     */
    get bindingPath() {
        if (this.viewModelContext && this.viewModelContext.viewModel.bindingPath) {
            return this.viewModelContext.viewModel.bindingPath;
        }
        return '/';
    }
    set pagingInfo(pagingInfo) {
        this.paginationInfo = pagingInfo;
        this.firePagingChangeEvent();
    }
    get pagingInfo() {
        return this.paginationInfo;
    }
    /**
     * 设置分页信息
     * @param skip 跳过
     * @param take 获取
     * @param bindingPath 路径
     */
    setPagingInfo(skip, take, bindingPath) {
        if (bindingPath.length < 1 || bindingPath === '/') {
            this.paginationInfo = Object.assign(this.paginationInfo, { pageSize: take, pageIndex: skip / take + 1 });
        }
        else {
            let pagingInfo = this.paginationInfo || {};
            const bindingPaths = bindingPath.substr(1).split('/').filter(item => !!item && item.length > 0).map(item => item.substring(0, item.length - 1));
            bindingPaths.forEach(path => {
                if (!pagingInfo.hasOwnProperty(path)) {
                    pagingInfo[path] = {};
                }
                pagingInfo = pagingInfo[path];
            });
            pagingInfo.pageIndex = ((skip / take) || 0) + 1;
            pagingInfo.pageSize = take || 0;
        }
        this.firePagingChangeEvent();
    }
    firePagingChangeEvent() {
        this.list.changes.next({
            type: ChangeType.PaginationInfoChange,
            path: [],
            value: this.paginationInfo
        });
    }
    /**
     * 变更集
     */
    get changes() {
        return this.list.changes;
    }
    /**
     * 设置值变化执行器工厂
     * @param value 值变化执行器工厂
     */
    setValueChangeInvokerFactory(value) {
        this.valueChangeInvokerFactory = value;
    }
    /**
     * 初始化（已废弃）
     */
    init(repository, bindingPath) {
        this.initByRepository(repository, null);
    }
    /**
     * 根据Repository对BindingData进行初始化
     */
    initByRepository(repository, viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.properties = PropertyUtil.getProperties(repository.entityType);
        this.list = BindingListFactory.create(this.properties);
        // 从repository初始化bindingData
        this.pagingInfo = repository.entityCollection.paginationInfo;
        // @todo
        // BindingData不应该知道Repository，加载数据、建立关联关系的过程应该转移到外边
        EntityUtil.loadRepository(repository, this.list);
        this.dataTypeInfo = repository.entityTypeInfo;
        this.extendProperties(this.properties);
    }
    /**
     * 初始化
     */
    initByBindingList(bindingList, viewModelContext) {
        this.list = bindingList;
        this.viewModelContext = viewModelContext;
        this.extendProperties(this.list.properties);
    }
    /**
     * 获取paths对应的属性值
     * @param  paths 属性路径数组
     * @returns 属性值
     */
    getValue(paths) {
        let target = this.list;
        paths.forEach((path) => {
            if (target) {
                target = target[path];
            }
        });
        return target;
    }
    /**
     * 根据paths设置属性值
     * @param paths 属性路径数组
     * @param value 属性值
     * @param emitEventToView 如果设置为true，则发送事件通知订阅它的组件、指令去更新界面，默认为false。
     * @param emitEventToEntity 如果设置为true，则同步去更新Entity上对应的字段，默认为true。
     */
    setValue(paths, value, emitEventToView = false, emitEventToEntity = true) {
        if (!paths || paths.length === 0) {
            throw Error('路径不能为空');
        }
        const parentPaths = paths.slice(0, paths.length - 1);
        const propName = paths[paths.length - 1];
        let parent = this.getValue(parentPaths);
        if (!parent) {
            throw Error('找不到要设置的对象');
        }
        if (parent instanceof BindingData) {
            parent = parent.list.currentItem;
        }
        else if (parent instanceof BindingList) {
            parent = parent.currentItem;
        }
        if (!!this.valueChangeInvokerFactory) {
            parent.setValue(propName, value, emitEventToView, emitEventToEntity, null, this.valueChangeInvokerFactory(paths));
        }
        else {
            parent.setValue(propName, value, emitEventToView, emitEventToEntity);
        }
    }
    /**
     * 根据paths清空属性值
     */
    clearValue(paths, emitEventToView = false, emitEventToEntity = true) {
        let initValue;
        const propInfo = this.dataTypeInfo.getPropInfoByPath(paths);
        if (propInfo && propInfo.metadataInfo && propInfo.metadataInfo.initValue !== undefined) {
            initValue = propInfo.metadataInfo.initValue;
        }
        else {
            // 原来的帮助映射中，强行纠正了数值的情况，保持一致
            const oldValue = this.getValue(paths);
            if (typeof oldValue === 'number') {
                initValue = 0;
            }
            else {
                initValue = '';
            }
        }
        this.setValue(paths, initValue, emitEventToView, emitEventToEntity);
    }
    /**
     * 获取当前列表
     */
    getList() {
        if (!this.bindingPath || this.bindingPath === '/') {
            return this.list;
        }
        const bindingPath = this.bindingPath.substr(1);
        const bindingPathArray = bindingPath.split('/').filter((part) => {
            return part !== '';
        });
        return this.getValue(bindingPathArray);
    }
    /**
     * 获取当前对象
     */
    getObject() {
        const bindingList = this.getList();
        return bindingList.currentItem;
    }
    /**
     * 扩展BindingData属性，映射BindingData所持有的绑定列表当前行的属性，减少绑定层级。
     * @param properties 关联实体的属性集合
     */
    extendProperties(properties) {
        properties.forEach((property) => {
            const propName = property.name;
            Object.defineProperty(this, propName, {
                get: () => {
                    return this.list.currentItem[propName];
                },
                set: (value) => {
                    this.list.currentItem[propName] = value;
                }
            });
        });
    }
}

class BindingDataFactory {
    /**
     * 根据Repository创建一个BindingData
     */
    static createFromRepository(repository, bindingPath) {
        const bindingData = new BindingData();
        const bindingProperties = PropertyUtil.getProperties(repository.entityType);
        const bindingList = BindingListFactory.create(bindingProperties);
        bindingData.initByBindingList(bindingList, null);
        EntityUtil.loadRepository(repository, bindingList);
        // 从repository初始化bindingData
        bindingData.pagingInfo = repository.entityCollection.paginationInfo;
        return bindingData;
    }
    /**
     * 根据EntityManager创建BindingData，并建立双向关联（请勿使用）
     * @internal
     * @summary
     * 1、该方法暂时仅供内部单元测试使用；
     * 2、该方法暂时只创建BindingData，不建立双向关联
     */
    static createFromEntityManager(entityManager, bindingPath) {
        const bindingData = new BindingData();
        const bindingProperties = PropertyUtil.getProperties(entityManager.entityType);
        const bindingList = BindingListFactory.create(bindingProperties);
        bindingData.initByBindingList(bindingList, null);
        // 初始化数据
        const entities = entityManager.getEntitiesByPath([]);
        EntityUtil.loadEntities(entities, bindingList);
        return bindingData;
    }
    /**
     * 根据已经存在的BindingData创建一个新的BindingData
     */
    static createFromExistingBindingData(existingBindingData, bindingPath) {
        const bindingData = new BindingData();
        bindingData.initByBindingList(existingBindingData.list, null);
        return bindingData;
    }
}

/**
 * EntityPath转换器
 */
class EntityPathConverter {
    /**
     * 转换为Entity可识别的路径
     * 根：[]
     * 主表：['id:xxx', 'name'],
     * 关联：['id:xxx', 'deptInfo', 'id:xxx', 'name']
     * UDT: ['id:xxx', 'updateInfo', ':', 'createdOn']
     * 从表：['id:xxx', 'edus', 'id:xxx', 'name'],
     * 从从表：['id:xxx', 'edus', 'id:xxx', 'grades', 'id:xxx', 'name']
     */
    static toEntityPathArray(bindingPathString, bindingData) {
        const bindingPathArray = BindingPathConverter.toBindingPathArray(bindingPathString);
        const entityPathArray = [];
        if (bindingPathArray.length === 0) {
            return entityPathArray;
        }
        // 根节点
        let currentBindingObject = bindingData.list.currentItem;
        entityPathArray.push(this.createPrimaryKeyPath(currentBindingObject.primaryKey, currentBindingObject.primaryKeyValue));
        bindingPathArray.forEach((propName) => {
            const propInfo = PropertyUtil.getPropertyByName(currentBindingObject.properties, propName);
            switch (propInfo.type) {
                case BindingPropertyType.Plain:
                    entityPathArray.push(propName);
                    break;
                case BindingPropertyType.Object:
                    currentBindingObject = currentBindingObject[propName];
                    entityPathArray.push(propName);
                    entityPathArray.push(this.createPrimaryKeyPath(currentBindingObject.primaryKey, currentBindingObject.primaryKeyValue));
                    break;
                case BindingPropertyType.List:
                    const currentBindingList = currentBindingObject[propName];
                    currentBindingObject = currentBindingList.currentItem;
                    entityPathArray.push(propName);
                    entityPathArray.push(this.createPrimaryKeyPath(currentBindingObject.primaryKey, currentBindingObject.primaryKeyValue));
                    break;
                default:
                    break;
            }
        });
        return entityPathArray;
    }
    /**
     * 创建路径中的主键部分
     */
    static createPrimaryKeyPath(primaryKey, primaryKeyValue) {
        return `${primaryKey}:${primaryKeyValue}`;
    }
}

/**
 * 实体路径比较器
 */
class EntityPathComparer {
}

/**
 * 表单路径转换类
 */
class FormPathConverter {
    /**
     * ControlPathString => BingingPathArray
     * @params controlPath FormControl对应的数据绑定路径（BindingData的bindingPaht + FormControl的binding）
     * @return BindingPath数组
     */
    static toBindingPathArray(formPahtString) {
        const bindingPathArray = formPahtString.split('.').filter((part) => {
            return part !== '';
        });
        return bindingPathArray;
    }
}

/**
 * 数据路径转换、比较等工具类
 * @summary
 * ----------------------------------------
 * 术语：
 * BindingPath：数组形式；
 * BindingPathString：BindingPath的字符串形式，用/分隔；
 * ControlPathString：BindingPath的字符串形式，用.分隔；
 *
 * EntityPath：数组形式；
 * EntityPathString：EntityPath的字符串形式，使用/分隔；
 * ----------------------------------------
 */

/**
 * 路径处理工具类（处理/PathNode1/PathNode2/...格式的路径）
 */
class DataPathUtil {
    /**
     * 转换成BindingData可识别的路径
     */
    static convertToBindingPathArray(path) {
        const bindingPathArray = path.split('/').filter((part) => {
            return part !== '';
        });
        return bindingPathArray;
    }
    /**
     * 转换为Entity可识别的路径
     * 根：[]
     * 主表：['id:xxx', 'name'],
     * 关联：['id:xxx', 'deptInfo', 'id:xxx', 'name']
     * UDT: ['id:xxx', 'updateInfo', ':', 'createdOn']
     * 从表：['id:xxx', 'edus', 'id:xxx', 'name'],
     * 从从表：['id:xxx', 'edus', 'id:xxx', 'grades', 'id:xxx', 'name']
     */
    static convertToEntityPathArray(path, bindingData) {
        const bindingPathArray = this.convertToBindingPathArray(path);
        const entityPathArray = [];
        if (bindingPathArray.length === 0) {
            return entityPathArray;
        }
        // 根节点
        let currentBindingObject = bindingData.list.currentItem;
        entityPathArray.push(this.createPrimaryKeyPath(currentBindingObject.primaryKey, currentBindingObject.primaryKeyValue));
        bindingPathArray.forEach((propName) => {
            const propInfo = PropertyUtil.getPropertyByName(currentBindingObject.properties, propName);
            switch (propInfo.type) {
                case BindingPropertyType.Plain:
                    entityPathArray.push(propName);
                    break;
                case BindingPropertyType.Object:
                    currentBindingObject = currentBindingObject[propName];
                    entityPathArray.push(propName);
                    entityPathArray.push(this.createPrimaryKeyPath(currentBindingObject.primaryKey, currentBindingObject.primaryKeyValue));
                    break;
                case BindingPropertyType.List:
                    const currentBindingList = currentBindingObject[propName];
                    currentBindingObject = currentBindingList.currentItem;
                    entityPathArray.push(propName);
                    entityPathArray.push(this.createPrimaryKeyPath(currentBindingObject.primaryKey, currentBindingObject.primaryKeyValue));
                    break;
                default:
                    break;
            }
        });
        return entityPathArray;
    }
    /**
     * 转换为RestUrl里的路径
     *
     * 返回结果：
     * 主表（/）：/
     * 从表（/jiwtEdus）：/xxx/jiwtEdus
     * 从从表（/jiwtEdus/jiwtGrades）： /xxx/jiwtEdus/xxx/jiwtGrades
     */
    static convertToRestUrl(path, bindingData) {
        const bindingPathArray = this.convertToBindingPathArray(path);
        const restPathArray = [];
        let currentBindingObject = bindingData.list.currentItem;
        restPathArray.push(currentBindingObject.primaryKeyValue);
        bindingPathArray.forEach((propName) => {
            const propInfo = PropertyUtil.getPropertyByName(currentBindingObject.properties, propName);
            if (propInfo.type !== BindingPropertyType.List) {
                throw new Error(`${propInfo.name}不是子表对应的属性`);
            }
            const currentBindingList = currentBindingObject[propName];
            currentBindingObject = currentBindingList.currentItem;
            restPathArray.push(propName);
            restPathArray.push(currentBindingObject.primaryKeyValue);
        });
        // 移除最后一个主键
        restPathArray.pop();
        return '/' + restPathArray.join('/');
    }
    /**
     * 获取叶子节点的Path
     */
    static getLeafPath(path) {
        const pathArray = DataPathUtil.convertToBindingPathArray(path);
        return pathArray.pop();
    }
    /**
     * 获取父路径
     */
    static getParentPath(path) {
        const pathArray = DataPathUtil.convertToBindingPathArray(path);
        pathArray.pop();
        return '/' + pathArray.join('/');
    }
    /**
     * 创建路径中的主键部分
     */
    static createPrimaryKeyPath(primaryKey, primaryKeyValue) {
        return `${primaryKey}:${primaryKeyValue}`;
    }
}

// tslint:disable: max-line-length
/**
 * GUID创建服务
 * @scope 静态类没有提供Provider
 */
class Guid {
    constructor(guid) {
        if (!guid) {
            throw new TypeError('Invalid argument; `value` has no value.');
        }
        this.value = Guid.EMPTY;
        if (guid && Guid.isGuid(guid)) {
            this.value = guid;
        }
    }
    static isGuid(guid) {
        const value = guid.toString();
        return guid && (guid instanceof Guid || Guid.validator.test(value));
    }
    static create() {
        return new Guid([Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join('-'));
    }
    static createEmpty() {
        return new Guid('emptyguid');
    }
    static parse(guid) {
        return new Guid(guid);
    }
    static raw() {
        return [Guid.gen(2), Guid.gen(1), Guid.gen(1), Guid.gen(1), Guid.gen(3)].join('-');
    }
    static gen(count) {
        let out = '';
        for (let i = 0; i < count; i++) {
            // tslint:disable-next-line:no-bitwise
            out += (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        }
        return out;
    }
    equals(other) {
        // Comparing string `value` against provided `guid` will auto-call
        // toString on `guid` for comparison
        return Guid.isGuid(other) && this.value === other.toString();
    }
    isEmpty() {
        return this.value === Guid.EMPTY;
    }
    toString() {
        return this.value;
    }
    toJSON() {
        return {
            value: this.value,
        };
    }
}
Guid.validator = new RegExp('^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$', 'i');
Guid.EMPTY = '00000000-0000-0000-0000-000000000000';

/*
 * @Author: aalizzwell
 * @Date: 2019-10-25 13:30:52
 * @Last Modified by:   aalizzwell
 * @Last Modified time: 2019-10-25 13:30:52
 */
const isObservable = (value) => {
    if (!value) {
        return false;
    }
    if (value[Symbol.observable] && value === value[Symbol.observable]()) {
        return true;
    }
    if (value['@@observable'] && value === value['@@observable']()) {
        return true;
    }
    if (value instanceof Observable) {
        return true;
    }
    return false;
};
const ɵ0$1 = isObservable;

/**
 * 【对象属性元数据】名称
 */
const OBJECT_PROP_META = 'ObjectPropMeta';
/**
 * 【对象属性元数据装饰器工厂】的工厂
 */
function makeObjectPropMetaDecorator(options) {
    if (ObjectUtil.isPlainObject(options)) {
        return options;
    }
    const type = typeof options;
    if (type === 'string') {
        return {
            dataField: options
        };
    }
    if (type === 'function') {
        return {
            type: options
        };
    }
}
/**
 * 对象属性元数据装饰器工厂
 */
const ObjectPropMeta = makePropDecorator(OBJECT_PROP_META, makeObjectPropMetaDecorator);

/**
 * 【动态对象元数据装饰器】名称
 */
const DYNAMIC_PROP_META = 'DynamicPropMeta';
/**
 * 【动态对象元数据装饰器工厂】的工厂
 */
function makeDynamicPropMetaDecorator(options) {
    if (ObjectUtil.isPlainObject(options)) {
        return options;
    }
    const type = typeof options;
    if (type === 'string') {
        return {
            dataField: options
        };
    }
    if (type === 'function') {
        return {
            type: options
        };
    }
}
/**
 * 实体属性注解
 */
const DynamicPropMeta = makePropDecorator(DYNAMIC_PROP_META, makeDynamicPropMetaDecorator);

/**
 * 【列表属性元数据】名称
 */
const LIST_PROP_META = 'ListPropMeta';
/**
 * 【列表属性元数据装饰器工厂】的工厂
 */
function makeListPropMetaDecorator(options) {
    if (ObjectUtil.isPlainObject(options)) {
        return options;
    }
    const type = typeof options;
    if (type === 'string') {
        return {
            dataField: options
        };
    }
    if (type === 'function') {
        return {
            type: options
        };
    }
}
/**
 * 列表属性装饰器工厂
 */
const ListPropMeta = makePropDecorator(LIST_PROP_META, makeListPropMetaDecorator);

/**
 * 属性注解器通用方法
 */
class FieldMetadataUtil {
    /**
     * 获取实体所有的简单属性元数据
     * @param target 实体类型
     * @returns 形如：{[propName: string]: NgObjectProperty}
     */
    static getNgFields(target) {
        return MetadataUtil.getPropsMetadatasByName(target, PRIMITIVE_PROP_META);
    }
    /**
     * 获取某个简单属性的元数据
     */
    static getNgField(target, propName) {
        const ngFields = this.getNgFields(target);
        const ngField = ngFields[propName];
        return ngField;
    }
    /**
     * 获取实体属性在原始数据中的属性名
     */
    static getDataField(target, propName) {
        const ngField = this.getNgField(target, propName);
        return ngField.dataField || propName;
    }
    /**
     * 获取标注为NgObject的属性的元数据
     * @param target 实体类型
     * @returns 形如：{[propName: string]: NgObjectProperty}
     */
    static getNgObjects(target) {
        return MetadataUtil.getPropsMetadatasByName(target, OBJECT_PROP_META);
    }
    static getNgDynamic(target) {
        return MetadataUtil.getPropsMetadatasByName(target, DYNAMIC_PROP_META);
    }
    /**
     * 获取标注为NgList的属性的元数据
     * @param target 实体类型
     * @returns 形如：{[propName: string]: NgListProperty}
     */
    static getNgList(target) {
        return MetadataUtil.getPropsMetadatasByName(target, LIST_PROP_META);
    }
    /**
     * 获取实体标注为主键的属性元数据
     * @param target 实体类型
     */
    static getPrimaryFieldMetadata(target) {
        const ngFieldObj = FieldMetadataUtil.getNgFields(target);
        const primaryKey = Object.keys(ngFieldObj).find((prop) => {
            return ngFieldObj[prop].primary;
        });
        if (primaryKey) {
            const propMeta = ngFieldObj[primaryKey];
            propMeta.property = primaryKey;
            if (!propMeta.dataField) {
                propMeta.dataField = primaryKey;
            }
            return propMeta;
        }
        return undefined;
    }
    /**
     * 获取主键名称，没有主键时返回空字符串
     */
    static getPrimaryKey(entityType) {
        const primaryNgField = this.getPrimaryFieldMetadata(entityType);
        if (!primaryNgField) {
            return '';
        }
        return primaryNgField.property;
    }
}

/**
 * 实体元数据工具类
 */
class EntityMetadataUtil {
    /**
     * 获取所有属性
     * @todo：封装根据基类获取所有元数据的方法，解决重复代码
     */
    static getAllNgProperties(entityType) {
        const ngPlainProperties = this.getNgFieldProperties(entityType);
        const ngEntityProperties = this.getNgObjectProperties(entityType);
        const ngDynamicProperties = this.getNgDynamicProperties(entityType);
        const ngEntityListProperties = this.getNgObjectProperties(entityType);
        return Object.assign({}, ngPlainProperties, ngEntityProperties, ngDynamicProperties, ngEntityListProperties);
    }
    /**
     * 获取NgField的属性元数据
     */
    static getNgFieldProperties(entityType) {
        return MetadataUtil.getPropsMetadatasByName(entityType, PRIMITIVE_PROP_META);
    }
    /**
     * 获取NgObject属性元数据
     */
    static getNgObjectProperties(entityType) {
        return MetadataUtil.getPropsMetadatasByName(entityType, OBJECT_PROP_META);
    }
    /**
     * 获取NgDynamic属性元数据
     */
    static getNgDynamicProperties(entityType) {
        return MetadataUtil.getPropsMetadatasByName(entityType, DYNAMIC_PROP_META);
    }
    /**
     * 获取NgList属性元数据
     */
    static getNgListProperties(entityType) {
        return MetadataUtil.getPropsMetadatasByName(entityType, LIST_PROP_META);
    }
    /**
     * 获取主键属性元数据
     */
    static getPrimaryKeyProperty(entityType) {
        let primaryKeyProperty;
        const ngPlainProperties = EntityMetadataUtil.getNgFieldProperties(entityType);
        Object.keys(ngPlainProperties).forEach((propName) => {
            const ngProperty = ngPlainProperties[propName];
            if (ngProperty.primary === true) {
                primaryKeyProperty = ngProperty;
            }
        });
        return primaryKeyProperty;
    }
}

/*
 * @Author: Witt
 * @Date: 2018-12-07 09:05:09
 * @Last Modified by: Witt
 * @Last Modified time: 2018-12-27 20:35:02
 */
/**
 * 实体类型信息
 * @todo：
 * 1、构造时不应该识别Entity模块的东西，应该是更抽象的；
 * 2、构造函数应该接收一个Builder接口，由Entity或者其他实现层来实现这个接口。
 */
class DataTypeInfo {
    /**
     * 是否为值对象
     */
    get isValueObject() {
        return !this.primaryKey;
    }
    /**
     * 构造函数
     * @todo：不应该识别
     */
    constructor(type) {
        this.type = type;
        this.primaryKey = '';
        this.foreignKey = '';
        this.propInfoMap = new Map();
        this.collectPropInfos();
    }
    /**
     * 获取全部属性信息
     */
    getPropInfos() {
        return Array.from(this.propInfoMap.values());
    }
    /**
     * 获取全部属性的名称
     */
    getPropNames() {
        const propNames = [];
        const propInfos = this.getPropInfos();
        propInfos.forEach((propInfo) => {
            propNames.push(propInfo.name);
        });
        return propNames;
    }
    /**
     * 根据group获取属性信息数组
     */
    getPropInfosByGroup(group) {
        const allPropInfos = Array.from(this.propInfoMap.values());
        const propInfos = allPropInfos.filter((propInfo) => {
            return propInfo.group === group;
        });
        return propInfos;
    }
    /**
     * 根据group获取属性名称数组
     * @param group 属性分组
     */
    getPropNamesByGroup(group) {
        const propNames = [];
        const propInfos = this.getPropInfosByGroup(group);
        propInfos.forEach((propInfo) => {
            propNames.push(propInfo.name);
        });
        return propNames;
    }
    /**
     * 根据propName获取属性信息
     */
    getPropInfoByName(propName) {
        if (this.propInfoMap.has(propName)) {
            return this.propInfoMap.get(propName);
        }
        return null;
    }
    /**
     * 根据path获取属性信息
     */
    getPropInfoByPath(path) {
        // 先复制，防止shift方法产生污染
        const arrPath = path.concat([]);
        if (arrPath.length === 0) {
            throw Error(`属性路径不能为空`);
        }
        // 循环查找
        let typeInfo = this;
        let propInfo = null;
        while (typeInfo && arrPath.length > 0) {
            const propName = arrPath.shift();
            propInfo = typeInfo.getPropInfoByName(propName);
            if (!propInfo) {
                throw Error(`路径${path}中存在不正确的节点${propName}，请检查`);
            }
            typeInfo = propInfo.typeInfo;
            // 如果是动态列，并且路径数组里还有属性，统一设置为null(动态列不再描述属性信息)
            if (propInfo.group === DataPropGroup.Dynamic && arrPath.length > 0) {
                propInfo = null;
                typeInfo = null;
            }
        }
        return propInfo;
    }
    /**
     * 根据path获取对应属性的TypeInfo
     */
    getTypeInfoByPath(path) {
        // 空数组时返回
        if (path.length === 0) {
            return this;
        }
        // 获取对应属性信息
        const propInfo = this.getPropInfoByPath(path);
        if (!propInfo.typeInfo) {
            throw Error(`路径${path}无法定位到一个EntityTypeInfo，请检查`);
        }
        return propInfo.typeInfo;
    }
    /**
     * 获取主键的属性信息
     */
    getPrimaryKeyPropInfo() {
        return this.getPropInfoByName(this.primaryKey);
    }
    /**
     * 根据name获取影射名
     */
    getPropMappingByName(name) {
        const propInfo = this.getPropInfoByName(name);
        if (!propInfo) {
            return '';
        }
        return propInfo.mapping;
    }
    /**
     * 根据path获取映射名
     */
    getPropMappingByPath(path) {
        const propInfo = this.getPropInfoByPath(path);
        if (!propInfo) {
            return '';
        }
        return propInfo.mapping;
    }
    /**
     * 检查属性是否属于特定的分组
     */
    checkPropGroup(propName, propGroup) {
        const propInfo = this.getPropInfoByName(propName);
        if (propInfo && propInfo.group === propGroup) {
            return true;
        }
        return false;
    }
    /**
     * --------------------------------------------------------------------------------
     * 属性元数据 => 属性描述信息
     * --------------------------------------------------------------------------------
     */
    /**
     * 搜集所有属性信息
     * @todo：消除重复代码，ts不支持interface类型检测，暂时通过遍历实现。
     */
    collectPropInfos() {
        // 简单属性
        const ngPlainProperties = EntityMetadataUtil.getNgFieldProperties(this.type);
        Object.keys(ngPlainProperties).forEach((propName) => {
            const ngProperty = ngPlainProperties[propName];
            if (ngProperty.primary === true) {
                this.primaryKey = propName;
            }
            if (ngProperty.foreign === true) {
                this.foreignKey = propName;
            }
            this.addPropInfo(DataPropGroup.Primitive, propName, ngProperty.dataField, null, ngProperty);
        });
        // 实体属性
        const ngEntityProperties = EntityMetadataUtil.getNgObjectProperties(this.type);
        Object.keys(ngEntityProperties).forEach((propName) => {
            const ngProperty = ngEntityProperties[propName];
            this.addPropInfo(DataPropGroup.Object, propName, ngProperty.dataField, ngProperty.type, ngProperty);
        });
        // 动态实体属性
        const ngDynamicProperties = EntityMetadataUtil.getNgDynamicProperties(this.type);
        Object.keys(ngDynamicProperties).forEach((propName) => {
            const ngProperty = ngDynamicProperties[propName];
            this.addPropInfo(DataPropGroup.Dynamic, propName, ngProperty.dataField, null, ngProperty);
        });
        // 实体列表属性
        const ngEntityListProperties = EntityMetadataUtil.getNgListProperties(this.type);
        Object.keys(ngEntityListProperties).forEach((propName) => {
            const ngProperty = ngEntityListProperties[propName];
            this.addPropInfo(DataPropGroup.List, propName, ngProperty.dataField, ngProperty.type, ngProperty);
        });
    }
    /**
     * 添加属性信息
     */
    addPropInfo(group, name, mapping, type, metadataInfo) {
        // 没有设置影射时，用属性名充当影射
        mapping = mapping ? mapping : name;
        let typeInfo = null;
        if (type) {
            typeInfo = new DataTypeInfo(type);
        }
        const propInfo = { group, name, mapping, typeInfo, metadataInfo };
        this.propInfoMap.set(name, propInfo);
    }
}

/**
 * 数据Path工厂类
 */
class DataPathCreator {
    /**
     * 将长路径数组或字符串转换为
     * @param fullPathArrayOrString 路径数组或字符串
     * @param repository 实体仓库
     * @summary
     * 1、长路径格式说明参考：data-path.md
     */
    static createByLongPathFromRoot(fullPathArrayOrString, entityManager) {
        const dataPath = new DataPath();
        const fullPathArray = fullPathArrayOrString;
        if (!fullPathArray || fullPathArray.length === 0) {
            return dataPath;
        }
        let currentNodeInfo = {
            nodeValue: fullPathArray.shift(),
            nodeType: DataPathNodeType.DataId,
            entityTypeInfo: new DataTypeInfo(entityManager.entityType)
        };
        while (currentNodeInfo) {
            dataPath.push(currentNodeInfo.nodeType, currentNodeInfo.nodeValue);
            // 处理下一个节点
            const nextNodeValue = fullPathArray.shift();
            if (!nextNodeValue || !currentNodeInfo.entityTypeInfo) {
                break;
            }
            currentNodeInfo = this.getNextPathNodeInfo(currentNodeInfo, nextNodeValue);
        }
        return dataPath;
    }
    /**
     * 获取下一个路径节点的信息
     * @param parentNodeInfo 当前路径节点信息
     * @param nextNodeValue 下一个路径节点的值
     * @summary
     * 1、这个递归写的很绕，说明数据结构设计不合理；
     * 2、多个因素混用了一个结构；
     */
    static getNextPathNodeInfo(parentNodeInfo, nextNodeValue) {
        const parentNodeValue = parentNodeInfo.nodeValue;
        const parentNodeType = parentNodeInfo.nodeType;
        const parentEntityTypeInfo = parentNodeInfo.entityTypeInfo;
        if (!nextNodeValue || !parentEntityTypeInfo) {
            return null;
        }
        const nextPathNodeInfo = {
            nodeValue: nextNodeValue,
            nodeType: null,
            entityTypeInfo: null
        };
        // DataNodeType=List：下一节点肯定是Object，并且EntityTypeInfo不变
        if (parentNodeType === DataPathNodeType.DataId) {
            nextPathNodeInfo.nodeType = DataPathNodeType.PropName;
            nextPathNodeInfo.entityTypeInfo = parentEntityTypeInfo;
        }
        else {
            // DataNodeType=Object：必然对应一个属性信息
            const nextPropInfo = parentEntityTypeInfo.getPropInfoByName(parentNodeValue);
            if (nextPropInfo.group === DataPropGroup.List) {
                // EntityPropGroup=EntityList：下一个节点是List类型。
                nextPathNodeInfo.nodeType = DataPathNodeType.DataId;
                nextPathNodeInfo.entityTypeInfo = nextPropInfo.typeInfo;
            }
            else {
                // EntityPropGroup=Entity：       下级entityTypeInfo为
                // EntityPropGroup=Dynamic|Plain：null
                nextPathNodeInfo.nodeType = DataPathNodeType.PropName;
                nextPathNodeInfo.entityTypeInfo = nextPropInfo.group === DataPropGroup.Object ? nextPropInfo.typeInfo : null;
            }
        }
        return nextPathNodeInfo;
    }
    /**
     * @param fullPathArrayOrString 路径数组或字符串
     * @param repository 实体仓库
     * @summary
     * 1、长路径格式说明参考：data-path.md
     * 2、shortPathArrayOrString暂时只支持字符串数组
     */
    static createByShortPathFromRoot(shortPathArrayOrString, entityManager, bindingData) {
        const dataPath = new DataPath();
        const shortPathArray = shortPathArrayOrString;
        // 根节点
        let currentBindingObject = bindingData.list.currentItem;
        let currentEntityTypeInfo = new DataTypeInfo(entityManager.entityType);
        dataPath.push(DataPathNodeType.DataId, currentBindingObject.primaryKeyValue);
        // 遍历下级节点
        shortPathArray.forEach((propName) => {
            const propInfo = currentEntityTypeInfo.getPropInfoByName(propName);
            switch (propInfo.group) {
                case DataPropGroup.Primitive:
                    dataPath.push(DataPathNodeType.PropName, propName);
                    break;
                case DataPropGroup.Object:
                    currentBindingObject = currentBindingObject[propName];
                    currentEntityTypeInfo = propInfo.typeInfo;
                    dataPath.push(DataPathNodeType.PropName, propName);
                    break;
                case DataPropGroup.List:
                    const currentBindingList = currentBindingObject[propName];
                    currentBindingObject = currentBindingList.currentItem;
                    currentEntityTypeInfo = propInfo.typeInfo;
                    dataPath.push(DataPathNodeType.PropName, propName);
                    dataPath.push(DataPathNodeType.DataId, currentBindingObject.primaryKeyValue);
                    break;
                default:
                    break;
            }
        });
        return dataPath;
    }
}

/**
 * 获取path对应的实体
 * @summary
 * 关于path的格式如下：
 * - 主表：[parentId]
 * - 主表关联: [parentId, assoInfo]
 * - 从表: [parentId, child1s, child1Id]
 * - 从表关联：[parentId, child1s, child1Id, assoInfo]
 * - 从从表: [parentId, child1s, child1Id, grand11s, grand11Id]
 * - 从从表关联：[parentId, child1s, child1Id, grand11s, grand11Id, assoInfo]
 */

const PARENT_PATH = '__PARENT_PATH__';
const PARENT_CLASS = '__PARENT__';

/**
 * 创建实体
 * @param entityType 实体类型
 * @param entityData 实体数据
 */
function createEntity(entityType, entityData) {
    const entity = new entityType(entityData);
    return entity;
}
/**
 * 批量创建实体
 * @param entityType     实体类型
 * @param entityListData 实体数据数组
 */
function createEntities(entityType, entityListData) {
    const entities = [];
    entityListData.forEach((entityData) => {
        const entity = createEntity(entityType, entityData);
        entities.push(entity);
    });
    return entities;
}
/**
 * 已弃用：请使用createEntity方法代替。
 */
function EntityFactory(T, data) {
    const entity = new T(data);
    return entity;
}

/**
 * 实体集合列表
 */
class EntityList {
    // #endregion
    /**
     * @param data JSON数据集合
     * @param type 集合中的实体类型
     */
    constructor(data, type) {
        /**
         * 已废弃：请勿使用
         */
        this.listChanged = new Subject();
        /**
         * 已废弃：请勿使用
         */
        this.changeSet = new ChangeSet();
        // #endregion
        // #region 公有属性
        /**
         * 集合改变时触发(新增、行记录修改、删除)
         * @event
         */
        this.onListChanged = this.listChanged.asObservable();
        this.clear();
        if (data) {
            // this.loadEntities(data);
            data.forEach(item => {
                this.initEntity(EntityFactory(type, item));
            });
        }
    }
    /**
     * 获取项集合
     */
    get items() {
        return this.rawData;
    }
    /**
     * 列表变更集
     */
    get changes() {
        return this.changeSet.changes;
    }
    /**
     * 迭代器
     */
    *[Symbol.iterator]() {
        yield* this.items;
    }
    // #region 公有方法
    /** 加载实体列表 */
    loadEntities(entities) {
        this.clear();
        entities.forEach(entity => {
            this.initEntity(entity);
        });
        // 发送Load变更
        const changeItem = {
            path: [],
            value: entities,
            preValue: undefined,
            type: ModifyType.Load
        };
        this.setChanges(changeItem);
    }
    /**
     * 清空
     */
    clear() {
        this.rawData = [];
    }
    /**
     * 添加实体对象到集合中，并返回新加的对象
     * @param entity 实体对象
     */
    appendNew(entity) {
        const newEntity = this.initEntity(entity);
        // 新增变更
        const changeItem = {
            path: [],
            value: [newEntity],
            preValue: undefined,
            type: ModifyType.Add
        };
        this.setChanges(changeItem);
        return newEntity;
    }
    /**
     * 追加实体
     */
    appendEntity(entity) {
        const newEntity = this.initEntity(entity);
        // 新增变更
        const changeItem = {
            path: [],
            value: [newEntity],
            preValue: undefined,
            type: ModifyType.Add
        };
        this.setChanges(changeItem);
    }
    /**
     * 批量追加实体
     */
    appendEntities(entities) {
        const newEntites = entities.map((entity) => {
            return this.initEntity(entity);
        });
        const changeItem = {
            path: [],
            value: newEntites,
            preValue: undefined,
            type: ModifyType.Add
        };
        this.setChanges(changeItem);
    }
    /**
     * 删除指定主键ID 的实体对象，返回布尔，true 删除成功，false 删除失败
     * @param primaryId 主键ID
     */
    remove(primaryId) {
        const total = this.count();
        const indexToRemove = this.rawData.findIndex((entity) => {
            return entity.primaryValue === primaryId;
        });
        if (indexToRemove === -1) {
            return false;
        }
        const entityToRemove = this.rawData[indexToRemove];
        this.rawData.splice(indexToRemove, 1);
        // 删除变更
        const changeItem = {
            path: [],
            value: { [entityToRemove.primaryProperty.dataField]: primaryId },
            preValue: undefined,
            type: ModifyType.Remove
        };
        this.updateIndex(total);
        this.setChanges(changeItem);
        return true;
    }
    /**
     * 从集合中获取指定ID值的实体对象
     * @param id 主键值
     */
    get(id) {
        return this.items.find(item => {
            return item.primaryValue === id;
        });
    }
    /**
     * 将变更记录添加到集合变更集中
     * @param value 变更记录
     */
    setChanges(modinfo) {
        // 向app层发送的变更
        this.listChanged.next(modinfo);
        // 构造向changeSet中添加的chagne
        const change = Object.assign({}, modinfo);
        if (modinfo.type === ModifyType.Add && modinfo.value[0] instanceof Entity) {
            change.value = [modinfo.value[0].data];
        }
        this.changeSet.append(change);
    }
    /** 集合总记录数 */
    count() {
        return this.items.length;
    }
    /**
     * 获取实体对象的索引值
     */
    indexOf(entity) {
        return this.items.indexOf(entity);
    }
    /**
     * 计算集合中某个属性的总和
     * @param propertyName 属性名称
     */
    sum(propertyName) {
        if (this.count() === 0) {
            return 0;
        }
        return this.items.reduce((val, curr) => {
            return val + curr[propertyName];
        }, 0);
    }
    /**
     * 已废弃：请使用toJSON方法代替
     * @deprecated
     */
    toJson() {
        return this.rawData;
    }
    /**
     * 转换为JSON格式
     */
    toJSON() {
        const result = [];
        this.items.forEach((entity) => {
            result.push(entity.toJSON());
        });
        return result;
    }
    toArray() {
        return this.items;
    }
    // #endregion
    // #region 私有方法
    /**
     * 实体初始化
     * @param entity 实体
     */
    initEntity(entity) {
        entity[PARENT_CLASS] = this;
        entity[PARENT_PATH] = this[PARENT_PATH];
        entity.onValueChanged.subscribe((v) => {
            const path = v.path;
            const value = v.value;
            const preValue = v.preValue;
            const operator = v.type;
            const subChanges = { path, value, preValue, type: operator };
            this.setChanges(subChanges);
        });
        // TODO: 添加数据验证逻辑代码
        const newLength = this.rawData.push(entity);
        this[newLength - 1] = entity;
        return entity;
    }
    /**
     * 更新索引
     * @param total 总记录数
     */
    updateIndex(total) {
        for (let i = 0; i < total; i++) {
            delete this[i];
        }
        this.rawData.forEach((entity, index) => {
            this[index] = entity;
        });
    }
    /**
     * 获取属性名称
     */
    getPropertyName() {
        const path = this[PARENT_PATH];
        if (path && path.length) {
            const name = path[path.length - 1];
            return name;
        }
        return undefined;
    }
}

function EntityFactory$1(T, data) {
    const entity = new T(data);
    return entity;
}

;
/**
 * @author Lucas Huang
 * 实体抽象基类，所有实体必须扩展自Entity
 *
 * ### 使用示例
 * ```
 * export class UserEntity extends Entity {
 *    userId: string;
 *    userName: string;
 *
 *    constructor(data: any){
 *        super(data);
 *    }
 * }
 * ```
 */
class Entity {
    // #endregion
    /**
     * @param data JSON数据
     */
    constructor(data) {
        // #region 私有、保护属性
        /**
         * 验证错误集合
         */
        this.validErrors = {};
        /**
         * 增量变更集合
         */
        this.changeSet = new ChangeSet();
        /**
         * 是否正在验证
         */
        this.isValidating = false;
        /**
         * 新数据
         */
        this.newData = undefined;
        // #endregion
        // #region 公有属性
        /**
         * 变更流
         */
        this.valueChanged = new Subject();
        /**
         * 属性值改变时触发
         *
         * ### 使用示例
         * ```
         *  const entity = new UserEntity(data);
         *  entity.onValueChanged.subscribe((data: Modification) => {
         *      console.log(data);
         *  })
         *
         * ```
         *
         * @event
         */
        this.onValueChanged = this.valueChanged.asObservable();
        this.newData = Object.assign({}, data);
        this.onValueChanged = this.valueChanged;
        this.initialize();
    }
    /**
     * 返回JSON格式的数据
     */
    get data() {
        return this.newData;
    }
    /**
     * 验证错误集合
     */
    get errors() {
        return this.validErrors;
    }
    /**
     * 实体变更集
     */
    get changes() {
        return this.changeSet.changes;
    }
    /**
     * 实体主键元数据
     */
    get primaryProperty() {
        return FieldMetadataUtil.getPrimaryFieldMetadata(this.constructor);
    }
    /**
     * 主键
     * @todo
     * 1、没有主键时返回''不合理，应该返回undefined
     */
    get primaryKey() {
        if (this.primaryProperty) {
            return this.primaryProperty.property;
        }
        else {
            return '';
        }
    }
    /**
     * 实体主键值
     * 1、没有主键时返回''不合理，应该返回undefined
     */
    get primaryValue() {
        if (this.primaryKey) {
            // return this[this.primaryProperty.property].toString();
            const primaryValue = this[this.primaryProperty.property];
            return primaryValue ? primaryValue : '';
        }
        else {
            return '';
        }
    }
    // #region 公有方法
    /**
     * 将变更记录保存至变更集中
     * @param value 变更记录
     */
    setChanges(value) {
        const propertyName = value.path[value.path.length - 1];
        // @todo：事件会从下级向上冒泡，change可能是下级的，不能和当前Entity的newData合并。
        // this.newData = Object.assign(this.newData, { [propertyName]: value.value });
        this.valueChanged.next(value);
        this.changeSet.append(value);
    }
    getPaths() {
        const pathObj = {
            path: [],
            isUdt: false,
            isGrid: false
        };
        const handleParent = item => {
            const parentPaths = item[PARENT_PATH];
            if (parentPaths) {
                const prop = parentPaths[parentPaths.length - 1];
                // 父级所在实体包含的ngObject，存在当前实体字段，则判断为UDt字段
                if (Object.keys(FieldMetadataUtil.getNgObjects(item[PARENT_CLASS].constructor)).indexOf(prop) > -1) {
                    pathObj.isUdt = true;
                }
                // 存在类型为ngList，则判断为grid
                if (item[PARENT_CLASS] && item instanceof EntityList === true) {
                    pathObj.isGrid = true;
                }
                pathObj.path.push(prop);
            }
            if (item[PARENT_CLASS] && item instanceof EntityList === true) {
                handleParent(item[PARENT_CLASS]);
            }
        };
        handleParent(this);
        pathObj.path = pathObj.path.reverse();
        return pathObj;
    }
    /**
     * 加载数据
     * @param data 新数据
     */
    load(data) {
        if (!data) {
            data = {};
        }
        this.loadFields(data);
        this.loadLists(data);
        this.loadObjects(data);
        this.loadDynamicObjects(data);
        this.newData = Object.assign({}, data);
    }
    /**
     * 转换为JSON
     */
    toJSON() {
        const result = {};
        // 简单属性
        const ngFields = FieldMetadataUtil.getNgFields(this.constructor);
        Object.keys(ngFields).forEach((propName) => {
            const ngField = ngFields[propName];
            const dataField = ngField.dataField || propName;
            result[dataField] = this[propName];
        });
        // 对象属性
        const ngObjects = FieldMetadataUtil.getNgObjects(this.constructor);
        Object.keys(ngObjects).forEach((propName) => {
            const ngObject = ngObjects[propName];
            const dataField = ngObject.dataField || propName;
            result[dataField] = this[propName] ? this[propName].toJSON() : {};
        });
        // 动态属性
        const ngDynamics = FieldMetadataUtil.getNgDynamic(this.constructor);
        Object.keys(ngDynamics).forEach((propName) => {
            const ngDynamic = ngDynamics[propName];
            const dataField = ngDynamic.dataField || propName;
            result[dataField] = this[propName] ? this[propName].toJSON() : {};
        });
        // 列表属性
        const ngLists = FieldMetadataUtil.getNgList(this.constructor);
        Object.keys(ngLists).forEach((propName) => {
            const ngList = ngLists[propName];
            const dataField = ngList.dataField || propName;
            result[dataField] = this[propName] ? this[propName].toJSON() : {};
        });
        return result;
    }
    // #endregion
    //#region 实体初始化相关private方法
    /**
     * 初始化实体
     */
    initialize() {
        const constructor = this.constructor;
        const ngFields = FieldMetadataUtil.getNgFields(constructor);
        const ngObjects = FieldMetadataUtil.getNgObjects(constructor);
        const ngLists = FieldMetadataUtil.getNgList(constructor);
        const ngDynamic = FieldMetadataUtil.getNgDynamic(constructor);
        this.initializeNormalField(ngFields);
        this.initializeList(ngLists);
        this.initializeObject(ngObjects);
        this.initializeDynamic(ngDynamic);
    }
    /**
     * 创建path
     * @param propertyName 属性名称
     */
    createPath(propertyName) {
        const primaryFieldMetadata = this.primaryProperty;
        if (primaryFieldMetadata) {
            const primaryDataField = primaryFieldMetadata.dataField;
            return [primaryDataField + ':' + this.primaryValue, propertyName];
        }
        else {
            return [':', propertyName];
        }
    }
    /**
     * 属性字段初始化
     * @param ngFields 属性字段元数据
     */
    initializeNormalField(ngFields) {
        Object.keys(ngFields).forEach(propName => {
            const ngField = ngFields[propName];
            const dataField = ngField.dataField || propName;
            if (delete this[propName]) {
                Object.defineProperty(this, propName, {
                    get: function () {
                        return this.getPropValue(propName, ngField);
                    },
                    set: function (newPropValue) {
                        // 有主键的实体，必须先给主键赋值，否则其他字段不允许赋值
                        if (this.primaryKey && this.primaryKey === propName && !newPropValue) {
                            return;
                        }
                        if (this.primaryKey && this.primaryKey !== propName && !this.primaryValue) {
                            return;
                        }
                        // 值相同时不触发变更。
                        const oldPropValue = this.getPropValue(propName, ngField);
                        if (this.isPropValueChanged(propName, ngField, newPropValue, oldPropValue) === false) {
                            return;
                        }
                        this.setPropValue(propName, ngField, newPropValue);
                        this.emitValueChange(propName, ngField, newPropValue, oldPropValue);
                    },
                    configurable: true
                });
            }
        });
    }
    /**
     * 初始化列表类型的元数据
     * @param ngListMetadata 列表类型元数据
     */
    initializeList(ngListMetadata) {
        Object.keys(ngListMetadata).forEach(propertyName => {
            const fieldMetadata = ngListMetadata[propertyName];
            const path = this.createPath(propertyName);
            const dataField = fieldMetadata.dataField || propertyName;
            const val = this.data[dataField];
            const entityList = new EntityList();
            entityList[PARENT_CLASS] = this;
            entityList[PARENT_PATH] = path;
            if (val) {
                const entities = val.map(v => EntityFactory$1(fieldMetadata.type, v));
                entityList.loadEntities(entities);
            }
            entityList.onListChanged.subscribe(value => {
                if (value) {
                    if (entityList[PARENT_PATH][0] !== value.path[0]) {
                        value.path = entityList[PARENT_PATH].concat(value.path);
                    }
                    this.setChanges(value);
                }
            });
            this[propertyName] = entityList;
        });
    }
    /**
     * 初始化子对象
     * @param ngObjectMetadata 子对象元数据
     */
    initializeObject(ngObjectMetadata) {
        Object.keys(ngObjectMetadata).forEach(propertyName => {
            const fieldMetadata = ngObjectMetadata[propertyName];
            const path = this.createPath(propertyName);
            const dataField = fieldMetadata.dataField || propertyName;
            // val不存在时，用空对象代替
            const val = this.data[dataField] || {};
            const createEntityFromJsonData = (value) => {
                let instance;
                if (value instanceof fieldMetadata.type) {
                    instance = value;
                }
                else {
                    instance = EntityFactory$1(fieldMetadata.type, value);
                }
                instance[PARENT_CLASS] = this;
                instance[PARENT_PATH] = path;
                instance.onValueChanged.subscribe(changes => {
                    if (changes) {
                        changes.path = (this[PARENT_PATH] || []).concat(changes.path);
                        this.setChanges(changes);
                    }
                });
                return instance;
            };
            // 如果没有值用一个空对象代替
            let childEntity = createEntityFromJsonData(val);
            if (delete this[propertyName]) {
                Object.defineProperty(this, propertyName, {
                    get: () => {
                        return childEntity;
                    },
                    set: function (value) {
                        const modifyInfo = {
                            path: childEntity[PARENT_PATH],
                            value: value.data,
                            preValue: this[propertyName].data,
                            type: ModifyType.ValueChange
                        };
                        childEntity = createEntityFromJsonData(value);
                        this.setChanges(modifyInfo);
                    },
                    configurable: true
                });
            }
        });
    }
    initializeDynamic(ngDynamicMetadata) {
        Object.keys(ngDynamicMetadata).forEach(propertyName => {
            const fieldMetadata = ngDynamicMetadata[propertyName];
            const path = this.createPath(propertyName);
            const dataField = fieldMetadata.dataField || propertyName;
            const originalData = this.data[dataField] || {};
            const createEntityFromJsonData = (value) => {
                let instance;
                if (value instanceof fieldMetadata.type) {
                    instance = value;
                }
                else {
                    instance = EntityFactory$1(fieldMetadata.type, value);
                }
                instance[PARENT_CLASS] = this;
                instance[PARENT_PATH] = path;
                instance.onValueChanged.subscribe(changes => {
                    if (changes) {
                        changes.path = (this[PARENT_PATH] || []).concat(changes.path);
                        this.setChanges(changes);
                    }
                });
                return instance;
            };
            let dynamicEntity = createEntityFromJsonData(originalData);
            if (delete this[propertyName]) {
                Object.defineProperty(this, propertyName, {
                    get: function () {
                        return dynamicEntity;
                    },
                    set: function (value) {
                        const modifyInfo = {
                            path: dynamicEntity[PARENT_PATH],
                            value: value.data,
                            preValue: this[propertyName].data,
                            type: ModifyType.ValueChange
                        };
                        dynamicEntity = createEntityFromJsonData(value);
                        this.setChanges(modifyInfo);
                    },
                    configurable: true
                });
            }
        });
    }
    //#endregion
    // #region 加载实体数据相关private、projected方法
    /**
     * 加载简单字段值
     * @todo 临时用修改的方式模拟
     */
    loadFields(data) {
        const ngFields = FieldMetadataUtil.getNgFields(this.constructor);
        Object.keys(ngFields).forEach((propName) => {
            const ngField = ngFields[propName];
            const dataField = ngField.dataField || propName;
            // if (ngField.primary === false) {
            //   this[propName] = data[dataField];
            // }
            this[propName] = data[dataField];
        });
    }
    /**
     * 加载子列表数据
     * @param data 数据
     */
    loadLists(data) {
        const ngLists = FieldMetadataUtil.getNgList(this.constructor);
        Object.keys(ngLists).forEach((propName) => {
            const ngList = ngLists[propName];
            const dataField = ngList.dataField || propName;
            const entityType = ngList.type;
            // 创建实体
            const listData = data[dataField];
            if (listData) {
                const entities = listData.map((entityData) => {
                    return EntityFactory$1(entityType, entityData);
                });
                this[propName].loadEntities(entities);
            }
            else {
                this[propName].loadEntities([]);
            }
        });
    }
    loadObjects(data) {
        const ngObjects = FieldMetadataUtil.getNgObjects(this.constructor);
        Object.keys(ngObjects).forEach((propName) => {
            const ngObject = ngObjects[propName];
            const dataField = ngObject.dataField || propName;
            const objectData = data[dataField];
            const entity = this[propName];
            if (!entity || !objectData) {
                return;
            }
            entity.load(objectData);
        });
    }
    loadDynamicObjects(data) {
        const ngDynamicObjects = FieldMetadataUtil.getNgDynamic(this.constructor);
        Object.keys(ngDynamicObjects).forEach((propName) => {
            const ngDynamicObject = ngDynamicObjects[propName];
            const dataField = ngDynamicObject.dataField || propName;
            const dynamicData = data[dataField] || {};
            const dynamicEntity = this[propName];
            if (!dynamicEntity) {
                return;
            }
            dynamicEntity.loadDynamicData(dynamicData);
        });
    }
    // #endregion
    // #region 私有工具方法
    /**
     * 发送值变更
     */
    emitValueChange(propName, propMetadata, newPropValue, oldPropValue) {
        const change = {
            path: this.createPath(propName),
            value: newPropValue,
            preValue: oldPropValue,
            type: ModifyType.ValueChange
        };
        if (this[PARENT_PATH]) {
            change.path = this[PARENT_PATH].concat(change.path);
        }
        this.setChanges(change);
    }
    /**
     * 获取属性值
     */
    getPropValue(propName, propMetadata) {
        const dataField = propMetadata.dataField || propName;
        const value = this.data[dataField];
        // 对多语录入字段，query不返回问题进行兼容
        if (propMetadata.enableMultiLangInput === true && !value) {
            const langCode = window.localStorage.getItem('languageCode') || 'zh-CHS';
            const originDataField = dataField.replace('_MULTILANGUAGE', '');
            return {
                [langCode]: this.data[originDataField]
            };
        }
        return value;
    }
    /**
     * 设置属性值
     */
    setPropValue(propName, propMetadata, propValue) {
        const dataField = propMetadata.dataField || propName;
        this.data[dataField] = propValue;
    }
    /**
     * 检查属性值是否发生变化
     */
    isPropValueChanged(propName, propMetadata, newPropValue, oldPropValue) {
        if (propMetadata.enableMultiLangInput === true) {
            if (this.isEmptyMultiLangPropValue(newPropValue) === true && this.isEmptyMultiLangPropValue(oldPropValue) === true) {
                return false;
            }
            return JSON.stringify(newPropValue) !== JSON.stringify(oldPropValue);
        }
        else {
            return newPropValue !== oldPropValue;
        }
    }
    /**
     * 多语录入字段的值是否为空
     */
    isEmptyMultiLangPropValue(value) {
        return !value || Object.keys(value).length === 0;
    }
}

/**
 * 支持动态字段集合的动态实体
 */
class DynamicEntity extends Entity {
    /**
     * 是否是嵌套的动态实体
     */
    get IsNested() {
        return this[PARENT_CLASS] instanceof DynamicEntity;
    }
    /**
     * @param data JSON数据
     */
    constructor(data) {
        super(data);
        this.loadDynamicData(data);
    }
    loadDynamicData(dynamicData) {
        this.initializeDynamicField(dynamicData);
        // super.loadFields(dynamicData);
    }
    /**
     * 初始化动态数据
     * @param dynamicData 动态数据
     */
    initializeDynamicField(dynamicData) {
        // 遍历动态数据的key，创建动态实体属性。
        Object.keys(dynamicData).forEach(propertyName => {
            // 如果属性已经存在，先删除
            if (this[propertyName]) {
                delete this[propertyName];
            }
            const dataField = propertyName;
            if (dynamicData[propertyName] instanceof Object) {
                const path = this.createPath(propertyName);
                let dynamicEntity = this.createDynamicEntityFromJsonData(dynamicData[propertyName], path);
                Object.defineProperty(this, propertyName, {
                    get: function () {
                        return dynamicEntity;
                    },
                    set: function (value) {
                        const modifyInfo = {
                            path: dynamicEntity[PARENT_PATH],
                            value: value.data,
                            preValue: this[propertyName].data,
                            type: ModifyType.ValueChange
                        };
                        dynamicEntity = this.createDynamicEntityFromJsonData(value, path);
                        this.setChanges(modifyInfo);
                    },
                    configurable: true
                });
            }
            else {
                Object.defineProperty(this, propertyName, {
                    // 定义返回数据方法。
                    get: function () {
                        // 从初始数据返回字段值。
                        return this.data[dataField];
                    },
                    set: function (value) {
                        // 值相同时不触发变更。
                        const oldValue = this.data[dataField];
                        if (oldValue === value) {
                            return;
                        }
                        // 更新元数据数据。
                        this.data[dataField] = value;
                        // 变更集
                        const changes = {
                            type: ModifyType.ValueChange,
                            path: this.createPath(propertyName),
                            value: value,
                            preValue: oldValue
                        };
                        if (this[PARENT_PATH]) {
                            changes.path = this[PARENT_PATH].concat(changes.path);
                        }
                        this.setChanges(changes);
                    },
                    configurable: true
                });
            }
        });
    }
    createDynamicEntityFromJsonData(value, parentPath) {
        let instance;
        if (value instanceof DynamicEntity) {
            instance = value;
        }
        else {
            instance = new DynamicEntity(value);
        }
        instance[PARENT_CLASS] = this;
        instance[PARENT_PATH] = parentPath;
        instance.onValueChanged.subscribe(changes => {
            if (changes) {
                changes.path = (this[PARENT_PATH] || []).concat(changes.path);
                this.setChanges(changes);
            }
        });
        return instance;
    }
    /**
     * 将变更记录保存至变更集中
     * @param value 变更记录
     * @todo
     * 1、preValue的处理有问题，下级传递上来的变更这样可以，根DyanmicaEntity上的，data已经发生变化，prevalue和value是一样了；
     * 2、当value是下级冒泡上来的，需要根据value去更新当前层级的data，该逻辑不应该放在setChagnes，待修改。
     */
    setChanges(value) {
        const propertyName = value.path[value.path.length - 1];
        const preValue = Object.assign({}, this.data);
        this.newData = Object.assign(this.newData, { [propertyName]: value.value });
        let parentPath = value.path;
        if (value.path.length > 2) {
            parentPath = value.path.slice(0, value.path.length - 2);
        }
        // 统一不使用构造函数（保持和其他位置对Modification的构造一致）
        // const parentModification = new Modification(this.data, value.type, parentPath, preValue);
        const parentModification = {
            path: parentPath,
            value: this.data,
            preValue: preValue,
            type: value.type
        };
        this.valueChanged.next(parentModification);
        this.changeSet.append(value);
    }
    /**
     * toJSON
     */
    toJSON() {
        return this.data;
    }
}

/**
 * REPOSITORY_META
 */
const REPOSITORY_META = 'RepositoryMeta';
/**
 * RepositoryMeta
 */
function RepositoryMeta(options) {
    const decoratorFactory = makeDecorator(REPOSITORY_META, (obj) => obj);
    return decoratorFactory(options);
}

// tslint:disable: no-bitwise
/**
 * 实体集合
 * @todo：应该用EntityList代替。
 */
class EntityCollection {
    /**
     * 构造函数
     */
    constructor(entityType) {
        this.innerEntitySet = new Set();
        this.innerEntityMap = new Map();
        this.collectionChanged = new Subject();
        this.entityType = entityType;
        this.primaryKey = FieldMetadataUtil.getPrimaryKey(this.entityType);
    }
    /**
     * 实体数量
     */
    count() {
        return this.innerEntitySet.size;
    }
    get entityTypeName() {
        return this.entityType.name;
    }
    /**
     * 是否包含指定主键值的实体
     * @param id 主键值
     */
    has(id) {
        return this.innerEntityMap.has(id);
    }
    /**
     * 清空全部实体
     */
    clear() {
        this.innerEntityMap.clear();
        this.innerEntitySet.clear();
        this.notifyCollectionChanged(new Modification([], ModifyType.Load));
    }
    /**
     * 转换为实体数组
     */
    toArray() {
        return Array.from(this.innerEntitySet);
    }
    /**
     * 转换为JSON数组
     */
    toJSON() {
        const result = [];
        const entities = this.toArray();
        entities.forEach((entity) => {
            result.push(entity.toJSON());
        });
        return result;
    }
    /**
     * 批量加载实体
     */
    loadEntities(entities) {
        this.innerEntityMap.clear();
        this.innerEntitySet.clear();
        entities.forEach(entity => {
            this.innerEntitySet.add(entity);
            this.innerEntityMap.set(entity[this.primaryKey], entity);
        });
        this.notifyCollectionChanged(new Modification(entities, ModifyType.Load));
    }
    /**
     * 追加实体
     * @param entity 要追加的实体
     */
    addEntity(entity) {
        this.verifyEntityToAdd(entity);
        this.innerEntitySet.add(entity);
        this.innerEntityMap.set(entity[this.primaryKey], entity);
        this.notifyCollectionChanged(new Modification([entity], ModifyType.Add));
    }
    /**
     * 批量追加实体
     * @param entities 要加载的实体数组
     */
    addEntities(entities) {
        if (!entities) {
            return;
        }
        const entitiesToAdd = [];
        entities.forEach(entity => {
            this.verifyEntityToAdd(entity);
            entitiesToAdd.push(entity);
        });
        entitiesToAdd.forEach(entity => {
            this.innerEntitySet.add(entity);
            this.innerEntityMap.set(entity[this.primaryKey], entity);
        });
        this.notifyCollectionChanged(new Modification(entitiesToAdd, ModifyType.Add));
    }
    /**
     * 根据主键值获取实体
     */
    getEntityById(identity) {
        if (this.innerEntityMap.has(identity) === false) {
            return null;
        }
        const entity = this.innerEntityMap.get(identity);
        return entity;
    }
    /**
     * 根据路径获取实体
     */
    getEntityByPath(pathArray) {
        const rootEntityId = pathArray[0].split(':')[1];
        let parentNode = this.getEntityById(rootEntityId);
        for (let i = 1; i < pathArray.length && parentNode; i = i + 1) {
            const currentPath = pathArray[i];
            if (parentNode instanceof Entity) {
                // @todo：强识了别冒号
                if (currentPath.indexOf(':') === -1) {
                    parentNode = parentNode[pathArray[i]];
                }
            }
            else {
                parentNode = parentNode.get(pathArray[i].split(':')[1]);
            }
        }
        return parentNode;
    }
    /**
     * 返回符合指定条件的实体集合
     * @param predicate 条件谓词
     */
    getEntities(predicate) {
        const entities = Array.from(this.innerEntitySet);
        const matchedEntities = entities.filter(predicate);
        return matchedEntities;
    }
    /**
     * 获取全部实体
     */
    getAllEntities() {
        return Array.from(this.innerEntitySet);
    }
    /**
     * 根据主键值删除对应实体
     * @param identity 主键值
     */
    removeEntityById(identity) {
        this.verifyEntityToRemove(identity);
        const entityToRemove = this.innerEntityMap.get(identity);
        this.innerEntityMap.delete(identity);
        this.innerEntitySet.delete(entityToRemove);
        this.notifyCollectionChanged(new Modification([entityToRemove], ModifyType.Remove));
        return entityToRemove;
    }
    removeEntitiesByIds(id) {
    }
    /**
     * 删除符合条件的实体集合
     */
    removeEntities(predicate) {
        const entitiesToRemove = Array.from(this.innerEntitySet).filter(predicate);
        entitiesToRemove.forEach(entityToRemove => {
            this.innerEntityMap.delete(entityToRemove[this.primaryKey]);
            this.innerEntitySet.delete(entityToRemove);
        });
        this.notifyCollectionChanged(new Modification(entitiesToRemove, ModifyType.Remove));
        return entitiesToRemove;
    }
    /**
     * 重置子表数据
     * @param paths 路径
     * 路径格式 ['实体主键:主键值','从表Codes','从从表Codes']
     * @param entities 实体数组
     */
    resetEntities(paths, entities) {
        if (paths[0].indexOf(':') === -1) {
            throw new Error('路径格式错误');
        }
        // paths里面第一个一定是id
        const entityInfo = paths[0].split(':');
        const [entityPrimaryKey, entityId] = entityInfo;
        let entity = null;
        for (const element of this.innerEntitySet) {
            if (element[entityPrimaryKey] === entityId) {
                entity = element;
                break;
            }
        }
        // for (let index = 0; index < this.innerEntitySet; index++) {
        //   const element: T = this.innerEntitySet[index];
        //   if (element[entityPrimaryKey] === entityId) {
        //     entity = element;
        //     break;
        //   }
        // }
        if (!entity) {
            throw new Error(`找不到${entityPrimaryKey}为${entityId}的实体`);
        }
        let data = entity;
        paths.slice(1).forEach(path => {
            data = data[path];
        });
        const entityList = data;
        entityList.clear();
        entityList.loadEntities(entities);
    }
    /**
     * 验证实体是否能够添加
     */
    verifyEntityToAdd(entity) {
        if (this.has(entity[this.primaryKey])) {
            this.innerEntitySet.delete(this.innerEntityMap.get(entity[this.primaryKey]));
            this.innerEntityMap.delete(entity[this.primaryKey]);
            // throw new Error(`The repository already had an item with the save identity of '${entity[this.primaryKey]}'`);
        }
        return true;
    }
    /**
     * 验证实体是否能移除
     */
    verifyEntityToRemove(identity) {
        if (!this.has(identity)) {
            throw new Error(`The entity with identity of '${identity} dose not exsit.'`);
        }
        return true;
    }
    /**
     * 实体集合变更流
     */
    notifyCollectionChanged(modification) {
        this.collectionChanged.next(modification);
    }
    //#region 分页
    /**
     * 设置分页大小
     */
    set pageSize(pageSize) {
        if (typeof (pageSize) !== 'number' || pageSize < 0) {
            throw new Error('Invalid parameter:pageSize');
        }
        const original = this.paginationInfo;
        // const entityPaginationInfo = Object.assign({}, original[this.entityTypeName], { pageSize });
        // this.paginationInfo = Object.assign({}, original, { [this.entityTypeName]: entityPaginationInfo });
        // this.notifyCollectionChanged(new Modification(this.paginationInfo[this.entityTypeName], ModifyType.PaginationInfoChange));
        this.paginationInfo = Object.assign({}, original, { pageSize });
        this.notifyCollectionChanged(new Modification(this.paginationInfo, ModifyType.PaginationInfoChange));
    }
    /**
     * 获取分页大小
     * @description 如果用户未指定分页大小则默认为0，即获取所有数据
     */
    get pageSize() {
        if (!!this.paginationInfo) {
            return this.paginationInfo.pageSize || 0;
        }
        return 0;
    }
    /**
     * 设置数据总条数
     */
    set totalCount(total) {
        if (typeof (total) !== 'number' || total < 0) {
            throw new Error('Invalid parameter:total');
        }
        const original = this.paginationInfo;
        // const entityPaginationInfo = Object.assign({}, original[this.entityTypeName], { total });
        // this.paginationInfo = Object.assign({}, original, { [this.entityTypeName]: entityPaginationInfo });
        this.paginationInfo = Object.assign({}, original, { total });
        this.notifyCollectionChanged(new Modification(this.paginationInfo, ModifyType.PaginationInfoChange));
    }
    /**
     * 获取数据总条数
     */
    get totalCount() {
        if (!!this.paginationInfo) {
            return this.paginationInfo.total || 0;
        }
        return 0;
    }
    /**
     * 设置当前页码
     */
    set pageIndex(pageIndex) {
        if (typeof (pageIndex) !== 'number' || pageIndex < 0) {
            throw new Error('Invalid parameter:pageIndex');
        }
        const original = this.paginationInfo;
        // const entityPaginationInfo = Object.assign({}, original[this.entityTypeName], { pageIndex });
        // this.paginationInfo = Object.assign({}, original, { [this.entityTypeName]: entityPaginationInfo });
        this.paginationInfo = Object.assign({}, original, { pageIndex });
        this.notifyCollectionChanged(new Modification(this.paginationInfo, ModifyType.PaginationInfoChange));
    }
    /**
     * 获取当前页码
     */
    get pageIndex() {
        if (!!this.paginationInfo) {
            return this.paginationInfo.pageIndex || 1;
        }
        return 1;
    }
    /**
     * 更新分页信息
     * @param path 绑定路径
     * @param pageInfo 分页信息
     */
    updatePaginationInfoByPath(path, pageInfo) {
        const original = this.paginationInfo;
        const { pageIndex, pageSize, totalCount: total } = pageInfo;
        const paginationInfo = Object.assign({}, original, { pageIndex, pageSize, total });
        this.setPaginationConfigByPath(path, paginationInfo);
    }
    /**
     * 根据路径获取分页大小
     * @param path 路径
     */
    getPaginationConfigByPath(path, defaultValue) {
        if (!path || path === '/') {
            return this.paginationInfo;
        }
        if (typeof path !== 'string') {
            throw new Error('路径必须为字符串！');
        }
        path = path.substring(1);
        const paths = path.split('/').filter(item => !!item && item.trim().length > 0).map(item => item.trim());
        let config = this.paginationInfo;
        paths.forEach(item => {
            if (config && config.hasOwnProperty(item)) {
                config = config[item];
            }
            else {
                config = null;
            }
        });
        return !!config ? config : typeof defaultValue !== 'undefined' ? defaultValue : undefined;
    }
    /**
     * 设置分页信息
     * @param path 路径
     * @param value 值
     */
    setPaginationConfigByPath(path, value) {
        const original = JSON.stringify(this.paginationInfo);
        if (!path || path === '/') {
            this.paginationInfo = value;
        }
        else {
            if (!Array.isArray(path)) {
                path = path.toString().match(/[^/[\]]+/g) || [];
            }
            path.slice(0, -1).reduce((prev, current, index) => Object(prev[current]) === prev[current]
                ? prev[current]
                : prev[current] = Math.abs(path[index + 1]) >> 0 === +path[index + 1]
                    ? []
                    : {}, this.paginationInfo)[path[path.length - 1]] = value;
        }
        if (JSON.stringify(this.paginationInfo) !== original) {
            this.notifyCollectionChanged(new Modification(this.paginationInfo, ModifyType.PaginationInfoChange));
        }
        return this.paginationInfo;
    }
}

/*
 * @Author: Witt
 * @Date: 2019-03-07 17:24:38
 * @Last Modified by:   Witt
 * @Last Modified time: 2019-03-11 19:50:38
 */
/**
 * 实体管理类
 */
class EntityManager {
    /**
     * 构造函数
     */
    constructor(entityCollection) {
        this.entityCollection = entityCollection;
        this.entityType = entityCollection.entityType;
    }
    // #region 创建实体相关方法
    /**
     * 创建实体
     */
    createEntity(entityData) {
        const entity = createEntity(this.entityType, entityData);
        return entity;
    }
    /**
     * 批量创建实体
     */
    createEntities(entityListData, entityType) {
        const entities = createEntities(this.entityType, entityListData);
        return entities;
    }
    // #endregion
    // #region 获取实体、实体数组相关方法
    /**
     * 获取path对应的实体
     */
    getEntityByPath(path) {
        const entity = this.getEntityNodeByPath(path);
        return entity;
    }
    /**
     * 获取path对应的实体
     */
    getEntitiesByPath(path) {
        const entityCollectionOrList = this.getEntityNodeByPath(path);
        let entities;
        if (entityCollectionOrList instanceof EntityCollection === true) {
            entities = entityCollectionOrList.toArray();
        }
        else {
            entities = entityCollectionOrList.toArray();
        }
        return entities;
    }
    /**
     * 获取实体节点
     * @param path 节点路径
     */
    getEntityNodeByPath(path) {
        const dataPath = DataPathCreator.createByLongPathFromRoot(path, this);
        let entityNode = this.entityCollection;
        let pathNode = dataPath.head.next;
        while (pathNode) {
            if (pathNode.type === DataPathNodeType.DataId) {
                if (entityNode instanceof EntityCollection === true) {
                    entityNode = entityNode.getEntityById(pathNode.value);
                }
                else {
                    entityNode = entityNode.get(pathNode.value);
                }
            }
            else {
                entityNode = entityNode[pathNode.value];
            }
            if (!entityNode) {
                throw new Error(`找不到${pathNode.value}对应的数据节点`);
            }
            pathNode = pathNode.next;
        }
        return entityNode;
    }
    // #endregion
    // #region 获取、设置属性值
    /**
     * 获取path对应的实体属性值
     */
    getPropValueByPath(path) {
        const propName = path.pop();
        const entity = this.getEntityByPath(path);
        return entity[propName];
    }
    /**
     * 设置path对应实体的属性值
     */
    setPropValueByPath(path, propValue) {
        const propName = path.pop();
        const entity = this.getEntityByPath(path);
        entity[propName] = propValue;
    }
    // #endregion
    // #region 插入实体
    /**
     * 在path对应实体前插入实体
     */
    insertEntityBeforeByPath(fpath) {
        throw new Error('Not Implemented');
    }
    /**
     * 在path对应实体前批量插入实体
     */
    insertEntitiesBeforeByPath() {
        throw new Error('Not Implemented');
    }
    /**
     * 在path对应实体前插入实体
     */
    insertEntityAfterByPath() {
        throw new Error('Not Implemented');
    }
    /**
     * 在path对应实体前批量插入实体
     */
    insertEntitiesAfterByPath() {
        throw new Error('Not Implemented');
    }
    // #endregion
    // #region 追加实体
    /**
     * 在path对应的实体集合中追加1个实体
     */
    // public appendEntityByPath(fpath: string[], entity: Entity): void {
    //   const entityCollectionOrList = this.getEntityNodeByPath(fpath);
    //   if (entityCollectionOrList instanceof EntityCollection === true) {
    //     const entityCollection = entityCollectionOrList as EntityCollection<Entity>;
    //     entityCollection.addEntity(entity);
    //   } else {
    //     const entityList = (entityCollectionOrList as EntityList<Entity>);
    //     entityList.appendEntity(entity);
    //   }
    // }
    /**
     * 根据path获取实体集合
     * @param fpath 路径
     * @param entityData 实体数据
     * @param initialData[可选] 默认值
     */
    appendEntityByPath(fpath, entityData, initialData) {
        const subPaths = fpath.split('/');
        if (subPaths.length < 3) {
            throw Error(`根据path删除实体数据出错了。传入的path[${fpath}]格式不对`);
        }
        let childEntityList;
        let propInfo;
        let propName;
        for (let i = 2; i < subPaths.length; i = i + 2) {
            const fid = subPaths[i - 1];
            propName = subPaths[i];
            // todo: EntityCollection重构之后这里无需差异处理
            const parentEntity = childEntityList ? childEntityList.get(fid) : this.entityCollection.getEntityById(fid);
            childEntityList = parentEntity[propName];
            const entityType = propInfo ? propInfo.propEntityType : this.entityType;
            propInfo = EntityUtil.getPropInfo(entityType, propName);
            if (!childEntityList) {
                throw Error(`fpath参数错误，无法找到${propName}对应的子表。fpath为：${fpath}`);
            }
        }
        // const propInfo = EntityUtil.getPropInfo(this.entityType, propName);
        const childEntity = createEntity(propInfo.propEntityType, entityData);
        // 在实体的实例上增加默认值属性，以便在createBindingObject时存放默认值
        if (initialData) {
            EntityUtil.appendInitialData(childEntity, initialData);
        }
        childEntityList.appendNew(childEntity);
        return childEntity;
    }
    /**
     * 在path对应的实体集合中追加多个实体
     */
    appendEntitiesByPath(fpath, entities) {
        const entityCollectionOrList = this.getEntityNodeByPath(fpath);
        if (entityCollectionOrList instanceof EntityCollection === true) {
            const entityCollection = entityCollectionOrList;
            entityCollection.addEntities(entities);
        }
        else {
            const entityList = entityCollectionOrList;
            entityList.appendEntities(entities);
        }
    }
    // #endregion
    // #region 删除实体
    /**
     * 从fapth对应的实体集合中删除id对应的实体
     */
    // public removeEntityByPath(fpath: string[], id: string): void {
    //   const entityCollectionOrList = this.getEntityNodeByPath(fpath);
    //   if (entityCollectionOrList instanceof EntityCollection === true) {
    //     const entityCollection = entityCollectionOrList as EntityCollection<Entity>;
    //     entityCollection.removeEntityById(id);
    //   } else {
    //     const entityList = (entityCollectionOrList as EntityList<Entity>);
    //     entityList.remove(id);
    //   }
    // }
    /**
     * 根据path获取实体集合
     * @param fpath path
     */
    removeEntityByPath(fpath, id) {
        const subPaths = fpath.split('/');
        if (subPaths.length < 3) {
            throw Error(`根据path删除实体数据出错了。传入的path[${fpath}]格式不对`);
        }
        let childEntityList;
        for (let i = 2; i < subPaths.length; i = i + 2) {
            const fid = subPaths[i - 1];
            const propName = subPaths[i];
            const parentEntity = childEntityList ? childEntityList.get(fid) : this.entityCollection.getEntityById(fid);
            childEntityList = parentEntity[propName];
            if (!childEntityList) {
                throw Error(`fpath参数错误，无法找到${propName}对应的子表。fpath为：${fpath}`);
            }
        }
        childEntityList.remove(id);
    }
    /**
     * 从fapth对应的实体集合中删除ids对应的实体
     */
    removeEntitiesByPath(fpath, ids) {
        // const entityCollectionOrList = this.getEntityNodeByPath(fpath);
        // if (entityCollectionOrList instanceof EntityCollection === true) {
        //   const entityCollection = entityCollectionOrList as EntityCollection<Entity>;
        //   entityCollection.removeEntitiesByIds(ids);
        // } else {
        //   const entityList = (entityCollectionOrList as EntityList<Entity>);
        //   entityList.remove(ids);
        // }
        throw new Error('Not Implemented');
    }
    // #endregion
    // #region 清空变更集相关方法
    /**
     * 清空所有实体的变更集
     */
    clearAllEntityChanges() {
        const entities = this.entityCollection.toArray();
        entities.forEach((entity) => {
            entity.changes.splice(0, entity.changes.length);
        });
    }
    /**
     * 清空id指定的实体变更集
     */
    clearEntityChangesById(id) {
        const entity = this.entityCollection.getEntityById(id);
        if (!entity) {
            return;
        }
        entity.changes.splice(0, entity.changes.length);
    }
    /**
     * 清空ids数组中指定的实体的变更集
     */
    clearEntityChangesByIds(ids) {
        if (!ids || ids.length < 0) {
            return;
        }
        ids.forEach((id) => {
            this.clearEntityChangesById(id);
        });
    }
    // #endregion
    // #region 变更集检查相关方法
    /**
     * 检查所有的实体，是否有未提交的变更
     */
    checkAllEntityChanges() {
        const entities = this.entityCollection.toArray();
        const hasChanges = entities.some((entity) => {
            if (entity.changes.length > 0) {
                return true;
            }
            else {
                return false;
            }
        });
        return hasChanges;
    }
    /**
     * 检查id对应的实体，是否有未提交的变更
     */
    checkEntityChangesById(id) {
        const entity = this.entityCollection.getEntityById(id);
        if (!entity) {
            return false;
        }
        return entity.changes.length > 0;
    }
    // #endregion
    // #region 不规范方法，待废弃
    /**
     * 待废弃
     * @deprecated
     */
    clearEntityChangesByArray(idArray) {
        this.clearEntityChangesByIds(idArray);
    }
}

// tslint:disable: no-bitwise
class PaginationManager {
    constructor(entityType, paginationConfig) {
        this.entityType = entityType;
        this.paginationConfig = paginationConfig;
        if (this.paginationConfig === null || this.paginationConfig === undefined) {
            this.paginationConfig = this.getNgListProperties();
        }
        // 兼容老表单，将之前的主表分页信息展开到分页配置根中
        this.expandMainEntityConfig();
        this.deleteMainEntityConfig();
    }
    /**
     * 主表分页信息展开到分页配置根中
     */
    expandMainEntityConfig() {
        const entityName = this.entityType.name;
        if (this.paginationConfig.hasOwnProperty(entityName)) {
            const entityConfig = this.paginationConfig[entityName];
            this.paginationConfig = Object.assign(this.paginationConfig, entityConfig);
        }
    }
    /**
     * 删除主表实体配置信息
     */
    deleteMainEntityConfig() {
        delete this.paginationConfig[this.entityType.name];
    }
    /**
     * 获取分页信息
     */
    get pagination() {
        return this.paginationConfig;
    }
    /**
     * 获取分页信息
     * @param path 路径
     * @param defaultValue 默认值
     */
    getPaginationConfigByPath(path, defaultValue) {
        if (!path || path === '/') {
            return this.paginationConfig;
        }
        if (typeof path !== 'string') {
            throw new Error('路径必须为字符串！');
        }
        path = path.substring(1);
        const paths = path.split('/').filter(item => !!item && item.trim().length > 0);
        let config = this.paginationConfig;
        paths.forEach(item => {
            if (config && config.hasOwnProperty(item)) {
                config = config[item];
            }
            else {
                config = null;
            }
        });
        return !!config ? config : typeof defaultValue !== 'undefined' ? defaultValue : undefined;
    }
    /**
     * 设置分页信息
     * @param path 路径
     * @param value 值
     */
    setPaginationConfigByPath(path, value) {
        if (!Array.isArray(path)) {
            path = path.toString().match(/[^/[\]]+/g) || [];
        }
        path.slice(0, -1).reduce((prev, current, index) => Object(prev[current]) === prev[current]
            ? prev[current]
            : prev[current] = Math.abs(path[index + 1]) >> 0 === +path[index + 1]
                ? []
                : {}, this.paginationConfig)[path[path.length - 1]] = value;
        return this.paginationConfig;
    }
    /**
     * 递归获取当前实体的所有NgList属性
     * @param defaultPageSize defaultPageSize
     */
    getNgListProperties(defaultPageSize = 0) {
        const getChilds = (objectType) => {
            const listProperties = FieldMetadataUtil.getNgList(objectType);
            let result = {};
            if (Object.keys(listProperties).length < 1) {
                return result;
            }
            Object.keys(listProperties).forEach(prop => {
                let itemTypeName = listProperties[prop].dataField;
                // 去掉尾部的s
                if (itemTypeName.endsWith('s')) {
                    itemTypeName = itemTypeName.substring(0, itemTypeName.length - 1);
                }
                result[itemTypeName] = {
                    pageSize: defaultPageSize
                };
                const child = getChilds(listProperties[prop].type);
                if (child !== null && Object.keys(child).length > 0) {
                    result = Object.assign({}, result, child);
                }
            });
            return result;
        };
        const childs = getChilds(this.entityType);
        const root = Object.assign({}, { pageSize: defaultPageSize }, childs);
        return root;
    }
}

class DataChangeHistory {
    constructor() {
        this.history = [];
    }
    addChange(dataChange) {
        const changeType = DataChangeType[dataChange.changeType];
        this[`on${changeType}Data`](dataChange);
    }
    addChanges(dataChange) {
        dataChange.forEach(change => this.addChange(change));
    }
    clear() {
        this.history.splice(0, this.history.length);
    }
    clearByIds(ids) {
        this.history = this.history.filter(item => {
            if (item.fpath && item.fpath !== '/' && item.fpath.includes('/')) {
                for (const id of ids) {
                    const include = item.fpath.split('/').includes(id);
                    return !include;
                }
            }
            else {
                return !ids.includes(item.dataId);
            }
        });
    }
    isChanged() {
        return this.history.length > 0;
    }
    onAddData(dataChange) {
        this.history.push(dataChange);
    }
    onDeleteData(dataChange) {
        const index = this.history.findIndex(item => item.dataId === dataChange.dataId && item.changeType === DataChangeType.Add);
        if (index >= 0) {
            this.history.splice(index, 1);
        }
        else {
            this.history.push(dataChange);
        }
    }
}

/*
 * @Author: Witt
 * @Date: 2018-10-12 15:37:11
 * @Last Modified by: aalizzwell
 * @Last Modified time: 2019-09-03 19:10:44
 * @todo 待优化问题
 * 1、apiUrl是否应该在基类中，子类中的api如何传递给基类；
 */
class Repository {
    /**
     * 构造函数
     */
    constructor() {
        /**
         * 用户分页配置信息
         */
        this.paginationInfo = null;
    }
    init() {
        this.entityTypeInfo = new DataTypeInfo(this.entityType);
        this.entityCollection = new EntityCollection(this.entityType);
        this.dataChangeHistory = new DataChangeHistory();
    }
    /**
     * 实体主键
     */
    get primaryKey() {
        return this.entityCollection.primaryKey;
    }
    /**
     * 实体变更集合
     */
    get entityCollectionChange() {
        return this.entityCollection.collectionChanged;
    }
    /**
     * 重置状态
     */
    reset() {
        this.entityCollection.clear();
    }
    /**
     * 创建实体
     */
    buildEntity(data) {
        const entity = createEntity(this.entityType, data);
        return entity;
    }
    /**
     * 批量创建实体
     */
    buildEntities(listData) {
        const entities = createEntities(this.entityType, listData);
        return entities;
    }
    /**
     * 初始化分页配置
     * @param config 用户分页配置
     */
    setPaginationConfig(config) {
        this.paginationManager = new PaginationManager(this.entityType, config);
        const { pageSize = 0 } = this.paginationManager.getPaginationConfigByPath('/') || {};
        // tslint:disable-next-line: max-line-length
        this.entityCollection.paginationInfo = Object.assign({ pageSize }, this.entityCollection.paginationInfo, this.paginationManager.pagination);
        // 无需再单独设置一次pageSize，减少一次变更
        // this.entityCollection.pageSize = pageSize;
    }
    /**
     * 设置分页
     */
    setPaginationInfo(paginationInfo) {
        this.paginationInfo = Object.assign({}, this.paginationInfo, paginationInfo);
    }
}

/**
 * 空Repository实现
 */
class DefaultRepository extends Repository {
    constructor() {
        super();
        this.entityManager = new EntityManager(this.entityCollection);
    }
}

/**
 * 命令处理装饰器名称
 */
const COMMAND_HANDLER_META = 'CommandHandlerMeta';
/**
 * 命令处理装饰器工厂
 */
function CommandHandlerMeta(options) {
    const decoratorFactory = makeDecorator(COMMAND_HANDLER_META, (handler) => handler);
    return decoratorFactory(options);
}
/**
 * 命令处理扩展装饰器名称
 */
const COMMAND_HANDLER_EXTENDER_META = 'CommandHandlerExtenderMeta';
/**
 * 命令处理扩展装饰器工厂
 */
function CommandHandlerExtenderMeta(options) {
    const decoratorFactory = makeDecorator(COMMAND_HANDLER_EXTENDER_META, (extender) => extender);
    return decoratorFactory(options);
}

/**
 * 任务节点
 */
class TaskNode {
    /**
     * 构造函数
     */
    constructor(name, func) {
        this.name = name;
        this.func = func;
    }
    /**
     * 执行任务函数
     */
    execute(context) {
        const result = this.func(context);
        const result$ = isObservable(result) ? result : of(result);
        return result$;
    }
}

/**
 * session变量解析
 * @author Witt <jiwt@inspur.com>
 */
const VARIABLE_PARSERS = createInjectionToken('@farris/devkit VARIABLE_PARSERS');

class AppOptions {
}

/*
 * @Author: Witt
 * @Date: 2018-12-29 10:46:01
 * @Last Modified by: Witt
 * @Last Modified time: 2018-12-30 17:56:02
 */
/**
 * BindingData管理类
 */
class BindingDataManager {
    /**
     * 构造函数
     */
    constructor() {
        this.bindingDataMap = new Map();
    }
    /**
     * 获取BindingDataMap
     */
    getBindingDataMap() {
        return this.bindingDataMap;
    }
    /**
     * 根据name获取BindingData
     * @return 找不到时返回undefined
     */
    getBindingDataByName(name) {
        return this.bindingDataMap.get(name);
    }
    /**
     * 初始化全局的BindingData
     */
    regBindingData(name, bindingData) {
        this.bindingDataMap.set(name, bindingData);
    }
    /**
     * 是否Repository已经存在
     */
    ifBindingDataExits(name) {
        const bindingData = this.getBindingDataByName(name);
        return bindingData ? true : false;
    }
}

/*
 * @Author: Witt
 * @Date: 2018-12-29 10:46:01
 * @Last Modified by: Witt
 * @Last Modified time: 2018-12-30 18:06:11
 */
/**
 * Repository管理类
 */
class RepositoryManager {
    /**
     * 构造函数
     */
    constructor() {
        this.repositoryMap = new Map();
    }
    /**
     * 注册Repository
     */
    regRepository(name, repository) {
        this.repositoryMap.set(name, repository);
    }
    /**
     * 获取RepositoryMap
     * @internal
     */
    getRepositoryMap() {
        return this.repositoryMap;
    }
    /**
     * 获取Repository数组
     */
    getRepositories() {
        return Array.from(this.repositoryMap.values());
    }
    /**
     * 根据name获取Repository
     */
    getRepositoryByName(name) {
        return this.repositoryMap.get(name);
    }
    /**
     * 是否Repository已经存在
     */
    ifRepositoryExits(name) {
        const repository = this.getRepositoryByName(name);
        return repository ? true : false;
    }
}

/**
 * ViewModelContext管理类
 */
class ViewModelContextManager {
    /**
     * 构造函数
     */
    constructor() {
        this.contextMap = new Map();
        this.contextSet = new Set();
    }
    /**
     * 注册Context
     */
    regContext(viewModelContext) {
        const id = viewModelContext.id;
        if (this.contextMap.has(id) === true) {
            // throw Error(`id为${id}的ViewModelContext已经存在`);
            // 临时处理，方式报错。
            this.unregContext(viewModelContext);
        }
        this.contextMap.set(id, viewModelContext);
        this.contextSet.add(viewModelContext);
    }
    /**
     * 取消注册
     */
    unregContext(context) {
        const id = context.id;
        this.contextMap.delete(id);
        this.contextSet.delete(context);
    }
    /**
     * 获取ContextMap
     */
    getContextMap() {
        return this.contextMap;
    }
    /**
     * 获取全部Context
     */
    getContexts() {
        return Array.from(this.contextSet);
    }
    /**
     * 根据id获取Context
     */
    getContextById(id) {
        const targetContext = this.contextMap.get(id);
        return targetContext;
    }
    /**
     * 获取根Context
     */
    getRootContext() {
        const contexts = this.getContexts();
        const rootContext = contexts.find((context) => {
            return context.parent === null;
        });
        return rootContext;
    }
    /**
     * 获取传入视图模型id的root及root的下一代集合数组
     */
    getRootContextAndPosterityById(viewModelId) {
        const targetContext = this.getContextById(viewModelId);
        const contexts = this.getContexts();
        let contextsGroup = [];
        // 1.找到ROOT
        const RootId = this.getContextsGroupRoot(targetContext);
        // 2.可直接遍历拿到所有直系后代 (目前只有两层结构直接获取下一代)
        contexts.map((context) => {
            if (context.parent && context.parent.id === RootId) {
                contextsGroup.push(context);
            }
        });
        contextsGroup.push(this.getContextById(RootId));
        return contextsGroup;
    }
    getContextsGroupRoot(context) {
        if (context.parent) {
            return this.getContextsGroupRoot(context.parent);
        }
        else {
            return context.id;
        }
    }
}

class Context {
    constructor() {
        /**
         * 上下文变量
         */
        this.params = new Map();
    }
    /**
     * 获取变量
     */
    getParam(key) {
        return this.params.get(key);
    }
    /**
     * 设置变量
     */
    setParam(key, value) {
        this.params.set(key, value);
    }
}

class AppContext extends Context {
    /**
     * 构造函数
     */
    constructor(injector, eventBus, repositoryManager, bindingDataManager, viewModelContextManager) {
        super();
        this.injector = injector;
        this.eventBus = eventBus;
        this.repositoryManager = repositoryManager;
        this.bindingDataManager = bindingDataManager;
        this.viewModelContextManager = viewModelContextManager;
    }
    /**
     * 注册FrameContext
     */
    regViewModelContext(viewModelContext) {
        const repository = viewModelContext.repository;
        const repositoryName = repository.name;
        // Repository
        if (this.repositoryManager.ifRepositoryExits(repositoryName) === false) {
            this.repositoryManager.regRepository(repositoryName, repository);
        }
        // BindingData
        if (this.bindingDataManager.ifBindingDataExits(repositoryName) === false) {
            const bindingData = BindingDataFactory.createFromRepository(repository, '/');
            this.bindingDataManager.regBindingData(repositoryName, bindingData);
        }
        // 考虑路由再次进入的时候，AppContext没有被注销，但Component被再次构造的场景
        this.viewModelContextManager.regContext(viewModelContext);
    }
}

/**
 * 视图模型上下文
 */
class ViewModelContext {
    constructor() {
    }
    init(viewModel) {
        this.innerViewModel = viewModel;
        this.id = this.innerViewModel.id;
        this.appContext = viewModel.injector.get(AppContext);
        this.regToTree();
        this.regToAppContext();
    }
    regToTree() {
        const parentInjector = this.innerViewModel.injector.get(Injector, null, InjectFlags.SkipSelf);
        if (parentInjector) {
            this.parent = parentInjector.get(ViewModelContext, null);
            this.root = this.parent ? this.parent.root : this;
        }
        else {
            this.parent = null;
            this.root = this;
        }
    }
    regToAppContext() {
        this.appContext.regViewModelContext(this);
    }
    get viewModel() {
        return this.innerViewModel;
    }
    get injector() {
        return this.innerViewModel.injector;
    }
    get repository() {
        return this.innerViewModel.repository;
    }
    get bindingData() {
        return this.innerViewModel.bindingData;
    }
    get uiState() {
        return this.innerViewModel.uiState;
    }
    get stateMachine() {
        return this.innerViewModel.stateMachine;
    }
    get form() {
        return this.innerViewModel.form;
    }
    get commandBus() {
        return this.innerViewModel.commandBus;
    }
}

/**
 * UIState属性元数据名称
 */
const UISTATE_PROP_META = 'UIStatePropMeta';
const ɵ0$2 = (obj) => obj;
/**
 * UIState属性元数据装饰器工厂
 */
const UIStatePropMeta = makePropDecorator(UISTATE_PROP_META, ɵ0$2);

class UIStateMetadataUtil {
    /**
     * 获取NgUIState的属性元数据
     * @param
     * @returns 属性元数据对象
     * @example
     * 返回格式：
     * {
     *    '属性名称': <NgUIStateProperty>{ ...}
     * }
     */
    static getUIFields(target) {
        return MetadataUtil.getPropsMetadatasByName(target, UISTATE_PROP_META);
    }
}

/*
 * @Author: Witt
 * @Date: 2018-11-17 13:38:23
 * @Last Modified by: Witt
 * @Last Modified time: 2018-11-17 13:38:50
 * @todo：临时删除原有功能，待重构
 */
/**
 * UI状态
 */
class UIState {
    constructor() {
        this.changes = new Subject();
        this.innerData = Object.assign({});
        this._init();
    }
    _init() {
        const construct = this.constructor;
        const uiFields = UIStateMetadataUtil.getUIFields(construct);
        this.initializeUIField(uiFields);
    }
    initializeUIField(uiFieldMetadata) {
        Object.keys(uiFieldMetadata).forEach(propertyName => {
            const fieldMetadata = uiFieldMetadata[propertyName];
            const uiField = fieldMetadata.stateName || propertyName;
            if (delete this[propertyName]) {
                this.defineProperty(propertyName, uiField);
            }
        });
    }
    isExistProperty(propertyName) {
        if (this.innerData.hasOwnProperty(propertyName) || this.hasOwnProperty(propertyName)) {
            return true;
        }
        return false;
    }
    defineProperty(propertyName, field = null) {
        Object.defineProperty(this, propertyName, {
            get: function () {
                return field !== null ? this.innerData[field] : this.innerData[propertyName];
            },
            set: function (value) {
                // 值相同时不触发变更
                const oldValue = field !== null ? this.innerData[field] : this.innerData[propertyName];
                if (oldValue === value) {
                    return;
                }
                if (field !== null) {
                    this.innerData[field] = value;
                }
                else {
                    this.innerData[propertyName] = value;
                }
                this.changes.next({
                    field: propertyName,
                    value: value
                });
            }
        });
    }
    setPropertyValue(propertyName, value) {
        if (propertyName === '' || propertyName === undefined) {
            return;
        }
        if (!this.isExistProperty(propertyName)) {
            this.defineProperty(propertyName);
        }
        this[propertyName] = value;
    }
}

/**
 * --------------------------------------------------------------------------------
 * State相关
 * --------------------------------------------------------------------------------
 */
/**
 * 基本状态：表单的基本状态，通过State的运算确定RenderState的值，进而控制页面控件的状态。
 */
class State {
    /**
     * 构造函数
     * @param name 状态名称
     */
    constructor(name) {
        this.name = name;
    }
}
/**
 * 初始渲染状态
 */
const initialUIState = false;

/**
 * 状态元数据名称
 */
const STATE_PROP_META = 'StatePropMeta';
const ɵ0$3 = (obj) => obj;
/**
 * 页面状态元数据装饰器工厂
 */
const StatePropMeta = makePropDecorator(STATE_PROP_META, ɵ0$3);

/**
 * 组件状态元数据名称
 */
const RENDER_STATE_PROP_META = 'RenderStatePropMeta';
const ɵ0$4 = (obj) => obj;
/**
 * 组件状态元数据工厂
 */
const RenderStatePropMeta = makePropDecorator(RENDER_STATE_PROP_META, ɵ0$4);

/**
 * 动作方法元数据名称
 */
const ACTION_METHOD_META = 'ActionMethodMeta';
const ɵ0$5 = (action) => action;
/**
 * 迁移动作元数据装饰工厂
 */
const ActionMethodMeta = makePropDecorator(ACTION_METHOD_META, ɵ0$5);

/**
 * 状态机上下文
 */
class StateMachineContext {
    /**
     * 构造函数
     * @param stateMachine 状态机实例
     * @param initialState 初始状态
     */
    constructor(stateMachine, initialState) {
        this.stateMachine = stateMachine;
        this.state = initialState.name;
    }
    /**
     * 初始化
     */
    init(frameContext) {
        this.viewModelContext = frameContext;
        this.parser = this.viewModelContext.injector.get(VariableParseService);
        this.stateMachineWatcher = this.stateMachine.stateMachineWatcher;
    }
    /**
     * 状态迁移
     * @param stateName 下一状态的名称
     */
    transitTo(stateName) {
        const nextState = this.stateMachine.states[stateName];
        if (nextState) {
            this.state = nextState.name;
            this.stateMachine.render();
        }
    }
    /**
     * 获取expression对应的UIState值
     * @param expression UIState表达式
     */
    getUIState(expression) {
        if (!expression) {
            return;
        }
        const viewModelContext = this.stateMachineWatcher.getViewModelContext(expression);
        if (!viewModelContext) {
            return;
        }
        this.stateMachineWatcher.subscribeUIStateChange(viewModelContext, expression);
        if (this.parser) {
            const value = this.parser.parse(expression, viewModelContext);
            if (value === null) {
                return null;
            }
            if (typeof value === 'object' && Object.keys(value).length === 0) {
                return null;
            }
            return value;
        }
        else {
            throw new Error('未初始化变量解析器。');
        }
    }
    /**
     * 获取数据的值
     */
    getData(expression) {
        if (!expression) {
            return;
        }
        const viewModelContext = this.stateMachineWatcher.getViewModelContext(expression);
        if (!viewModelContext) {
            return;
        }
        this.stateMachineWatcher.subscribeEntityChange(viewModelContext, expression);
        if (this.parser) {
            const value = this.parser.parse(expression, viewModelContext);
            if (value === null) {
                return null;
            }
            if (typeof value === 'object' && Object.keys(value).length === 0) {
                return null;
            }
            return value;
        }
        else {
            throw new Error('未初始化变量解析器。');
        }
    }
}

/**
 * 状态机事件，监听uistate的变化和entity的变化
 */
class StateMachineWatcher {
    constructor(stateMachine) {
        this.stateMachine = stateMachine;
        /**
         * 所有UIStatePath数组
         */
        this.uiStatePathList = [];
        /**
         * 所有DataStatePath数组
         */
        this.dataStatePathList = [];
        this.viewModelContextAndUIStatePathsMap = new Map();
        this.viewModelContextAndDataStatePathsMap = new Map();
    }
    /**
     * 初始化
     * @param viewModelContext 当前视图上下文
     */
    init(viewModelContext) {
        this.viewModelContext = viewModelContext;
    }
    /**
     * 返回表达式中ViewModelId对应的ViewModelContext
     */
    getViewModelContext(expression) {
        const viewModelId = this.extractPaths(expression).split('/')[1];
        return this.viewModelContext.appContext.viewModelContextManager.getContextById(viewModelId);
    }
    /**
     * 监听UIState变更
     * @param viewModelContext ViewModel上下文
     * @param expression UIState表达式
     */
    subscribeUIStateChange(viewModelContext, expression) {
        const uiStatePath = this.getStatePath(expression);
        if (this.viewModelContextAndUIStatePathsMap.has(viewModelContext) === false) {
            this.viewModelContextAndUIStatePathsMap.set(viewModelContext, this.uiStatePathList);
            viewModelContext.uiState.changes.subscribe((uiStateChange) => {
                const uiStatePathList = this.viewModelContextAndUIStatePathsMap.get(viewModelContext);
                if (uiStateChange.field && uiStatePathList.indexOf(uiStateChange.field) > -1) {
                    this.stateMachine.render();
                }
            });
        }
        if (this.viewModelContextAndUIStatePathsMap.get(viewModelContext).indexOf(uiStatePath) === -1) {
            this.uiStatePathList.push(uiStatePath);
        }
    }
    /**
     * 监听实体变更
     */
    subscribeEntityChange(viewModelContext, expression) {
        if (this.viewModelContextAndDataStatePathsMap.has(viewModelContext) === false) {
            this.viewModelContextAndDataStatePathsMap.set(viewModelContext, this.dataStatePathList);
            viewModelContext.bindingData.changes.subscribe((change) => {
                if (change.type === 'Load' || change.type === 'SelectionChanged') {
                    this.stateMachine.render();
                }
                const dataPathList = this.viewModelContextAndDataStatePathsMap.get(viewModelContext);
                if (change.path.join() && this.isAccordingPath(dataPathList, change.path.join('/'))) {
                    this.stateMachine.render();
                }
            });
        }
        if (this.viewModelContextAndDataStatePathsMap.get(viewModelContext).indexOf(expression) === -1) {
            this.dataStatePathList.push(expression);
        }
    }
    /**
     * 根据表达式获取对应的StatePath（移除了ViewModelId之外的部分）
     * @param expression 变量表达式
     */
    getStatePath(expression) {
        return this.extractPaths(expression).split('/')[2];
    }
    /**
     * 判断是否监听范围内的变更路径
     */
    isAccordingPath(dataStatePaths, dataStatePath) {
        const targetPath = dataStatePaths.find((item) => {
            return item.indexOf(dataStatePath) > -1;
        });
        return targetPath === undefined ? false : true;
    }
    /**
     * 暂时把这个方法放了这个地方，等季老师共用方法调整后，直接引用他的方法，该方法可删除
     * @param expression 变量表达式
     */
    extractPaths(expression) {
        let path;
        const UI_STATE_PATTERN_G = /\{UISTATE~(\S+?)\}/g;
        const DATA_PATTERN_G = /\{DATA~(\S+?)\}/g;
        const uiStateVariables = expression.match(UI_STATE_PATTERN_G);
        const dataVariables = expression.match(DATA_PATTERN_G);
        if (uiStateVariables !== null) {
            const UI_STATE_PATTERN = /\{UISTATE~(\S+?)\}/;
            uiStateVariables.forEach((uiStateVariable) => {
                const pathMatches = uiStateVariable.match(UI_STATE_PATTERN);
                if (pathMatches != null && pathMatches.length === 2) {
                    path = pathMatches[1];
                }
            });
        }
        if (dataVariables !== null) {
            const DATA_PATTERN = /\{DATA~(\S+?)\}/;
            dataVariables.forEach((dataVariable) => {
                const pathMatches = dataVariable.match(DATA_PATTERN);
                if (pathMatches != null && pathMatches.length === 2) {
                    path = pathMatches[1];
                }
            });
        }
        return path;
    }
}

/**
 * 状态机
 */
class StateMachine {
    /**
     * 构造函数
     */
    constructor() {
        this.renderStates = {};
        this.handlePropMetadatas();
        this.stateChange = new BehaviorSubject(false);
        this.context = new StateMachineContext(this, this.initialState);
        this.stateMachineWatcher = new StateMachineWatcher(this);
    }
    /**
     * 初始化状态机
     * @param viewModelContext ViewModel上下文
     * @summary
     * 状态机变更，为了在绑定数据之后执行状态机的操作，把render方法延后执行。
     */
    init(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.context.init(this.viewModelContext);
        this.stateMachineWatcher.init(this.viewModelContext);
        this.render();
    }
    /**
     * 批量处理属性元数据
     */
    handlePropMetadatas() {
        const propsMetadatas = MetadataUtil.getPropsMetadatas(this.constructor);
        // 遍历所有属性装饰器，并调用相应的build方法
        if (propsMetadatas) {
            Object.keys(propsMetadatas).forEach((propName) => {
                const propMetadatas = propsMetadatas[propName];
                propMetadatas.forEach(propMetadata => {
                    this.handlePropMetadata(propName, propMetadata);
                });
            });
        }
        if (!this.initialState) {
            throw new Error('请在StatePropMeta注解中指定状态机的初始状态。');
        }
    }
    /**
     * 处理属性元数据
     */
    handlePropMetadata(propName, propMetadata) {
        const ngMetadataName = propMetadata.ngMetadataName;
        switch (ngMetadataName) {
            case STATE_PROP_META:
                this.buildState(propName, propMetadata);
                break;
            case RENDER_STATE_PROP_META:
                this.buildRenderState(propName, propMetadata);
                break;
            case ACTION_METHOD_META:
                this.buildAction(propName, propMetadata);
                break;
            default:
                break;
        }
    }
    /**
     * 包装State
     * @param stateName 状态名称
     * @param ngState   状态对象
     */
    buildState(stateName, ngState) {
        this.states = this.states || {};
        this[stateName] = new State(stateName);
        this.states[stateName] = this[stateName];
        if (ngState.initialState) {
            this.initialState = this[stateName];
        }
    }
    /**
     * 包装RenderState
     * @param renderStateName 渲染状态名称
     * @param ngRenderState   渲染状态元数据
     */
    buildRenderState(renderStateName, ngRenderState) {
        this.renderStates = this.renderStates || {};
        this[renderStateName] = initialUIState;
        this.renderStates[renderStateName] = this[renderStateName];
        // 将renderState上指定的render加入到renders中
        this.renders = this.renders || {};
        this.renders[renderStateName] = ngRenderState.render;
    }
    /**
     * 包装Action
     * @param actionName 动作名称
     * @param ngAction 动作元数据
     */
    buildAction(actionName, ngAction) {
        this[actionName] = () => {
            const nextStateName = ngAction.transitTo;
            const nextState = this.states[nextStateName];
            this.context.transitTo(nextState.name);
            this.render();
        };
    }
    /**
     * 重新计算所有渲染状态的值
     * @sumamry
     * 当 state切换的时候，调用遍历所有的render方法，更改renderState
     */
    render() {
        for (const renderStateName in this.renderStates) {
            if (this.renderStates.hasOwnProperty(renderStateName) === false) {
                continue;
            }
            // 执行RenderState的render方法，更新renderState
            const stateRender = this.renders[renderStateName];
            if (!stateRender) {
                continue;
            }
            this.renderStates[renderStateName] = stateRender(this.context);
            this[renderStateName] = this.renderStates[renderStateName];
        }
        this.stateChange.next(this.context.state);
    }
}

var BindingType;
(function (BindingType) {
    /**
     * 实体状态
     */
    BindingType["EntityState"] = "EntityState";
    /**
     * UI状态
     */
    BindingType["UIState"] = "UIState";
})(BindingType || (BindingType = {}));

/**
 * 日期字符串转换器
 */
class DateStringValueConverter {
    convertFrom(dateObj) {
        return DateUtil.formatISO(dateObj);
    }
    convertTo(dateString) {
        return DateUtil.parse(dateString);
    }
}
/**
 * 数组字符串转换器
 */
class ArrayStringValueConverter {
    convertFrom(arr) {
        return arr.join(',');
    }
    convertTo(arrString) {
        return arrString.split(',');
    }
}

/**
 * Entity值访问器
 */
class EntityBindingValueAccessor {
    constructor(bindingData, bindingPath, valueConverter) {
        this.bindingData = bindingData;
        this.bindingPathSegments = this.getBindingPathSegments(bindingPath);
        this.valueConverter = valueConverter;
    }
    getValue() {
        const stateValue = this.bindingData.getValue(this.bindingPathSegments);
        const controlValue = this.valueConverter ? this.valueConverter.convertTo(stateValue) : stateValue;
        return controlValue;
    }
    setValue(controlValue) {
        const oldStateValue = this.bindingData.getValue(this.bindingPathSegments);
        const stateValue = this.valueConverter ? this.valueConverter.convertFrom(controlValue) : controlValue;
        if (this.isDateConverter(this.valueConverter) === true) {
            if (DateUtil.isEqual(oldStateValue, stateValue) === true) {
                return;
            }
        }
        this.bindingData.setValue(this.bindingPathSegments, stateValue, true, true);
    }
    getBindingPathSegments(bindingPath) {
        const parentPathSegments = BindingPathConverter.toBindingPathArray(this.bindingData.bindingPath);
        bindingPath = bindingPath.replace(/\./g, '\/');
        const bindingPathSegments = BindingPathConverter.toBindingPathArray(bindingPath);
        return parentPathSegments.concat(bindingPathSegments);
    }
    /**
     * 是否是DateConverter
     */
    isDateConverter(converter) {
        let isDateConverter = false;
        if (converter && converter.hasOwnProperty('format') === true) {
            isDateConverter = true;
        }
        return isDateConverter;
    }
}
/**
 * UIState值访问器
 */
class UIStateBindingValueAccessor {
    constructor(uiState, bindingPath, valueConverter) {
        this.uiState = uiState;
        this.bindingPathSegments = this.getUiStateBindingPath(bindingPath);
    }
    getValue() {
        let stateValue;
        let obj = this.uiState;
        this.bindingPathSegments.forEach(item => {
            stateValue = obj[item];
            obj = stateValue;
        });
        return stateValue;
    }
    setValue(controlValue) {
        const length = this.bindingPathSegments.length;
        if (length === 1) {
            this.uiState.setPropertyValue(this.bindingPathSegments, controlValue);
        }
        else {
            let obj;
            for (let i = length - 1; i > 0; i--) {
                obj = { [this.bindingPathSegments[i]]: controlValue };
                controlValue = obj;
            }
            this.uiState.setPropertyValue(this.bindingPathSegments[0], obj);
        }
    }
    // UISTATE获取路径
    getUiStateBindingPath(bindingPath) {
        const index = bindingPath.search('/');
        if (index !== -1) {
            return bindingPath.split('/');
        }
        else {
            return [bindingPath];
        }
    }
}
/**
 * 绑定值访问器工厂
 */
class BindingValueAccessorFactory {
    static create(bindingType, bindingBindingPath, bindingValueConverter, viewModelContext) {
        switch (bindingType) {
            case BindingType.EntityState:
                const bindingData = viewModelContext.bindingData;
                return new EntityBindingValueAccessor(bindingData, bindingBindingPath, bindingValueConverter);
            case BindingType.UIState:
                const uiState = viewModelContext.uiState;
                return new UIStateBindingValueAccessor(uiState, bindingBindingPath, bindingValueConverter);
            default:
                throw new Error('Not Supported');
        }
    }
}

/**
 * FormControl元数据名称
 */
const FORM_CONTROL_PROP_META = 'FormControlPropMeta';
const ɵ0$6 = (obj) => obj;
/**
 * FormControl装饰器工厂
 */
const FormControlPropMeta = makePropDecorator(FORM_CONTROL_PROP_META, ɵ0$6);

/**
 * 验证器工厂
 */
class ValidatorFactory {
    /**
     * 创建适配器
     */
    static create(validRules) {
        let validatorFn = [];
        if (Array.isArray(validRules) && validRules.length > 1) {
            validRules.forEach((validRule) => {
                validatorFn.push(this.initValidRuleFn(validRule));
            });
        }
        else if (Array.isArray(validRules) && validRules.length === 1) {
            validatorFn.push(this.initValidRuleFn(validRules[0]));
        }
        else {
            validatorFn.push(this.initValidRuleFn(validRules));
        }
        return validatorFn;
    }
    static initValidRuleFn(validRule) {
        const { type, constraints, message } = validRule;
        switch (type) {
            case 'required':
                return (v) => {
                    if (constraints[0] === true) {
                        if (null === v || undefined === v || '' === v) {
                            return { passing: false, message: message || '必填' };
                        }
                        else {
                            return { passing: true, message: '' };
                        }
                    }
                };
            case 'NumberMaxValue':
                return (v) => {
                    if (typeof v !== 'number') {
                        return;
                    }
                    if (constraints[0] || 0 == constraints[0]) {
                        if (v <= parseFloat(constraints[0])) {
                            return { passing: true, message: '' };
                        }
                        else {
                            return { passing: false, message: message || `输入值不能大于${constraints[0]}` };
                        }
                    }
                };
            case 'NumberMinValue':
                return (v) => {
                    if (typeof v !== 'number') {
                        return;
                    }
                    if (constraints[0] || 0 == constraints[0]) {
                        if (v >= parseFloat(constraints[0])) {
                            return { passing: true, message: '' };
                        }
                        else {
                            return { passing: false, message: message || `输入值不能小于${constraints[0]}` };
                        }
                    }
                };
            case 'DateMaxValue':
                return (v) => {
                    if (constraints[0]) {
                        if (DateUtil.isBefore(v, constraints[0]) || DateUtil.isSame(v, constraints[0])) {
                            return { passing: true, message: '' };
                        }
                        else {
                            return { passing: false, message: message || `输入日期不能大于${constraints[0]}` };
                        }
                    }
                };
            case 'DateMinValue':
                return (v) => {
                    if (constraints[0]) {
                        if (DateUtil.isAfter(v, constraints[0]) || DateUtil.isSame(v, constraints[0])) {
                            return { passing: true, message: '' };
                        }
                        else {
                            return { passing: false, message: message || `输入日期不能小于${constraints[0]}` };
                        }
                    }
                };
            case 'StringMaxLength':
                return (v) => {
                    if (constraints[0]) {
                        if (v.length <= constraints[0]) {
                            return { passing: true, message: '' };
                        }
                        else {
                            return { passing: false, message: message || `输入值长度不能大于${constraints[0]}` };
                        }
                    }
                };
            case 'StringMinLength':
                return (v) => {
                    if (constraints[0]) {
                        if (v.length >= constraints[0]) {
                            return { passing: true, message: '' };
                        }
                        else {
                            return { passing: false, message: message || `输入值长度不能小于${constraints[0]}` };
                        }
                    }
                };
            case 'regex':
                return (v) => {
                    let constraintsTemp = [];
                    if (typeof constraints[0] === 'string') {
                        constraintsTemp = constraints[0].split(',');
                    }
                    for (let i = 0; i < constraintsTemp.length; i++) {
                        if (constraintsTemp[i] === '') {
                            return;
                        }
                        const re = new RegExp(constraintsTemp[i]);
                        if (re.test(v)) {
                            return { passing: false, message: message || `存在不可输入项${constraints[0]}` };
                        }
                        else {
                            return { passing: true, message: '' };
                        }
                    }
                };
            case 'customFunction':
                return (v) => {
                    if (typeof constraints[0] === 'function') {
                        let message = constraints[0](v);
                        if (!message) {
                            return { passing: true, message: '' };
                        }
                        else {
                            return { passing: false, message };
                        }
                    }
                };
            default:
                return () => {
                    return { passing: true, message: '' };
                };
        }
    }
    /**
     * 遍历生成的校验方法对当前值进行校验，当发现错误就返回校验结果
     * 遍历完成没有错误则返回校验通过结果
     * @param validatorFn 校验方法
     * @param value 当前值
     */
    static executeValidator(validatorFn, value) {
        for (let i = 0; i < validatorFn.length; i++) {
            let validationResult = validatorFn[i](value);
            if (validationResult['passing'] === false) {
                return validationResult;
            }
        }
        return { passing: true, message: '' };
    }
}

/**
 * FormControl定义
 */
class FormControl {
    constructor(config, viewModelContext) {
        this.valueAccessor = BindingValueAccessorFactory.create(config.bindingType, config.bindingPath, config.valueConverter, viewModelContext);
        this.validatorFn = config.validRules && ValidatorFactory.create(config.validRules);
    }
    get value() {
        return this.valueAccessor.getValue();
    }
    set value(val) {
        this.valueAccessor.setValue(val);
    }
}

/**
 * Form抽象类
 */
class Form {
    /**
     * 构造函数
     */
    constructor(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.formControlConfigs = [];
        this.validateformControls = [];
        this.validateformControlPathMap = new Map;
        this.changes = new Subject();
    }
    /**
     * 初始化
     */
    init() {
        this.collectMetadatas();
        this.createFormControls();
    }
    /**
     * 全部校验
     *  formControlConfigs 上所有的formControl的存在方法调用一遍 将错误信息集中返回
     */
    validateFields() {
        let validationResult = [];
        if (this.validateformControls.length === 0) {
            return validationResult;
        }
        this.validateformControls.forEach((formControl) => {
            this[formControl]['validationResult'] = ValidatorFactory.executeValidator(this[formControl]['validatorFn'], this[formControl]['value']);
            !this[formControl]['validationResult'].passing && validationResult.push(this[formControl]);
        });
        this.changes.next({ type: 'validateFieldsFinished' });
        return validationResult;
    }
    /**
     * 获取某一个得校验错误信息
     * @param name 属性名称
     */
    getFieldError(name) {
        if (this.validateformControls.length === 0) {
            return {};
        }
        const index = this.validateformControls.findIndex((item) => {
            return item === name;
        });
        if (index === -1) {
            return {};
        }
        else {
            const result = ValidatorFactory.executeValidator(this[name]['validatorFn'], this[name]['value']);
            this[name]['validationResult'] = result;
            this.changes.next({ type: 'validateFieldsFinished', value: name });
            return result;
        }
    }
    /**
   * 根据form元数据中的path获取某一个得校验错误信息
   * @param path 属性名称数组
   */
    getFieldErrorByPath(path) {
        if (this.validateformControls.length === 0) {
            return {};
        }
        let pathName = path[0];
        if (path && path.length >= 2) {
            pathName = path.join('.');
        }
        const index = this.validateformControlPathMap.has(pathName);
        if (!index) {
            return {};
        }
        else {
            const result = ValidatorFactory.executeValidator(this[this.validateformControlPathMap.get(pathName)]['validatorFn'], this[this.validateformControlPathMap.get(pathName)]['value']);
            this[this.validateformControlPathMap.get(pathName)]['validationResult'] = result;
            this.changes.next({ type: 'validateFieldsFinished', value: this.validateformControlPathMap.get(pathName) });
            return result;
        }
    }
    /**
     * 清除一组字段验证状态
     * @param fields 字段的数组
     */
    resetFieldsValidate(fields) {
        if (this.validateformControls.length === 0) {
            return true;
        }
        else {
            if (fields && fields.length > 0) {
                const sa = new Set(this.validateformControls);
                const sb = new Set(fields);
                // 交集
                const intersect = this.validateformControls.filter(x => sb.has(x));
                // 遍历清空所有校验结果数据
                intersect.forEach(item => {
                    this[item]['validationResult'] = {};
                });
            }
            else {
                // 没传数据全部清除
                this.validateformControls.forEach(item => {
                    this[item]['validationResult'] = {};
                });
            }
            this.changes.next({ type: 'validateFieldsFinished' });
        }
    }
    /**
     * 创建FormControls
     */
    createFormControls() {
        this.formControlConfigs.forEach((formControlConfig) => {
            const name = formControlConfig.name;
            const formControl = new FormControl(formControlConfig, this.viewModelContext);
            this[name] = formControl;
        });
    }
    /**
     * 收集元数据
     */
    collectMetadatas() {
        const formControlMetadatas = MetadataUtil.getPropsMetadatasByName(this.constructor, FORM_CONTROL_PROP_META);
        Object.keys(formControlMetadatas).forEach((name) => {
            const formControlMetadata = formControlMetadatas[name];
            if (formControlMetadata.validRules) {
                this.validateformControls.push(name);
                this.validateformControlPathMap.set(formControlMetadata.bindingPath, name);
            }
            const formControlConfig = {
                name: name,
                bindingType: formControlMetadata.bindingType,
                bindingPath: formControlMetadata.bindingPath,
                valueConverter: formControlMetadata.valueConverter,
                valueChanging: formControlMetadata.valueChanging,
                valueChanged: formControlMetadata.valueChanged,
                validRules: formControlMetadata.validRules
            };
            this.formControlConfigs.push(formControlConfig);
        });
    }
    getEntityValueChangingListeners() {
        const listeners = {};
        this.formControlConfigs.forEach((formControl) => {
            if (formControl.valueChanging) {
                listeners[formControl.bindingPath] = formControl.valueChanging;
            }
        });
        return listeners;
    }
    getEntityValueChangedListeners() {
        const listeners = {};
        this.formControlConfigs.forEach((formControl) => {
            if (formControl.valueChanged) {
                listeners[formControl.bindingPath] = formControl.valueChanged;
            }
        });
        return listeners;
    }
}

/**
 * 命令装饰器名称
 */
const COMMAND_METHOD_META = 'CommandMethodMeta';
const ɵ0$7 = (obj) => obj;
/**
 * 命令装饰器工厂
 */
const CommandMethodMeta = makePropDecorator(COMMAND_METHOD_META, ɵ0$7);

class ViewModel {
    /**
     * 构造函数
     */
    constructor(injector, id) {
        this.injector = injector;
        this.id = id;
    }
    /**
     * 初始化
     */
    init() {
        this.initRepository();
        this.initContext();
        this.initBindingData();
        this.initUIState();
        this.intiStateMachine();
        this.initForm();
        this.initCommandBus();
        this.registerWithParent();
        this.initListeners();
        this.closeOldBeSession();
    }
    initRepository() {
        this.repository = this.injector.get(Repository);
    }
    initContext() {
        this.context = this.injector.get(ViewModelContext);
        this.context.init(this);
    }
    initBindingData() {
        this.bindingData = this.context.injector.get(BindingData);
        this.entityValueChangingListeners = new Map();
        this.entityValueChangedListeners = new Map();
        if (this.bindingData) {
            this.bindingData.setValueChangeInvokerFactory((paths) => {
                return (preValue, value, entityChanged, primaryValue) => {
                    const plainPath = '/' + paths.join('/');
                    let command;
                    if (entityChanged === false) {
                        command = this.entityValueChangingListeners[plainPath];
                    }
                    else {
                        command = this.entityValueChangedListeners[plainPath];
                    }
                    if (!!command) {
                        const change = {
                            paths: paths,
                            preValue: preValue,
                            value: value,
                            changed: entityChanged
                        };
                        const commands = command.split(';').filter(p => p);
                        let valueChangeSuccess = true;
                        return from(commands).pipe(concatMap(item => {
                            if (!valueChangeSuccess) {
                                return EMPTY$1;
                            }
                            return this[item](change).pipe(tap((result) => {
                                valueChangeSuccess = result;
                            }));
                        }), every((result) => result));
                    }
                    else {
                        return of(true);
                    }
                };
            });
        }
        const repositoryName = this.repository.name;
        const bindingDataManager = this.context.appContext.bindingDataManager;
        const repositoryBindingData = bindingDataManager.getBindingDataByName(repositoryName);
        this.bindingData.initByBindingList(repositoryBindingData.list, this.context);
    }
    initUIState() {
        this.uiState = this.injector.get(UIState);
    }
    intiStateMachine() {
        this.stateMachine = this.injector.get(StateMachine, null);
        if (!this.stateMachine) {
            return;
        }
        this.stateMachine.init(this.context);
    }
    initForm() {
        this.form = this.injector.get(Form, null);
        this.form.init();
    }
    initCommandBus() {
        this.commandBus = this.injector.get(CommandBus);
        this.extendCommandMethods();
    }
    extendCommandMethods() {
        this.ngCommands = MetadataUtil.getPropsMetadatasByName(this.constructor, COMMAND_METHOD_META);
        this.keybindingMap = new Map();
        Object.keys(this.ngCommands).forEach((propName) => {
            const ngCommand = this.ngCommands[propName];
            Object.defineProperty(this, propName, {
                value: (eventParams) => {
                    const command = {
                        name: ngCommand.name,
                        params: ngCommand.params,
                        paramDescriptions: ngCommand.paramDescriptions,
                        eventParam: eventParams || null
                    };
                    return this.commandBus.dispatch(command);
                }
            });
            if (ngCommand.keyBinding) {
                this.keybindingMap.set(propName, ngCommand.keyBinding);
            }
        });
    }
    registerWithParent() {
        const parentContext = this.context.parent;
        if (!parentContext || !parentContext.viewModel || !parentContext.viewModel['childViewModels']) {
            return;
        }
        const parentViewModel = parentContext.viewModel;
        const className = this.constructor.name;
        const propName = parentViewModel['childViewModels'][className];
        parentViewModel[propName] = this;
    }
    /**
     * 关闭老的BeSession
     */
    closeOldBeSession() {
        const allViewModelContexts = this.context.appContext.viewModelContextManager.getContexts();
        if (allViewModelContexts.length === 1 && allViewModelContexts[0] === this.context) {
            this.context.repository.reset();
        }
    }
    /**
   * 从Form获取监听器
   */
    initListeners() {
        const extractPath = (bindingBasePath, bindingPath) => {
            return '/' + bindingBasePath.split('/').concat(bindingPath.split('.')).filter((item) => item.length > 0).join('/');
        };
        if (this.form) {
            const valueChangingListeners = this.form.getEntityValueChangingListeners();
            Object.keys(valueChangingListeners).forEach((bindingPath) => {
                const plainPath = extractPath(this.bindingPath, bindingPath);
                this.entityValueChangingListeners[plainPath] = valueChangingListeners[bindingPath];
            });
            const valueChangedListeners = this.form.getEntityValueChangedListeners();
            Object.keys(valueChangedListeners).forEach((bindingPath) => {
                const plainPath = extractPath(this.bindingPath, bindingPath);
                this.entityValueChangedListeners[plainPath] = valueChangedListeners[bindingPath];
            });
        }
    }
}

class ViewModelOptions {
}

class AppEventBus {
    /**
     * 构造函数
     */
    constructor() {
        this.eventBus = new Subject();
        this.subscriptionsMap = new Map();
    }
    triggerEvent(event) {
        this.eventBus.next(event);
    }
    subscribe(componentId, func, funcError) {
        if (this.subscriptionsMap.has(componentId) === false) {
            const subscription = this.eventBus.subscribe((value) => func(value), (value) => funcError(value));
            this.subscriptionsMap.set(componentId, subscription);
        }
    }
    unsubscribe(componentId) {
        if (this.subscriptionsMap.has(componentId) === true) {
            this.subscriptionsMap.get(componentId).unsubscribe();
            this.subscriptionsMap.delete(componentId);
        }
    }
}

const APP_BASE_PROVIDERS = [
    { provide: AppEventBus, useClass: AppEventBus, deps: [] },
    { provide: BindingDataManager, useClass: BindingDataManager, deps: [] },
    { provide: RepositoryManager, useClass: RepositoryManager, deps: [] },
    { provide: ViewModelContextManager, useClass: ViewModelContextManager, deps: [] },
    {
        provide: AppContext, useClass: AppContext,
        deps: [Injector, AppEventBus, RepositoryManager, BindingDataManager, ViewModelContextManager]
    }
];

class App {
    /**
     * 构造函数
     */
    constructor(options) {
        options.providers = options.providers || [];
        const appProviders = [
            ...APP_BASE_PROVIDERS,
            ...APP_VARIABLE_PROVIDERS,
            ...HTTP_PROVIDERS,
            ...options.providers
        ];
        const appInjector = createInjector(appProviders);
        this.context = appInjector.get(AppContext);
    }
    /**
     * 启用ViewModel
     */
    createViewModel(options) {
        const providers = options.providers || [];
        const parent = options.parent || null;
        const mergedProviders = [
            { provide: ViewModelContext, useClass: ViewModelContext, deps: [] },
            ...VIEW_MODEL_COMMAND_PROVIDERS,
            ...providers
        ];
        const parentInjector = parent ? parent.injector : this.context.injector;
        const injector = createInjector(mergedProviders, parentInjector);
        const viewModel = injector.get(ViewModel);
        viewModel.init();
        return viewModel;
    }
}

/*
 * StateMachine变量解析
 * @Author: Witt
 * @Date: 2018-12-04 17:09:42
 * @Last Modified by: Witt
 * @Last Modified time: 2019-10-30 11:07:10
 */
/**
 * 解析辅助工具类
 */
class ParseUtil {
    /**
     * 获取应用上下文
     */
    static getAppContext(context) {
        if (context instanceof CommandContext) {
            return context.viewModelContext.appContext;
        }
        else if (context instanceof ViewModelContext) {
            return context.appContext;
        }
        else if (context instanceof AppContext) {
            return context;
        }
        else {
            throw new Error('上下文中找不到AppContext，请检查！');
        }
    }
    /**
     * 获取当前Frame的Context
     */
    static getFrameContext(context) {
        if (context instanceof CommandContext) {
            return context.viewModelContext;
        }
        else if (context instanceof ViewModelContext) {
            return context;
        }
        else {
            throw new Error('上下文中找不到FrameContext，请检查！');
        }
    }
    /**
     * 获取根Frame的Context
     */
    static getRootFrameContext(context) {
        const frameContext = this.getFrameContext(context);
        return frameContext.root;
    }
    /**
     * 根据frameId获取FrameContext
     */
    static getFrameContextById(context, frameId) {
        const appContext = this.getAppContext(context);
        return appContext.viewModelContextManager.getContextById(frameId);
    }
}

/**
 * 数据变量解析
 */
class DataVariableParser {
    /**
     * 解析变量
     * @param expression 表达式
     * @param context 上下文
     */
    parse(expression, context) {
        const appContext = ParseUtil.getAppContext(context);
        const paths = this.extractPaths(expression);
        // 1、单个的表达式：直接求值
        if (paths.length === 1 && expression === `{DATA~${paths[0]}}`) {
            return this.getValue(paths[0], appContext);
        }
        // 2、其他情况：字符串替换
        paths.forEach((path) => {
            const searchValue = `{DATA~${path}}`;
            const replaceValue = this.getValue(path, appContext);
            expression = expression.replace(searchValue, replaceValue);
        });
        return expression;
    }
    /**
     * 提取路径
     */
    extractPaths(expression) {
        const paths = [];
        // 查找所有的uiState变量字符串
        const DATA_PATTERN_G = /\{DATA~(\S+?)\}/g;
        const dataVariables = expression.match(DATA_PATTERN_G);
        if (dataVariables === null) {
            return [];
        }
        // 提取后边的路径
        const DATA_PATTERN = /\{DATA~(\S+?)\}/;
        dataVariables.forEach(dataVariable => {
            const pathMatches = dataVariable.match(DATA_PATTERN);
            if (pathMatches != null && pathMatches.length === 2) {
                paths.push(pathMatches[1]);
            }
        });
        return paths;
    }
    /**
     * 获取值
     * @param path 路径：/
     */
    getValue(path, appContext) {
        const parts = path.split('/').filter((part) => {
            return part !== '';
        });
        const frameContext = appContext.viewModelContextManager.getContextById(parts[0]);
        if (!frameContext) {
            throw new Error(`${path}不正确，请检查！`);
        }
        const bindingData = frameContext.bindingData;
        if (!bindingData) {
            throw new Error(`${path}不正确，请检查！`);
        }
        return bindingData.getValue(parts.slice(1));
    }
}

/**
 * session变量解析
 * @author Witt <jiwt@inspur.com>
 */
/**
 * 数据变量解析
 */
class UIStateVariableParser {
    /**
     * 解析变量
     * @param expression 形如：/frameId/stateName
     * @param context 上下文
     */
    parse(expression, context) {
        const appContext = ParseUtil.getAppContext(context);
        const paths = this.extractPaths(expression);
        // 1、单个的表达式：直接求值
        if (paths.length === 1 && expression === `{UISTATE~${paths[0]}}`) {
            return this.getUIState(paths[0], appContext);
        }
        // 2、其他情况：字符串替换
        paths.forEach(path => {
            const searchValue = `{UISTATE~${path}}`;
            const replaceValue = this.getUIState(path, appContext);
            expression = expression.replace(searchValue, replaceValue);
        });
        return expression;
    }
    /**
     * 提取路径
     * 变量格式：{}
     */
    extractPaths(expression) {
        const paths = [];
        // 查找所有的uiState变量字符串
        const UI_STATE_PATTERN_G = /\{UISTATE~(\S+?)\}/g;
        const uiStateVariables = expression.match(UI_STATE_PATTERN_G);
        if (uiStateVariables === null) {
            return [];
        }
        // 提取后边的路径
        const UI_STATE_PATTERN = /\{UISTATE~(\S+?)\}/;
        uiStateVariables.forEach((uiStateVariable) => {
            const pathMatches = uiStateVariable.match(UI_STATE_PATTERN);
            if (pathMatches != null && pathMatches.length === 2) {
                paths.push(pathMatches[1]);
            }
        });
        return paths;
    }
    /**
     * 获取UIState
     */
    getUIState(path, appContext) {
        const parts = path.split('/').filter((part) => {
            return part !== '';
        });
        const [frameId, stateName] = parts;
        const frameContext = appContext.viewModelContextManager.getContextById(frameId);
        let state = frameContext.uiState[stateName];
        if (state && state.constructor.toString().startsWith('function Date()')) {
            return this.formatDate(state);
        }
        for (let i = 2; i < parts.length; i++) {
            state = state[parts[i]];
            // 复杂对象一层层查找下去，如果某一层不存在，结果可以是undefined，但是要直接返回undefined避免报错。
            if (!state) {
                return state;
            }
        }
        return state;
    }
    /**
     * @todo：待删除
     */
    formatDate(value) {
        if (!value) {
            return '';
        }
        // 年
        const year = value.getFullYear();
        // 月
        let month = (value.getMonth() + 1).toString();
        month = month.length === 1 ? ('0' + month) : month;
        // 日
        let day = value.getDate().toString();
        day = day.length === 1 ? ('0' + day) : day;
        return `${year}-${month}-${day}`;
    }
}

/**
 * 状态机变量解析
 * @summary
 *
 * 解析策略：
 * 1、不带frameId，从顶层StateMachine中解析
 * {STATEMACHINE~/states/key}
 * {STATEMACHINE~/renderStates/key}
 *
 * 2、带frameId，从frameId对应的FrameContext的StateMachine中解析
 * {STATEMACHINE~/frameId/states/key}
 * {STATEMACHINE~/frameId/renderStates/key}
 *
 * 存在的问题：
 * 1、不带frameId从顶层StateMachine解析仅为了兼容，将来改为从当前FrameContext的StateMachine中解析；
 * 2、组合表单中顶层StateMachine是主表单的rootFrameContext的StateMachine，显然不合理（既成事实）；
 * 3、farmeId如果是states或renderStates，导致解析失败，几率很小，但又风险。
 */
class StateMachineVariableParser {
    /**
     * 构造函数
     */
    constructor() {
    }
    /**
     * 解析变量
     * @param expression 变量：格式形如：/frameId/componentId/stateName
     * @param context 上下文
     */
    parse(expression, context) {
        const paths = this.extractPaths(expression);
        // 1、单个的表达式：直接求值
        if (paths.length === 1 && expression === `{STATEMACHINE~${paths[0]}}`) {
            return this.getValue(paths[0], context);
        }
        // 2、其他情况：字符串替换
        paths.forEach(path => {
            const searchValue = `{STATEMACHINE~${path}}`;
            const replaceValue = this.getValue(path, context);
            expression = expression.replace(searchValue, replaceValue);
        });
        return expression;
    }
    /**
     * 提取Session变量名
     * 变量格式：{}
     */
    extractPaths(expression) {
        const paths = [];
        // 查找所有的StateMachine变量字符串
        const STATE_MACHINE_PATTERN_G = /\{STATEMACHINE~(\S+?)\}/g;
        const stateMachineVariables = expression.match(STATE_MACHINE_PATTERN_G);
        if (stateMachineVariables === null) {
            return [];
        }
        // 提取后边的路径
        const STATE_MACHINE_PATTERN = /\{STATEMACHINE~(\S+?)\}/;
        stateMachineVariables.forEach(sessionVariable => {
            const pathMatches = sessionVariable.match(STATE_MACHINE_PATTERN);
            if (pathMatches != null && pathMatches.length === 2) {
                paths.push(pathMatches[1]);
            }
        });
        return paths;
    }
    /**
     * 获取对应的值
     */
    getValue(path, context) {
        const pathObj = this.getPathObj(path);
        const stateMachine = this.getTargetStateMachine(pathObj.frameId, context);
        if (pathObj.type === 'currentState') {
            return stateMachine.context.state;
        }
        else if (pathObj.type === 'renderStates') {
            return stateMachine[pathObj.name];
        }
        else {
            throw new Error(`不支类型为${pathObj.type}的状态机变量`);
        }
    }
    /**
     * 解析path，并获取对应的StateMachine实例
     */
    getTargetStateMachine(frameId, context) {
        let targetFrameContext;
        if (frameId) {
            targetFrameContext = ParseUtil.getFrameContextById(context, frameId);
        }
        else {
            targetFrameContext = ParseUtil.getRootFrameContext(context);
        }
        if (!targetFrameContext || !targetFrameContext.stateMachine) {
            throw new Error('找不到对应的状态机实例，请检查！');
        }
        return targetFrameContext.stateMachine;
    }
    /**
     * 将Path解析为格式化的Path对象
     */
    getPathObj(path) {
        let parsedPathObj;
        const parts = this.splitPath(path);
        if (parts[0] === 'currentState' || parts[0] === 'renderStates') {
            parsedPathObj = {
                frameId: '',
                type: parts[0],
                name: parts[1]
            };
        }
        else {
            parsedPathObj = {
                frameId: parts[0],
                type: parts[1],
                name: parts[2]
            };
        }
        return parsedPathObj;
    }
    /**
     * 分隔Path
     */
    splitPath(path) {
        const parts = path.split('/').filter((part) => {
            return part !== '';
        });
        return parts;
    }
}

/**
 * session变量解析
 * @author Witt <jiwt@inspur.com>
 */
/**
 * 命令变量解析
 * {COMMAND~/params/key}
 * {COMMAND~/results/taskName}
 */
class CommandVariableParser {
    /**
     * 构造函数
     */
    constructor() {
    }
    /**
     * 解析变量
     * @param expression 变量：格式形如：/frameId/componentId/stateName
     * @param context 上下文
     */
    parse(expression, context) {
        const paths = this.extractPaths(expression);
        // 1、单个的表达式：直接求值
        if (paths.length === 1 && expression === `{COMMAND~${paths[0]}}`) {
            return this.getValue(paths[0], context);
        }
        // 2、其他情况：字符串替换
        paths.forEach(path => {
            const searchValue = `{COMMAND~${path}}`;
            const replaceValue = this.getValue(path, context);
            expression = expression.replace(searchValue, replaceValue);
        });
        return expression;
    }
    /**
     * 提取Session变量名
     * 变量格式：{}
     */
    extractPaths(expression) {
        const paths = [];
        // 查找所有的uiState变量字符串
        const UI_STATE_PATTERN_G = /\{COMMAND~(\S+?)\}/g;
        const uiStateVariables = expression.match(UI_STATE_PATTERN_G);
        if (uiStateVariables === null) {
            return [];
        }
        // 提取后边的路径
        const UI_STATE_PATTERN = /\{COMMAND~(\S+?)\}/;
        uiStateVariables.forEach(sessionVariable => {
            const pathMatches = sessionVariable.match(UI_STATE_PATTERN);
            if (pathMatches != null && pathMatches.length === 2) {
                paths.push(pathMatches[1]);
            }
        });
        return paths;
    }
    /**
     * 获取UIState
     */
    getValue(path, context) {
        if (context instanceof CommandContext === false) {
            throw new Error('当前上下文不支持COMMAND变量，请检查！');
        }
        const parts = path.split('/').filter((part) => {
            return part !== '';
        });
        const [type, name] = parts;
        if (type === 'params') {
            return context.command.params[name];
        }
        else if (type === 'results') {
            return context.results[name];
        }
    }
}

/**
 * 变量解析服务
 * 职责：
 * 1、解析字符串中的变量，并替换成相应的值；
 * 2、对表达式进行求值。
 *
 * @todo 对表达式求值的部分和表达式功能重叠，是否转移到表达式中？
 */
class VariableParseService {
    /**
     * 构造变量解析服务
     * @param parsers 解析器集合
     */
    constructor(parsers) {
        this.parsers = parsers;
    }
    /**
     * 解析表达式
     * @param expression 表达式
     * @param context 上下文
     */
    parse(target, context) {
        if (typeof target === 'string' && target.length > 0) {
            // 字符串，直接解析
            return this.parseExpression(target, context);
        }
        else if (Array.isArray(target)) {
            // 遍历数组
            target.forEach((item, itemIndex) => {
                if (typeof item === 'string') {
                    target[itemIndex] = this.parseExpression(item, context);
                }
                else {
                    target[itemIndex] = this.parse(item, context);
                }
            });
        }
        else if (typeof target === 'object' && target !== null) {
            // 遍历对象可枚举属性
            const keys = Object.keys(target);
            keys.forEach(key => {
                if (typeof target[key] === 'string') {
                    target[key] = this.parseExpression(target[key], context);
                }
                else {
                    target[key] = this.parse(target[key], context);
                }
            });
        }
        return target;
    }
    /**
     * 表达式求值
     */
    evaluate(expression, context) {
        const parsedExpression = this.parse(expression, context);
        return (new Function('return ' + parsedExpression))();
    }
    /**
     * 解析表达式
     * @param expression 表达式
     * @param context 上下文
     */
    parseExpression(expression, context) {
        // 空串直接返回
        if (expression === '') {
            return '';
        }
        this.parsers.forEach(parser => {
            if (typeof expression === 'string') {
                expression = parser.parse(expression, context);
            }
        });
        return expression;
    }
}

const APP_VARIABLE_PROVIDERS = [
    { provide: VARIABLE_PARSERS, useClass: DataVariableParser, multi: true, deps: [] },
    { provide: VARIABLE_PARSERS, useClass: UIStateVariableParser, multi: true, deps: [] },
    { provide: VARIABLE_PARSERS, useClass: StateMachineVariableParser, multi: true, deps: [] },
    { provide: VARIABLE_PARSERS, useClass: CommandVariableParser, multi: true, deps: [] },
    { provide: VariableParseService, useClass: VariableParseService, deps: [VARIABLE_PARSERS] },
];

/* eslint-disable no-case-declarations */
/**
 * 任务链接
 */
class TaskLink {
    /**
     * 构造函数
     */
    constructor(from, to, condition) {
        this.from = from;
        this.to = to;
        this.condition = condition;
    }
    /**
     * 是否能够
     */
    canLink(context) {
        const type = typeof this.condition;
        let canLink;
        switch (type) {
            case 'boolean':
                canLink = this.condition;
                break;
            case 'function':
                canLink = this.condition(context);
                break;
            case 'string':
                const parseService = context.viewModelContext.injector.get(VariableParseService);
                canLink = parseService.evaluate(this.condition, context);
                break;
            default:
                canLink = false;
                break;
        }
        return canLink;
    }
}

/*
 * @Author: Witt
 * @Date: 2018-10-17 14:13:40
 * @Last Modified by: Witt
 * @Last Modified time: 2018-10-17 16:08:34
 */
/**
 * 任务执行流程
 */
class TaskFlow {
    constructor() {
        /**
         * 节点集合
         */
        this.nodes = [];
        /**
         * 边集合
         */
        this.links = [];
        // #endregion
    }
    // #region 节点操作
    /**
     * 添加节点
     */
    addNode(name, func) {
        const node = new TaskNode(name, func);
        this.nodes.push(node);
    }
    /**
     * 批量添加链接
     */
    addNodes(nodes) {
        this.nodes = this.nodes.concat(nodes);
    }
    /**
     * 在目标节点之前插入一个节点
     * @param target 目标节点名称
     * @param name 名称
     * @param func 函数
     */
    insertNode(target, name, func) {
        const index = this.findNodeIndex(target);
        const node = this.createNode(name, func);
        this.nodes.splice(index, 0, node);
    }
    /**
     * 在目标节点之前插入一个节点
     */
    appendNode(target, name, func) {
        const index = this.findNodeIndex(target) + 1;
        const node = this.createNode(name, func);
        this.nodes.splice(index, 0, node);
    }
    /**
     * 获取节点索引
     * @param name 名称
     */
    findNodeIndex(name) {
        return this.nodes.findIndex((node) => {
            return node.name === name;
        });
    }
    /**
     * 创建任务节点
     * @param name 名称
     * @param func 函数
     */
    createNode(name, func) {
        const node = new TaskNode(name, func);
        return node;
    }
    // #endregion
    // #region 链接操作
    /**
     * 添加链接
     * @param name 名称
     * @param func 函数
     */
    addLink(from, to, condition) {
        const link = this.createLink(from, to, condition);
        this.links.push(link);
    }
    /**
     * 批量添加链接
     */
    addLinks(links) {
        this.links = this.links.concat(links);
    }
    /**
     * 创建链接
     */
    createLink(from, to, condition) {
        const link = new TaskLink(from, to, condition);
        return link;
    }
    // #endregion
    // #region 流程控制
    /**
     * 获取下一个节点
     * @param from    源节点名称
     * @param context 上下文
     */
    getNext(from, context) {
        if (!from) {
            return this.nodes.shift();
        }
        // 符合满足条件的边
        const nextLink = this.links.find((link) => {
            return link.from === from && link.canLink(context);
        });
        if (!nextLink) {
            return;
        }
        return this.nodes.find((node) => {
            return node.name === nextLink.to;
        });
    }
    // #endregion
    // #region 其他方法
    /**
     * 克隆任务流
     */
    clone() {
        const taskFlow = new TaskFlow();
        taskFlow.addNodes(this.nodes);
        taskFlow.addLinks(this.links);
        return taskFlow;
    }
}

/**
 * Command上下文
 */
class CommandContext {
    /**
     * 构造函数
     * @param command 命令
     * @param viewModelContext 视图模型上下文
     */
    constructor(command, viewModelContext) {
        /**
         * 执行结果
         */
        this.results = {};
        this.command = command;
        this.viewModelContext = viewModelContext;
    }
}

/**
 * 命令处理抽象类，所有具体的命令处理类必须继承它，并实现schedule方法。
 */
class CommandHandler {
    /**
     * 构造函数
     */
    constructor() {
    }
    /**
     * 初始化
     */
    init(viewModelContext) {
        this.viewModelContext = viewModelContext;
        this.parseService = viewModelContext.injector.get(VariableParseService);
        this.taskFlow = new TaskFlow();
        this.schedule();
    }
    /**
     * 执行任务
     * @param command 要执行的命令
     * @return 最后一个任务的执行结果
     * @todo：按功能拆分小函数
     */
    execute(command) {
        const lastTaskResult$ = new Subject();
        const taskFlow = this.taskFlow.clone();
        // setTimeout暂时不能去掉的原因：
        // 1、树表单加载数据，依赖TreeTableBinding里设置的全局变量，需要延后执行加载时机；
        // 2、关闭前命令需要延迟执行。
        setTimeout(() => {
            // 1、解析参数
            // 避免解析变量时修改了原始的command
            const { eventParam = null } = Object.assign({}, command);
            delete command.eventParam;
            const commandToExecute = JSON.parse(JSON.stringify(command));
            commandToExecute.params = this.parseService.parse(commandToExecute.params, this.viewModelContext);
            command.eventParam = eventParam;
            commandToExecute.eventParam = eventParam;
            // 2、串联任务流
            const initContext = new CommandContext(commandToExecute, this.viewModelContext);
            initContext.eventParams = command.eventParam || null;
            const context$ = new BehaviorSubject(initContext);
            let currentTask = taskFlow.getNext('', initContext);
            const highOrder$ = context$.pipe(concatMap((context) => {
                const result$ = currentTask.execute(context);
                return result$.pipe(take(1), map((result) => {
                    // 写入执行结果
                    context.results[currentTask.name] = result;
                    context.latestResult = result;
                    currentTask = taskFlow.getNext(currentTask.name, context);
                    // 操作控制流
                    if (currentTask) {
                        context$.next(context);
                    }
                    else {
                        context$.complete();
                    }
                    // 将结果流转换为context流
                    return context;
                }), throwIfEmpty(() => {
                    context$.complete();
                }));
            }));
            // 3、执行合并后的任务流
            highOrder$.pipe(takeLast(1)).subscribe({
                next: (context) => {
                    lastTaskResult$.next(context.latestResult);
                },
                error: (error) => {
                    this.displayError(error);
                    lastTaskResult$.error(error);
                },
                complete: () => {
                    lastTaskResult$.complete();
                },
            });
        }, 0);
        return lastTaskResult$;
    }
    /**
     * 显示错误信息
     */
    displayError(error) {
        if (!error) {
            return;
        }
        if (!console || !console.error) {
            return;
        }
        console.error(error);
    }
    /**
     * 添加任务，只有子类可以添加任务，外部不能访问
     * @param name  任务名称
     * @param func 任务函数
     */
    addTask(name, func) {
        this.taskFlow.addNode(name, func);
    }
    /**
     * 添加任务，只有子类可以添加任务，外部不能访问
     * @param name  任务名称
     * @param func 任务函数
     */
    addLink(from, to, condition) {
        this.taskFlow.addLink(from, to, condition);
    }
    /**
     * 插入任务
     * @param  name 要扩展的任务名称
     * @param  func 扩展函数
     */
    insertTask(target, name, func) {
        throw new Error('Not Implemented');
    }
    /**
     * 插入任务
     * @param  name 要扩展的任务名称
     * @param  func 扩展函数
     */
    afterTask(target, name, func) {
        throw new Error('Not Implemented');
    }
    /**
     * 替换任务
     * @param  name 要替换的任务名称
     * @param  func 替换函数
     */
    replaceTask(name, func) {
        throw new Error('Not Implement');
    }
    /**
     * 调用方法
     */
    invoke(serviceInstance, method, args, context) {
        this.setContextToServiceInstance(serviceInstance, context);
        const parsedArgs = this.parseService.parse(args, context);
        return serviceInstance[method](...parsedArgs);
    }
    /**
     * 为服务设置命令上下文
     * @todo
     * 通过这种方式存在很大问题：
     * 1、会覆盖掉已有的context，给开发人员造成困扰和调试成本；
     * 2、服务中依赖了一个没有声明的对象，不符合面向对象的原则。
     * 建议解决方案：
     * 1、将context修改为某个特殊属性名；
     * 2、先检测服务上有没有一个CommandContext类型的context属性，有的话再赋值，
     *    这就要求需要使用context的服务需要是实现一个IContext接口。
     */
    setContextToServiceInstance(serviceInstance, context) {
        // 如果服务上已经存在context属性，并且该属性不是CommandContext类型，则不能覆盖
        const serviceContext = serviceInstance.context;
        if (serviceContext && (serviceContext instanceof CommandContext === false)) {
            return;
        }
        serviceInstance.context = context;
    }
}
/**
 * 命令处理器注入Token
 */
const COMMAND_HANDLERS_TOKEN = createInjectionToken('@Farris/devkit COMMAND_HANDLERS_TOKEN');

/**
 * 命令处理注册器相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * 命令处理注册器
 */
class CommandHandlerRegistry {
    /**
     * 构造函数
     * @param handlers 命令处理实例数组
     */
    constructor(injector) {
        this.injector = injector;
        const handlers = this.injector.get(COMMAND_HANDLERS_TOKEN, null, InjectFlags.Optional);
        this.handlerMap = new Map();
        if (handlers) {
            handlers.forEach((handler) => {
                this.regist(handler);
            });
        }
    }
    /**
     * 添加命令处理
     * @param  commandName    命令名称
     * @param  commandHandler 命令处理实例
     */
    set(commandName, commandHandler) {
        if (this.handlerMap.has(commandName)) {
            throw new Error(commandName + '对应的CommandHandler已经存在');
        }
        this.handlerMap.set(commandName, commandHandler);
    }
    /**
     * 获取命令处理
     * @param   commandName 命令名称
     * @returns 命令处理实例
     */
    get(commandName) {
        if (this.handlerMap.has(commandName) === false) {
            throw new Error('找不到' + commandName + '对应的CommandHandler');
        }
        return this.handlerMap.get(commandName);
    }
    /**
     * 注册命令处理
     * @param handlers 命令处理实例
     */
    regist(commandHandler) {
        // 根据metadata获取对应的Command名称
        const handlerMetadata = MetadataUtil.getClassMetadataByName(commandHandler.constructor, COMMAND_HANDLER_META);
        if (!handlerMetadata) {
            throw new Error('CommandHandler必须指定要处理的命令名称');
        }
        const commandName = handlerMetadata.commandName;
        this.set(commandName, commandHandler);
    }
}

/**
 * 命令处理扩展相关
 * @author Witt<jiwt@inspur.com>
 */
class CommandHandlerExtender {
}
/**
 * 命令处理器扩展注入Token
 */
const COMMAND_HANDLER_EXTENDERS_TOKEN = createInjectionToken('@farris/devkit COMMAND_HANDLER_EXTENDERS_TOKEN');

/**
 * 命令处理扩展注册器相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * 命令处理扩展注册器
 */
class CommandHandlerExtenderRegistry {
    /**
     * 构造函数
     * @param extenders 命令扩展实例数组
     */
    constructor(injector) {
        this.injector = injector;
        const extenders = this.injector.get(COMMAND_HANDLER_EXTENDERS_TOKEN, null, InjectFlags.Optional);
        this.extendersMap = new Map();
        if (extenders) {
            extenders.forEach((extender) => {
                this.regist(extender);
            });
        }
    }
    /**
     * 获取命令扩展实例数组
     * @param   commandName 命令名称
     * @returns 命令处理扩展实例数组
     */
    get(commandName) {
        if (this.extendersMap.has(commandName) === false) {
            return [];
        }
        return this.extendersMap.get(commandName);
    }
    /**
     * 添加命令扩展
     * @param commandName Command名称
     * @param extender    CommandHandlerExtender实例
     * @return void
     */
    set(commandName, extender) {
        if (this.extendersMap.has(commandName)) {
            // 如果commandName对应的扩展已经存在，则在扩展数组中追加
            this.extendersMap.get(commandName).push(extender);
        }
        else {
            // 如果不存在，则创建新的扩展数组，并追加
            this.extendersMap.set(commandName, [extender]);
        }
    }
    /**
     * 注册命令扩展
     * @param extender CommandHandlerExtender实例
     */
    regist(extender) {
        // 通过元数据获取要扩展的Comamnd名称
        const extenderMetadata = MetadataUtil.getClassMetadataByName(extender.constructor, COMMAND_HANDLER_EXTENDER_META);
        if (!extenderMetadata) {
            throw new Error('CommandHandlerExtender必须指定要扩展的命令名称');
        }
        const commandName = extenderMetadata.commandName;
        // 添加到Map中
        this.set(commandName, extender);
    }
}

/**
 * 命令处理器工厂相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * 命令处理器工厂
 */
class CommandHandlerFactory {
    /**
     * 构造函数
     * @param handlerRegistry  命令处理注册器
     * @param extenderRegistry 命令处理扩展注册器
     */
    constructor(handlerRegistry, extenderRegistry, viewModelContext) {
        this.handlerRegistry = handlerRegistry;
        this.extenderRegistry = extenderRegistry;
        this.viewModelContext = viewModelContext;
    }
    /**
     * 创建命令处理器
     * @param   commandName 命令名称
     * @returns 对应的命令处理器实例
     */
    create(commandName) {
        const rawHandler = this.handlerRegistry.get(commandName);
        rawHandler.init(this.viewModelContext);
        const extenders = this.extenderRegistry.get(commandName);
        // 遍历extenders，依次对handler进行扩展
        return extenders.reduce((handler, extender) => {
            return extender.extend(handler);
        }, rawHandler);
    }
}

/**
 * CommandBus相关定义
 * @author Witt<jiwt@inspur.com>
 */
/**
 * CommandBus用于派发Command，它接受一个Command实例，查找对应的CommandHandler，并执行。
 */
class CommandBus {
    /**
     * 构造函数
     */
    constructor(handlerFactory) {
        this.handlerFactory = handlerFactory;
        this.executingCommands = [];
        this.executingCommandCount$ = new BehaviorSubject(this.executingCommands.length);
    }
    /**
     * 派发命令
     * @param command 要派发的命令
     */
    dispatch(command) {
        const commandResult$ = new Subject();
        this.executeCommand(command).subscribe({
            next: (lastTaskResult) => {
                commandResult$.next(lastTaskResult);
                commandResult$.complete();
            },
            complete: () => {
                commandResult$.complete();
                this.removeCommandFromExecutingQueue(command);
            },
            error: (error) => {
                commandResult$.error(error);
                this.removeCommandFromExecutingQueue(command);
            }
        });
        return commandResult$;
    }
    /**
     * 执行命令并返回最后一个任务的执行结果流
     */
    executeCommand(command) {
        this.addCommandToExecutingQueue(command);
        const commandName = command.name;
        const handler = this.handlerFactory.create(commandName);
        const lastTaskResult$ = handler.execute(command);
        return lastTaskResult$;
    }
    /**
     * 添加到执行队列
     */
    addCommandToExecutingQueue(command) {
        this.executingCommands.push(command);
        this.executingCommandCount$.next(this.executingCommands.length);
    }
    /**
     * 从执行队列中移除
     */
    removeCommandFromExecutingQueue(command) {
        this.executingCommands = this.executingCommands.filter((executingCommand) => {
            return executingCommand !== command;
        });
        this.executingCommandCount$.next(this.executingCommands.length);
    }
}

const VIEW_MODEL_COMMAND_PROVIDERS = [
    {
        provide: CommandHandlerRegistry,
        useClass: CommandHandlerRegistry,
        deps: [Injector]
    },
    {
        provide: CommandHandlerExtenderRegistry,
        useClass: CommandHandlerExtenderRegistry,
        deps: [Injector]
    },
    {
        provide: CommandHandlerFactory,
        useClass: CommandHandlerFactory,
        deps: [CommandHandlerRegistry, CommandHandlerExtenderRegistry, ViewModelContext]
    },
    {
        provide: CommandBus,
        useClass: CommandBus,
        deps: [CommandHandlerFactory]
    }
];

/*
 * @Author: aalizzwell
 * @Date: 2019-05-30 11:08:18
 * @Last Modified by: aalizzwell
 * @Last Modified time: 2019-06-01 17:10:04
 */
const EXCEPTION_HANDLER = '@farris/devkit ExceptionHandler';

/**
 * Generated bundle index. Do not edit.
 */

export { ACTION_METHOD_META, ANNOTATIONS, APP_VARIABLE_PROVIDERS, ActionMethodMeta, App, AppContext, AppOptions, ArrayStringValueConverter, ArrayUtil, BindingData, BindingDataFactory, BindingDataManager, BindingList, BindingListFactory, BindingObject, BindingObjectFactory, BindingPathComparer, BindingPathConverter, BindingPathTraverser, BindingPropertyType, BindingType, BindingValueAccessorFactory, BoolUtil, COMMAND_HANDLERS_TOKEN, COMMAND_HANDLER_EXTENDERS_TOKEN, COMMAND_HANDLER_EXTENDER_META, COMMAND_HANDLER_META, COMMAND_METHOD_META, ChangeSet, ChangeType, CommandBus, CommandContext, CommandHandler, CommandHandlerExtender, CommandHandlerExtenderMeta, CommandHandlerExtenderRegistry, CommandHandlerFactory, CommandHandlerMeta, CommandHandlerRegistry, CommandMethodMeta, CommandVariableParser, Context, DYNAMIC_PROP_META, DataChangeType, DataPath, DataPathCreator, DataPathNode, DataPathNodeType, DataPathUtil, DataPropGroup, DataPropInfo, DataTypeInfo, DataVariableParser, DateStringValueConverter, DateUtil, DefaultRepository, DynamicEntity, DynamicPropMeta, EXCEPTION_HANDLER, Entity, EntityBindingValueAccessor, EntityCollection, EntityFactory, EntityList, EntityManager, EntityMetadataUtil, EntityPathComparer, EntityPathConverter, EntityUtil, EnumUtil, FORM_CONTROL_PROP_META, FieldMetadataUtil, Form, FormControl, FormControlPropMeta, FormPathConverter, Guid, HTTP_PROVIDERS, HttpClient, HttpMethods, HttpUtil, INJECTOR, INJECTOR_IMPL, INJECTOR_IMPL__PRE_R3__, INJECTOR_SCOPE, InjectFlags, InjectionToken, Injector, LIST_PROP_META, ListPropMeta, MetadataUtil, Modification, ModifyType, NumberUtil, OBJECT_PROP_META, ObjectPropMeta, ObjectUtil, PARAMETERS, PARENT_CLASS, PARENT_PATH, PRIMITIVE_PROP_META, PROP_METADATA, PrimitivePropMeta, PropertyUtil, RENDER_STATE_PROP_META, REPOSITORY_META, RenderStatePropMeta, Repository, RepositoryManager, RepositoryMeta, STATE_PROP_META, State, StateMachine, StateMachineContext, StateMachineVariableParser, StatePropMeta, StaticInjector, StringUtil, TaskFlow, TaskLink, TaskNode, Type, UISTATE_PROP_META, UIState, UIStateBindingValueAccessor, UIStateMetadataUtil, UIStatePropMeta, UIStateVariableParser, USE_VALUE, VARIABLE_PARSERS, VIEW_MODEL_COMMAND_PROVIDERS, VariableParseService, ViewChangeType, ViewModel, ViewModelContext, ViewModelContextManager, ViewModelOptions, createEntities, createEntity, createInjectionToken, createInjector, initialUIState, isObservable, isType, makeDecorator, makeParamDecorator, makePropDecorator, setCurrentInjector, ɵ0, getClosureSafeProperty as ɵa, AppEventBus as ɵb };
//# sourceMappingURL=farris-mobile-devkit.js.map
