import { InjectionToken, Injectable, Optional, Inject, defineInjectable, inject, Directive, Input, HostListener, Component, ElementRef, HostBinding, NgModule } from '@angular/core';
import { FileViewerService, FileListModule } from '@gsp-svc/file-viewer';
import { DownloadService, GspFormRemoveListEntity, GspFormUploadListEntity, GspFormUploadEntity, OperatingModes, GspFormDocInfo, UploadService, UploadDialogMoudle } from '@gsp-svc/formdoc-upload';
import { UploadServerService, UploadStatus, FFileUploadModule } from '@farris/extend-file-upload';
import { Observable, forkJoin, Subject, concat, of, EMPTY } from 'rxjs';
import { switchMap, catchError, delay, map, expand, last } from 'rxjs/operators';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ffileupload-adapt-unifile.config.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function FFileUploadAdaptUnifileConfig() { }
if (false) {
    /** @type {?|undefined} */
    FFileUploadAdaptUnifileConfig.prototype.rootId;
    /** @type {?|undefined} */
    FFileUploadAdaptUnifileConfig.prototype.formId;
    /** @type {?|undefined} */
    FFileUploadAdaptUnifileConfig.prototype.mode;
    /** @type {?|undefined} */
    FFileUploadAdaptUnifileConfig.prototype.options;
}
/** @type {?} */
const FFileUploadAdaptUnifileConfigToken = new InjectionToken('MFFileUploadAdaptUnifileConfig');
class FFileUploadAdaptUnifileConfigService {
    /**
     * @param {?} exConfig
     */
    constructor(exConfig) {
        this.config = (/** @type {?} */ ({
            rootId: '',
            formId: '',
            mode: 0
        }));
        if (exConfig) {
            Object.assign(this.config, exConfig);
        }
    }
    /**
     * 获取config属性的值
     * @return {?}
     */
    getConfig() {
        return this.config;
    }
    /**
     * 设置config的属性值
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    setConfig(key, value) {
        this.config[key] = value;
    }
}
FFileUploadAdaptUnifileConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
FFileUploadAdaptUnifileConfigService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [FFileUploadAdaptUnifileConfigToken,] }] }
];
/** @nocollapse */ FFileUploadAdaptUnifileConfigService.ngInjectableDef = defineInjectable({ factory: function FFileUploadAdaptUnifileConfigService_Factory() { return new FFileUploadAdaptUnifileConfigService(inject(FFileUploadAdaptUnifileConfigToken, 8)); }, token: FFileUploadAdaptUnifileConfigService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    FFileUploadAdaptUnifileConfigService.prototype.config;
}
;

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ffilepreview-adapt-unifile.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FfilepreviewAdaptUnifileService {
    /**
     * @param {?} fileviewSer
     * @param {?} configSer
     * @param {?} downloadSer
     */
    constructor(fileviewSer, configSer, downloadSer) {
        this.fileviewSer = fileviewSer;
        this.configSer = configSer;
        this.downloadSer = downloadSer;
        // 暂时用于简单合并
        this.previewExtendServerConfig = null;
        this.extendData = this.configSer.getConfig();
    }
    /**
     * 返回最终属性值
     * @private
     * @param {?} key
     * @param {?} extendValue
     * @return {?}
     */
    getFinallyConfig(key, extendValue) {
        if (extendValue && extendValue.hasOwnProperty(key)) {
            return extendValue[key];
        }
        // 避免下载等其他指令再传入扩展配置
        if (this.previewExtendServerConfig && this.previewExtendServerConfig.hasOwnProperty(key)) {
            return this.previewExtendServerConfig[key];
        }
        // 来自module中forRoot的配置
        if (this.extendData.hasOwnProperty(key)) {
            return this.extendData[key];
        }
        return null;
    }
    /**
     * 预览单个文件
     * @param {?} info
     * @param {?} extendService
     * @return {?}
     */
    previewFile(info, extendService) {
        return this.previewFileList([info], extendService);
    }
    /**
     * 预览整个列表
     * @param {?} infos
     * @param {?} extendService
     * @return {?}
     */
    previewFileList(infos, extendService) {
        //metadataIdList: string[]
        /** @type {?} */
        let rootId = this.getFinallyConfig('rootId', extendService);
        /** @type {?} */
        let metadataIdList = [];
        infos.forEach((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            metadataIdList.push(item.extend['metadataId']);
        }));
        /** @type {?} */
        let options = this.getFinallyConfig('options', extendService);
        if (options) {
            return this.fileviewSer.viewerFileList(metadataIdList, rootId, options);
        }
        else {
            return this.fileviewSer.viewerFileList(metadataIdList, rootId);
        }
    }
    /**
     * 下载附件
     * @param {?} info
     * @param {?} extendService
     * @return {?}
     */
    downloadFile(info, extendService) {
        if (!info.id) {
            throw new Error('请设置要下载的附件');
        }
        window.open(this.getImgSrc(info, extendService));
    }
    /**
     * 下载附件
     * @param {?} infos
     * @param {?} extendService
     * @return {?}
     */
    multiDownloadFiles(infos, extendService) {
        //metadataIdList: string[]
        if (infos.length == 1) {
            this.downloadFile(infos[0], extendService);
        }
        else {
            /** @type {?} */
            let rootId = this.getFinallyConfig('rootId', extendService);
            /** @type {?} */
            let metadataIdList = [];
            infos.forEach((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                metadataIdList.push(item.extend['metadataId']);
            }));
            /** @type {?} */
            let url = this.downloadSer.getMultipleDownloadUrl(JSON.stringify(metadataIdList), rootId);
            window.open(url);
        }
    }
    /**
     * @param {?} infos
     * @param {?=} name
     * @param {?=} extendService
     * @return {?}
     */
    multiDownloadFilesWidthName(infos, name = "", extendService) {
        //metadataIdList: string[]
        if (infos.length == 1) {
            this.downloadFile(infos[0], extendService);
        }
        else {
            /** @type {?} */
            let rootId = this.getFinallyConfig('rootId', extendService);
            /** @type {?} */
            let metadataIdList = [];
            infos.forEach((/**
             * @param {?} item
             * @return {?}
             */
            item => {
                metadataIdList.push(item.extend['metadataId']);
            }));
            /** @type {?} */
            let url = this.downloadSer.getMultipleDownloadUrlWithName(JSON.stringify(metadataIdList), rootId, name);
            window.open(url);
        }
    }
    /**
     * 获取下载链接
     * @param {?} info
     * @param {?} extendService
     * @return {?}
     */
    getImgSrc(info, extendService) {
        if (!info.id) {
            throw new Error('请设置要下载的附件');
        }
        /** @type {?} */
        let url = '';
        /** @type {?} */
        let attachId = info.extend['metadataId'];
        /** @type {?} */
        let rootId = this.getFinallyConfig('rootId', extendService);
        // 文档服务服务单元名进行规范性调整，由document修改为dfs
        if (this.downloadSer) {
            if (rootId) {
                url = this.downloadSer.getDownloadUrl(attachId, rootId);
            }
        }
        else if (rootId) {
            console.warn('因为安全问题，附件下载提供安全校验机制，附件下载功能需要重新编译');
            url = `/api/runtime/dfs/v1.0/formdoc/filecontent?metadataid=${attachId}&rootid=${rootId}`;
        }
        return url;
    }
    /**
     * 根据预览指令的扩展配置获取
     * @param {?} value
     * @return {?}
     */
    setPreviwExtendServerConfig(value) {
        this.previewExtendServerConfig = value;
    }
    /**
     * @return {?}
     */
    getPreviewExtendServerConfig() {
        return this.previewExtendServerConfig;
    }
}
FfilepreviewAdaptUnifileService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
FfilepreviewAdaptUnifileService.ctorParameters = () => [
    { type: FileViewerService },
    { type: FFileUploadAdaptUnifileConfigService },
    { type: DownloadService, decorators: [{ type: Optional }] }
];
/** @nocollapse */ FfilepreviewAdaptUnifileService.ngInjectableDef = defineInjectable({ factory: function FfilepreviewAdaptUnifileService_Factory() { return new FfilepreviewAdaptUnifileService(inject(FileViewerService), inject(FFileUploadAdaptUnifileConfigService), inject(DownloadService, 8)); }, token: FfilepreviewAdaptUnifileService, providedIn: "root" });
if (false) {
    /** @type {?} */
    FfilepreviewAdaptUnifileService.prototype.extendData;
    /**
     * @type {?}
     * @private
     */
    FfilepreviewAdaptUnifileService.prototype.previewExtendServerConfig;
    /**
     * @type {?}
     * @private
     */
    FfilepreviewAdaptUnifileService.prototype.fileviewSer;
    /**
     * @type {?}
     * @private
     */
    FfilepreviewAdaptUnifileService.prototype.configSer;
    /**
     * @type {?}
     * @private
     */
    FfilepreviewAdaptUnifileService.prototype.downloadSer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ffilepreview-adapt-unifile-simple.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FFileAdaptPreviewFileDirective {
    /**
     * @param {?} previewSer
     */
    constructor(previewSer) {
        this.previewSer = previewSer;
        // 是否禁用预览
        this.viewDisabled = false;
        // 处理扩展的服务器端配置
        this.extendServerConfig = null;
    }
    /**
     * 捕获预览事件
     * @return {?}
     */
    filePreviewEventHandler() {
        if (!this.fileInfo || this.viewDisabled) {
            return;
        }
        this.previewSer.previewFile(this.fileInfo, this.extendServerConfig);
    }
}
FFileAdaptPreviewFileDirective.decorators = [
    { type: Directive, args: [{
                selector: '[fFileAdaptPreviewFile]'
            },] }
];
/** @nocollapse */
FFileAdaptPreviewFileDirective.ctorParameters = () => [
    { type: FfilepreviewAdaptUnifileService }
];
FFileAdaptPreviewFileDirective.propDecorators = {
    fileInfo: [{ type: Input, args: ['fFileAdaptPreviewFile',] }],
    filePreviewEventHandler: [{ type: HostListener, args: ['click', ['$event'],] }],
    viewDisabled: [{ type: Input }],
    extendServerConfig: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    FFileAdaptPreviewFileDirective.prototype.fileInfo;
    /** @type {?} */
    FFileAdaptPreviewFileDirective.prototype.viewDisabled;
    /** @type {?} */
    FFileAdaptPreviewFileDirective.prototype.extendServerConfig;
    /**
     * @type {?}
     * @private
     */
    FFileAdaptPreviewFileDirective.prototype.previewSer;
}
class FFileAdaptDownloadFileDirective {
    /**
     * @param {?} previewSer
     */
    constructor(previewSer) {
        this.previewSer = previewSer;
        //重命名
        this.zipName = '';
        // 是否禁用下载
        this.downloadDisabled = false;
        // 处理扩展的服务器端配置
        this.extendServerConfig = null;
        // 是否启用批量下载
        this.enableMulti = false;
    }
    /**
     * 捕获预览事件
     * @return {?}
     */
    filePreviewEventHandler() {
        if (!this.fileInfo || this.downloadDisabled) {
            return;
        }
        if (this.enableMulti && this.fileInfo instanceof Array) {
            this.previewSer.multiDownloadFilesWidthName(this.fileInfo, this.zipName, this.extendServerConfig);
        }
        else {
            this.previewSer.downloadFile(this.fileInfo, this.extendServerConfig);
        }
    }
}
FFileAdaptDownloadFileDirective.decorators = [
    { type: Directive, args: [{
                selector: '[fFileAdaptDownloadFile]'
            },] }
];
/** @nocollapse */
FFileAdaptDownloadFileDirective.ctorParameters = () => [
    { type: FfilepreviewAdaptUnifileService }
];
FFileAdaptDownloadFileDirective.propDecorators = {
    fileInfo: [{ type: Input, args: ['fFileAdaptDownloadFile',] }],
    filePreviewEventHandler: [{ type: HostListener, args: ['click', ['$event'],] }],
    zipName: [{ type: Input }],
    downloadDisabled: [{ type: Input }],
    extendServerConfig: [{ type: Input }],
    enableMulti: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    FFileAdaptDownloadFileDirective.prototype.fileInfo;
    /** @type {?} */
    FFileAdaptDownloadFileDirective.prototype.zipName;
    /** @type {?} */
    FFileAdaptDownloadFileDirective.prototype.downloadDisabled;
    /** @type {?} */
    FFileAdaptDownloadFileDirective.prototype.extendServerConfig;
    /** @type {?} */
    FFileAdaptDownloadFileDirective.prototype.enableMulti;
    /**
     * @type {?}
     * @private
     */
    FFileAdaptDownloadFileDirective.prototype.previewSer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ffilepreview-adapt-seeimg/ffilepreview-adapt-seeimg.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FfilepreviewAdaptSeeimgComponent {
    /**
     * @param {?} adpSer
     * @param {?} elementRef
     */
    constructor(adpSer, elementRef) {
        this.adpSer = adpSer;
        this.elementRef = elementRef;
        this.cls = true;
        // 是否启用图片的缩略图，默认为false；如果启用，图片类型会出现缩略图；不启用，根据类型显示图标
        this.enableThumbnail = false;
        // 图标的样式前缀
        this.clsPrefix = 'ffilepreview--filetype';
        // 显示缩略图中时，定义哪些后缀属于图片;
        this.supportImgSuffix = 'jpeg,jpg,gif,png,bmp';
        this.iconWidth = 38;
        // 缩略图的最大宽度
        this.maxThumbnailWidth = '100%';
        // 缩略图的最小宽度
        this.maxThumbnailHeight = '100%';
        // 处理扩展的服务器端配置，这样可以支持每个指令预览不同的目录，比如{'rootId':'default-root','formId':'formId'}
        this.extendServerConfig = null;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * 获取图片的链接
     * @return {?}
     */
    imgSrc() {
        return this.adpSer.getImgSrc(this.fileInfo, this.extendServerConfig);
    }
    /**
     * 判断是否是图片
     * @return {?}
     */
    isImage() {
        // 没有数据
        if (!this.fileInfo) {
            return false;
        }
        // 没有名称
        /** @type {?} */
        let fileName = this.fileInfo.name;
        if (!fileName) {
            return false;
        }
        /** @type {?} */
        let lastDotIndex = fileName.lastIndexOf(".");
        /** @type {?} */
        let fileSuffix = '';
        if (lastDotIndex > -1) {
            fileSuffix = fileName.substring(lastDotIndex + 1).toLocaleLowerCase();
        }
        if (!fileSuffix) {
            return false;
        }
        /** @type {?} */
        let tImgSuffixArray = this.supportImgSuffix.split(',');
        /** @type {?} */
        let tIndex = tImgSuffixArray.findIndex((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            return item == fileSuffix;
        }));
        if (tIndex > -1) {
            return true;
        }
        return false;
    }
    /**
     * 获取文件类型样式
     * @return {?}
     */
    getFileTypeClassName() {
        /** @type {?} */
        let clsName = this.clsPrefix;
        // 如果名称为空
        if (!this.fileInfo || !this.fileInfo['name']) {
            return clsName + '-any';
        }
        /** @type {?} */
        let fileName = this.fileInfo['name'];
        /** @type {?} */
        let lastDotIndex = fileName.lastIndexOf(".");
        /** @type {?} */
        let fileSuffix = '';
        if (lastDotIndex > -1) {
            fileSuffix = fileName.substring(lastDotIndex + 1).toLocaleLowerCase();
        }
        switch (fileSuffix) {
            case 'pdf':
                clsName += '-pdf';
                break;
            case 'jpeg':
            case 'jpg':
            case 'gif':
            case 'png':
            case 'bmp':
                clsName += '-img';
                break;
            case 'ppt':
                clsName += '-ppt';
                break;
            case 'doc':
            case 'docx':
                clsName += '-doc';
                break;
            case 'xls':
            case 'xlsx':
                clsName += '-xls';
                break;
            case 'txt':
                clsName += '-txt';
                break;
            case 'zip':
                clsName += '-zip';
                break;
            default:
                clsName += '-any';
        }
        return clsName;
    }
}
FfilepreviewAdaptSeeimgComponent.decorators = [
    { type: Component, args: [{
                selector: 'ffilepreview-adapt-seeimg',
                template: "<div class=\"ffilepreview-seeimg--wrapper\" [ngClass]=\"{'ffilepreview-seeimg--thumbnail':enableThumbnail}\">\r\n  <ng-container *ngIf=\"enableThumbnail&&isImage();else notImage\">\r\n    <img class=\"ffilepreview-seeimg--img\" [src]=\"imgSrc()\" [ngStyle]=\"{'maxWidth':maxThumbnailWidth,'maxHeight':maxThumbnailHeight}\"/>\r\n  </ng-container>\r\n</div>\r\n<ng-template #notImage>\r\n  <span class=\"ffilepreview--filetype-icon\" [ngClass]=\"getFileTypeClassName()\" [ngStyle]=\"{'width':iconWidth+'px','height':iconWidth+'px'}\"></span>\r\n</ng-template>",
                styles: [":host{height:100%;width:100%;position:relative}.ffilepreview-seeimg--thumbnail{top:0;bottom:0;position:absolute;right:0;left:0;display:-webkit-box;display:flex;-webkit-box-align:center;align-items:center;-webkit-box-pack:center;justify-content:center}.ffilepreview-seeimg--wrapper:hover{opacity:.8}.ffilepreview-seeimg--img{max-width:100%;max-height:100%;border-radius:4px}"]
            }] }
];
/** @nocollapse */
FfilepreviewAdaptSeeimgComponent.ctorParameters = () => [
    { type: FfilepreviewAdaptUnifileService },
    { type: ElementRef }
];
FfilepreviewAdaptSeeimgComponent.propDecorators = {
    cls: [{ type: HostBinding, args: ['class.ffilepreview-adapt-seeimg',] }],
    enableThumbnail: [{ type: Input }],
    clsPrefix: [{ type: Input }],
    supportImgSuffix: [{ type: Input }],
    fileInfo: [{ type: Input }],
    iconWidth: [{ type: Input }],
    maxThumbnailWidth: [{ type: Input }],
    maxThumbnailHeight: [{ type: Input }],
    extendServerConfig: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    FfilepreviewAdaptSeeimgComponent.prototype.cls;
    /** @type {?} */
    FfilepreviewAdaptSeeimgComponent.prototype.enableThumbnail;
    /** @type {?} */
    FfilepreviewAdaptSeeimgComponent.prototype.clsPrefix;
    /** @type {?} */
    FfilepreviewAdaptSeeimgComponent.prototype.supportImgSuffix;
    /** @type {?} */
    FfilepreviewAdaptSeeimgComponent.prototype.fileInfo;
    /** @type {?} */
    FfilepreviewAdaptSeeimgComponent.prototype.iconWidth;
    /** @type {?} */
    FfilepreviewAdaptSeeimgComponent.prototype.maxThumbnailWidth;
    /** @type {?} */
    FfilepreviewAdaptSeeimgComponent.prototype.maxThumbnailHeight;
    /** @type {?} */
    FfilepreviewAdaptSeeimgComponent.prototype.extendServerConfig;
    /**
     * @type {?}
     * @private
     */
    FfilepreviewAdaptSeeimgComponent.prototype.adpSer;
    /**
     * @type {?}
     * @private
     */
    FfilepreviewAdaptSeeimgComponent.prototype.elementRef;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ffileupload-adapt-unifile.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FfileuploadAdaptUnifileService extends UploadServerService {
    /**
     * @param {?} uploadSer
     * @param {?} configSer
     */
    constructor(uploadSer, configSer) {
        super();
        this.uploadSer = uploadSer;
        this.configSer = configSer;
        // 暂时用于简单合并
        this.bufferSize = 1024 * 1024;
        this.uploadedChunk = {};
        this.fileTotalChunk = {};
        this.extendData = this.configSer.getConfig();
    }
    /**
     * @private
     * @return {?}
     */
    uuid() {
        /** @type {?} */
        let S4 = (/**
         * @return {?}
         */
        function () {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        });
        /** @type {?} */
        let nGuid = S4() + S4() + S4() + S4() + S4() + S4() + S4() + S4();
        return nGuid;
    }
    /**
     * 删除文件
     * @param {?} files
     * @param {?} event
     * @param {?} extendService
     * @return {?}
     */
    remove(files, event, extendService) {
        return this.innerRemoveList(files, event, extendService);
    }
    /**
     * @private
     * @param {?} files
     * @param {?} event
     * @param {?=} extendService
     * @return {?}
     */
    innerRemoveList(files, event, extendService = null) {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        observer => {
            /** @type {?} */
            let removeFileInfo = new GspFormRemoveListEntity;
            /** @type {?} */
            let metadataIdList = [];
            files.forEach((/**
             * @param {?} fileItem
             * @return {?}
             */
            fileItem => {
                if (fileItem['response']) {
                    metadataIdList.push(fileItem['response']['metadataId']);
                }
            }));
            removeFileInfo.mode = this.getFinallyConfig('mode', extendService);
            /** @type {?} */
            let rootId = this.getFinallyConfig('rootId', extendService);
            removeFileInfo.metadataIdList = [].concat(metadataIdList);
            this.uploadSer.removeList(metadataIdList, rootId).subscribe((/**
             * @param {?} result
             * @return {?}
             */
            result => {
                // 没有需要整合的服务器端返回数据
                observer.next({ type: 'removed', files: files });
            }), (/**
             * @param {?} error
             * @return {?}
             */
            error => {
                observer.error(error);
                observer.complete();
            }), (/**
             * @return {?}
             */
            () => {
                observer.complete();
            }));
        }));
    }
    /**
     * 上传文件
     * @param {?} files
     * @param {?} event
     * @param {?} extendService
     * @return {?}
     */
    upload(files, event, extendService) {
        if (event.type == 'sliceUpload') {
            return this.uploadBigFile(files, event, extendService);
        }
        return this.innerUploadList(files, event, extendService);
    }
    /**
     * 内部上传方式
     * @private
     * @param {?} files
     * @param {?} event
     * @param {?} extendService
     * @return {?}
     */
    innerUploadList(files, event, extendService) {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        observer => {
            /** @type {?} */
            let uploadInfo = new GspFormUploadListEntity;
            uploadInfo.formId = this.getFinallyConfig('formId', extendService);
            uploadInfo.mode = this.getFinallyConfig('mode', extendService);
            /** @type {?} */
            let rootId = this.getFinallyConfig('rootId', extendService);
            uploadInfo.docInfoList = [];
            /** @type {?} */
            let readerObserable = [];
            files.forEach((/**
             * @param {?} fileItem
             * @return {?}
             */
            (fileItem) => {
                /** @type {?} */
                let sub = new Observable((/**
                 * @param {?} obser
                 * @return {?}
                 */
                obser => {
                    /** @type {?} */
                    let reader = new FileReader();
                    // 暂不处理异常
                    reader.readAsBinaryString(fileItem.nativeFile);
                    reader.onload = (/**
                     * @param {?} e
                     * @return {?}
                     */
                    (e) => {
                        /** @type {?} */
                        let info = (/** @type {?} */ ({ 'fileName': '', 'fileContent': '' }));
                        info['fileName'] = fileItem.name;
                        info['fileContent'] = btoa(reader.result.toString());
                        // 如果data里有数据，并且属性是配置的扩展属性
                        if (event.hasOwnProperty('data') && event['data'] && event['data'].hasOwnProperty('extProperty')) {
                            // 
                            info['extProperty'] = event['data']['extProperty'];
                        }
                        uploadInfo.docInfoList.push(info);
                        obser.next();
                        obser.complete();
                    });
                }));
                readerObserable.push(sub);
            }));
            forkJoin(readerObserable).subscribe((/**
             * @param {?} datas
             * @return {?}
             */
            datas => {
                //     metadataId: string;
                //  fileName: string;
                this.uploadSer.uploadList(uploadInfo, rootId).subscribe((/**
                 * @param {?} result
                 * @return {?}
                 */
                result => {
                    if (result.error) {
                        // 此接口一旦出现问题，所有附件都上传不通过
                        observer.error(this.errorInfoFormat(result.error, files));
                        observer.complete();
                        return;
                    }
                    // 合并返回结果到此处
                    result.forEach((/**
                     * @param {?} item
                     * @return {?}
                     */
                    item => {
                        /** @type {?} */
                        var findIndex = this.findFileIndexByFileName(files, item.fileName);
                        if (findIndex > -1) {
                            files[findIndex]['response'] = item;
                            files[findIndex]['progress']['status'] = UploadStatus.Done;
                        }
                    }));
                    observer.next({ type: 'done', files: files });
                }), (/**
                 * @param {?} error
                 * @return {?}
                 */
                error => {
                    observer.error(this.errorInfoFormat(error, files));
                    observer.complete();
                }), (/**
                 * @return {?}
                 */
                () => {
                    observer.complete();
                }));
            }));
        }));
    }
    ;
    /**
     * 分片加载
     * @param {?} file
     * @param {?} event
     * @param {?} extendService
     * @return {?}
     */
    multipartUpload(file, event, extendService) {
        return new Observable((/**
         * @param {?} observer
         * @return {?}
         */
        observer => {
            // let fileInfo: FileInfo;
            /** @type {?} */
            let uuid = this.uuid();
            // let uuid = UUID.UUID();
            //reader.readAsBinaryString(selectedFile);
            //reader.onload = (e) => {
            /** @type {?} */
            let fileName = file.name;
            // fileInfo = {
            //   id: uuid,
            //   name: fileName,
            //   type: file.type,
            //   source: "",
            //   size: this.formatFileSize(file.size),
            //   fileSize: file.size,
            //   picListDisplayName: this.getMultipartDisplayName(fileName),
            //   queueListDisplayName: fileName,
            //   //content: reader.result.toString(),
            //   hasUploaded: false,
            //   mouseOn: false,
            //   selectd: false,
            //   isUploading: true,
            //   uploadResult: false,
            //   uploadProcess: 0,
            //   errorMessage: "",
            //   extensionDropListId: 0,
            //   extensionName: ""
            // }
            /** @type {?} */
            let chunkTotal = Math.ceil(file.size / this.bufferSize);
            // 标记当前附件总的分片数
            this.fileTotalChunk[uuid] = chunkTotal;
            /** @type {?} */
            let chunkIndex = 0;
            // 标记当前附件成功的分片数
            this.uploadedChunk[uuid] = 0;
            while (chunkIndex < chunkTotal) {
                /** @type {?} */
                let uploadInfo = new GspFormUploadEntity;
                uploadInfo.mode = OperatingModes.Temp;
                uploadInfo.formId = this.getFinallyConfig('formId', extendService);
                uploadInfo.rootId = this.getFinallyConfig('rootId', extendService);
                /** @type {?} */
                let docInfo = new GspFormDocInfo;
                docInfo.fileName = fileName;
                docInfo.metadataId = uuid;
                docInfo.total = chunkTotal;
                // 如果data里有数据，并且属性是配置的扩展属性
                if (event.hasOwnProperty('data') && event['data'] && event['data'].hasOwnProperty('extProperty')) {
                    docInfo['extProperty'] = (/** @type {?} */ (event['data']['extProperty']));
                }
                // 下一个文件大小
                /** @type {?} */
                let nextSize = Math.min((chunkIndex + 1) * this.bufferSize, file.size);
                // File类型
                /** @type {?} */
                let fileData = file['nativeFile'].slice(chunkIndex * this.bufferSize, nextSize);
                // 读取文件
                /** @type {?} */
                let reader = new FileReader();
                reader.readAsBinaryString(fileData);
                /** @type {?} */
                let innerIndex = chunkIndex;
                reader.onload = (/**
                 * @return {?}
                 */
                () => {
                    // 附件上传
                    docInfo.fileContent = btoa(reader.result.toString());
                    docInfo.index = innerIndex;
                    uploadInfo.docInfo = docInfo;
                    /** @type {?} */
                    let info = uploadInfo;
                    this.uploadSer.uploadFile(info).subscribe((/**
                     * @param {?} result
                     * @return {?}
                     */
                    result => {
                        if (result && result.error) {
                            // 分片上传有返回结果就是报错了
                            observer.error(this.errorInfoFormat(result.error, [file]));
                            observer.complete();
                            return;
                        }
                        else {
                            this.uploadedChunk[uuid]++;
                            if (this.uploadedChunk[docInfo.metadataId] == this.fileTotalChunk[docInfo.metadataId]) {
                                // 判断是所有分片都上传完成
                                file.progress = {
                                    status: UploadStatus.Done,
                                    data: {
                                        percentage: 100
                                    }
                                };
                                file.response = docInfo;
                                delete this.uploadedChunk[uuid];
                                delete this.fileTotalChunk[uuid];
                                observer.next({ type: 'done', files: [file] });
                                observer.complete();
                            }
                            else {
                                // 分片上传正常
                                /** @type {?} */
                                const percentage = Number.parseInt((this.uploadedChunk[uuid] / this.fileTotalChunk[uuid] * 100).toFixed(0));
                                // 判断未上传完成
                                file.progress = {
                                    status: UploadStatus.Uploading,
                                    data: {
                                        percentage: percentage
                                    }
                                };
                                observer.next({ type: 'uploading', files: [file] });
                            }
                        }
                    }), (/**
                     * @param {?} error
                     * @return {?}
                     */
                    error => {
                        delete this.uploadedChunk[uuid];
                        delete this.fileTotalChunk[uuid];
                        observer.error(this.errorInfoFormat(error, [file]));
                        observer.complete();
                    }));
                });
                chunkIndex = chunkIndex + 1;
            }
        }));
    }
    /**
     * 获取分片的附件大小
     * @private
     * @param {?} size
     * @return {?}
     */
    formatFileSize(size) {
        if (size < 102400)
            return (size / 1024).toFixed(1) + "K";
        else if (size < 1024 * 1024)
            return (size / 1024).toFixed(0) + "K";
        else if (size < 100 * 1024 * 1024)
            return (size / 1024 / 1024).toFixed(1) + "M";
        else if (size < 1024 * 1024 * 1024)
            return (size / 1024 / 1024).toFixed(0) + "M";
        else
            return (size / 1024 / 1024 / 1024).toFixed(1) + "G";
    }
    /**
     * 获取分片的 附件名称
     * @private
     * @param {?} fileName
     * @return {?}
     */
    getMultipartDisplayName(fileName) {
        if (fileName.length <= 10)
            return fileName;
        else {
            /** @type {?} */
            let headContent = fileName.substring(0, 2);
            /** @type {?} */
            let tailContent = fileName.substring(fileName.lastIndexOf('.') - 2);
            return headContent + "…" + tailContent;
        }
    }
    /**
     * @private
     * @param {?} error
     * @param {?} files
     * @return {?}
     */
    errorInfoFormat(error, files) {
        // 
        /** @type {?} */
        let errorFiles = files.map((/**
         * @param {?} item
         * @return {?}
         */
        item => {
            return { id: item.id, name: item.name };
        }));
        if (error) {
            return Object.assign(error, { files: errorFiles }, { message: error['Message'] || error['extensionMessage'] || '上传失败', type: 'error' });
        }
        else {
            return Object.assign({ files: errorFiles }, { message: '上传失败', type: 'error' });
        }
    }
    /**
     * 返回最终属性值
     * @private
     * @param {?} key
     * @param {?} extendValue
     * @return {?}
     */
    getFinallyConfig(key, extendValue) {
        if (extendValue && extendValue.hasOwnProperty(key)) {
            return extendValue[key];
        }
        return this.extendData[key];
    }
    /**
     * @private
     * @param {?} files
     * @param {?} fileName
     * @return {?}
     */
    findFileIndexByFileName(files, fileName) {
        // 按照肯定能找到文件来处理
        /** @type {?} */
        let findIndex = files.findIndex((/**
         * @param {?} file
         * @return {?}
         */
        file => file.name == fileName));
        return findIndex;
    }
    //#region 大文件分片上传
    /**
     * @param {?} files
     * @param {?} event
     * @param {?} extendService
     * @return {?}
     */
    uploadBigFile(files, event, extendService) {
        /** @type {?} */
        const uploadChunks$ = new Subject();
        /** @type {?} */
        const _files = files.map((/**
         * @param {?} n
         * @return {?}
         */
        n => {
            /** @type {?} */
            const chunks = this._getBigFileChunks(n, event, extendService);
            return Object.assign({}, n, chunks);
        }));
        /** @type {?} */
        const uploadchunks$ = _files.map((/**
         * @param {?} f
         * @return {?}
         */
        (f) => this.uploadChunks(f, uploadChunks$)));
        concat(...uploadchunks$).subscribe((/**
         * @param {?} f
         * @return {?}
         */
        (f) => {
            // console.log(`file: ${f.name} - upload complete`);
            f.progress = {
                status: UploadStatus.Done,
                data: {
                    percentage: 100
                }
            };
            f.response = JSON.parse(f.chunks[0].get('docInfo'));
            uploadChunks$.next({ type: 'done', files: [f] });
        }), (/**
         * @param {?} error
         * @return {?}
         */
        error => {
            uploadChunks$.error(this.errorInfoFormat(error, files));
            uploadChunks$.complete();
        }), (/**
         * @return {?}
         */
        () => {
            uploadChunks$.complete();
            // console.log("all files uploaded")
        }));
        return uploadChunks$.asObservable();
    }
    /**
     * @private
     * @param {?} file
     * @return {?}
     */
    uploadFileChunk(file) {
        /** @type {?} */
        const url = "/api/runtime/dfs/v1.0/formdoc/slice";
        return this.uploadSer['http']['http'].post(url, file.chunks[file.total]).pipe(switchMap((/**
         * @return {?}
         */
        () => {
            return of(file);
        })), catchError((/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
            return of(error);
        })));
    }
    /**
     * @private
     * @param {?} file
     * @param {?} upChunk$
     * @return {?}
     */
    uploadChunks(file, upChunk$) {
        /** @type {?} */
        const doChunksRemain = (/**
         * @param {?} i
         * @return {?}
         */
        (i) => i > -1);
        /** @type {?} */
        const completeUpload = (/**
         * @param {?} f
         * @return {?}
         */
        (f) => of(f));
        /** @type {?} */
        const uploadChunk = (/**
         * @param {?} f
         * @return {?}
         */
        (f) => {
            return this.uploadFileChunk(f).pipe(delay(100), map((/**
             * @param {?} f
             * @return {?}
             */
            (f) => {
                // 块数为0 时，即为此文件的所有块均上传成功
                f.progress = {
                    status: UploadStatus.Uploading,
                    data: {
                        percentage: (f.total / f.chunks.length * 100).toFixed(0)
                    }
                };
                upChunk$.next({ type: 'uploading', files: [f] });
                return f;
            })));
        });
        /** @type {?} */
        const createMultipartUpload = (/**
         * @param {?} f
         * @return {?}
         */
        (f) => of(f));
        return createMultipartUpload(file).pipe(
        // tap((f) => console.log("upload file", f.name)),
        expand((/**
         * @param {?} f
         * @return {?}
         */
        (f) => {
            if (doChunksRemain(--file.total)) {
                return uploadChunk(file);
            }
            return EMPTY;
        })), 
        // tap((f: any) => {
        //     console.log(`file: ${f.name} - remaining chunks: ${f.total}`);
        // }),
        last(), switchMap((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            return completeUpload(file);
        })));
    }
    /**
     * @private
     * @param {?} file
     * @param {?} event
     * @param {?} extendService
     * @return {?}
     */
    _getBigFileChunks(file, event, extendService) {
        /** @type {?} */
        let uuid = this.uuid();
        /** @type {?} */
        let chunkTotal = Math.ceil(file.size / this.bufferSize * (event.chunkSize || 1));
        /** @type {?} */
        let chunkIndex = 0;
        /** @type {?} */
        const fileChunks = { chunks: [], total: chunkTotal };
        while (chunkIndex < chunkTotal) {
            /** @type {?} */
            let uploadInfo = new GspFormUploadEntity;
            uploadInfo.mode = OperatingModes.Temp;
            uploadInfo.formId = this.getFinallyConfig('formId', extendService);
            uploadInfo.rootId = this.getFinallyConfig('rootId', extendService);
            /** @type {?} */
            let docInfo = new GspFormDocInfo;
            docInfo.fileName = file.name;
            docInfo.metadataId = uuid;
            docInfo.total = chunkTotal;
            /** @type {?} */
            let nextSize = Math.min((chunkIndex + 1) * this.bufferSize, file.size);
            // File类型
            /** @type {?} */
            let fileData = file['nativeFile'].slice(chunkIndex * this.bufferSize, nextSize);
            docInfo.size = file.size;
            docInfo.index = chunkIndex;
            docInfo.fileContent = "";
            // 如果data里有数据，并且属性是配置的扩展属性
            if (event.hasOwnProperty('data') && event['data'] && event['data'].hasOwnProperty('extProperty')) {
                docInfo['extProperty'] = (/** @type {?} */ (event['data']['extProperty']));
            }
            uploadInfo.docInfo = docInfo;
            //封装请求formdata
            /** @type {?} */
            let formData = new FormData();
            formData.append('uploadInfo', JSON.stringify(uploadInfo));
            formData.append('docInfo', JSON.stringify(docInfo));
            formData.append('file', fileData);
            fileChunks.chunks.push(formData);
            chunkIndex = chunkIndex + 1;
        }
        return fileChunks;
    }
}
FfileuploadAdaptUnifileService.previous = 0;
FfileuploadAdaptUnifileService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
FfileuploadAdaptUnifileService.ctorParameters = () => [
    { type: UploadService },
    { type: FFileUploadAdaptUnifileConfigService }
];
/** @nocollapse */ FfileuploadAdaptUnifileService.ngInjectableDef = defineInjectable({ factory: function FfileuploadAdaptUnifileService_Factory() { return new FfileuploadAdaptUnifileService(inject(UploadService), inject(FFileUploadAdaptUnifileConfigService)); }, token: FfileuploadAdaptUnifileService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    FfileuploadAdaptUnifileService.previous;
    /** @type {?} */
    FfileuploadAdaptUnifileService.prototype.extendData;
    /** @type {?} */
    FfileuploadAdaptUnifileService.prototype.bufferSize;
    /**
     * @type {?}
     * @private
     */
    FfileuploadAdaptUnifileService.prototype.uploadedChunk;
    /**
     * @type {?}
     * @private
     */
    FfileuploadAdaptUnifileService.prototype.fileTotalChunk;
    /**
     * @type {?}
     * @private
     */
    FfileuploadAdaptUnifileService.prototype.uploadSer;
    /**
     * @type {?}
     * @private
     */
    FfileuploadAdaptUnifileService.prototype.configSer;
    /* Skipping unhandled member: ;*/
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ffilepreview-adapt-unifile.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FFilePreviewAdaptUnifileDirective {
    /**
     * @param {?} previewSer
     */
    constructor(previewSer) {
        this.previewSer = previewSer;
        /**
         * 处理扩展的服务器端配置
         */
        this._extendServeConfig = null;
    }
    /**
     * 捕获预览事件
     * @param {?} fileInfo
     * @return {?}
     */
    filePreviewEventHandler(fileInfo) {
        /** @type {?} */
        const previewOpts = Object.assign(this.extendServerConfig || {}, {
            options: {
                showDownload: !!fileInfo.showDownload,
                showHeader: true,
                showFileList: true
            }
        });
        this.previewSer.previewFile(fileInfo, previewOpts);
    }
    /**
     * 捕获下载事件
     * @param {?} downloadEv
     * @return {?}
     */
    fileDownloadEventHandler(downloadEv) {
        // 如果是批量下载, downloadEv={fileInfos:[],name:}
        if (downloadEv && downloadEv['fileInfos'].length > 0) {
            if (downloadEv['fileInfos'].length > 1) {
                this.previewSer.multiDownloadFilesWidthName(downloadEv['fileInfos'], downloadEv['name'], this.extendServerConfig);
            }
            else {
                this.previewSer.downloadFile(downloadEv['fileInfos'][0], this.extendServerConfig);
            }
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set extendServerConfig(value) {
        this._extendServeConfig = value;
        this.previewSer.setPreviwExtendServerConfig(value);
    }
    /**
     * @return {?}
     */
    get extendServerConfig() {
        return this._extendServeConfig;
    }
}
FFilePreviewAdaptUnifileDirective.decorators = [
    { type: Directive, args: [{
                selector: '[fFilePreviewAdaptUnifile]',
                providers: [FfilepreviewAdaptUnifileService]
            },] }
];
/** @nocollapse */
FFilePreviewAdaptUnifileDirective.ctorParameters = () => [
    { type: FfilepreviewAdaptUnifileService }
];
FFilePreviewAdaptUnifileDirective.propDecorators = {
    filePreviewEventHandler: [{ type: HostListener, args: ['filePreviewEvent', ['$event'],] }],
    fileDownloadEventHandler: [{ type: HostListener, args: ['fileDownloadEvent', ['$event'],] }],
    extendServerConfig: [{ type: Input }]
};
if (false) {
    /**
     * 处理扩展的服务器端配置
     * @type {?}
     * @private
     */
    FFilePreviewAdaptUnifileDirective.prototype._extendServeConfig;
    /**
     * @type {?}
     * @private
     */
    FFilePreviewAdaptUnifileDirective.prototype.previewSer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ffileupload-adapt-unifile.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class FfileuploadAdaptUnifileModule {
    /**
     * @param {?=} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: FfileuploadAdaptUnifileModule,
            providers: [
                { provide: FFileUploadAdaptUnifileConfigToken, useValue: config },
                FFileUploadAdaptUnifileConfigService,
                FfilepreviewAdaptUnifileService,
                FileViewerService
            ]
        };
    }
}
FfileuploadAdaptUnifileModule.decorators = [
    { type: NgModule, args: [{
                declarations: [FFilePreviewAdaptUnifileDirective, FfilepreviewAdaptSeeimgComponent, FFileAdaptDownloadFileDirective, FFileAdaptPreviewFileDirective],
                imports: [
                    CommonModule,
                    UploadDialogMoudle,
                    FileListModule,
                    FFileUploadModule.forRoot(null, FfileuploadAdaptUnifileService)
                ],
                exports: [FFileUploadModule, FFilePreviewAdaptUnifileDirective, FfilepreviewAdaptSeeimgComponent, FFileAdaptDownloadFileDirective, FFileAdaptPreviewFileDirective],
                providers: [
                    FFileUploadAdaptUnifileConfigService,
                    FfilepreviewAdaptUnifileService,
                    FileViewerService
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public-api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: farris-extend-fileupload-adapt-unifile.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { FFileAdaptDownloadFileDirective, FFileAdaptPreviewFileDirective, FFilePreviewAdaptUnifileDirective, FFileUploadAdaptUnifileConfigService, FFileUploadAdaptUnifileConfigToken, FfilepreviewAdaptSeeimgComponent, FfilepreviewAdaptUnifileService, FfileuploadAdaptUnifileModule, FfileuploadAdaptUnifileService };
//# sourceMappingURL=farris-extend-fileupload-adapt-unifile.js.map
