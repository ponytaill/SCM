/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * @Author: 疯狂秀才(Lucas Huang)
 * @Date: 2019-08-15 17:31:08
 * @LastEditors: 疯狂秀才(Lucas Huang)
 * @LastEditTime: 2019-09-04 15:01:15
 * @QQ: 1055818239
 * @Version: v0.0.1
 */
import { Component, EventEmitter, Input, Output, ViewEncapsulation } from '@angular/core';
import { UtilService } from '../../services/public-api';
import { KeyCode } from '../../enums/public-api';
import { OPTS, MONTHS } from '../../constants/constants';
var MonthViewComponent = /** @class */ (function () {
    function MonthViewComponent(utilService) {
        this.utilService = utilService;
        this.months = [];
        this.monthCellClicked = new EventEmitter();
        this.monthCellKeyDown = new EventEmitter();
        this.onMouseEnter = new EventEmitter();
        this.onMouseLeave = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    MonthViewComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.hasOwnProperty(OPTS)) {
            this.opts = changes[OPTS].currentValue;
        }
        if (changes.hasOwnProperty(MONTHS)) {
            this.months = changes[MONTHS].currentValue;
        }
    };
    /**
     * @param {?} event
     * @param {?} cell
     * @return {?}
     */
    MonthViewComponent.prototype.onMonthCellClicked = /**
     * @param {?} event
     * @param {?} cell
     * @return {?}
     */
    function (event, cell) {
        event.stopPropagation();
        if (cell.disabled) {
            return;
        }
        this.monthCellClicked.emit(cell);
    };
    /**
     * @param {?} event
     * @param {?} cell
     * @return {?}
     */
    MonthViewComponent.prototype.onMonthCellKeyDown = /**
     * @param {?} event
     * @param {?} cell
     * @return {?}
     */
    function (event, cell) {
        /** @type {?} */
        var keyCode = this.utilService.getKeyCodeFromEvent(event);
        if (keyCode !== KeyCode.tab) {
            event.preventDefault();
            if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {
                this.onMonthCellClicked(event, cell);
            }
            else if (this.opts.moveFocusByArrowKeys) {
                this.monthCellKeyDown.emit(cell);
            }
        }
    };
    /**
     * @param {?} cell
     * @return {?}
     */
    MonthViewComponent.prototype.onMonthCellMouseEnter = /**
     * @param {?} cell
     * @return {?}
     */
    function (cell) {
        if (this.utilService.isInitializedDate(this.selectedDateRange.begin) &&
            !this.utilService.isInitializedDate(this.selectedDateRange.end)) {
            for (var i = 0; i < this.months.length; i++) {
                /** @type {?} */
                var row = this.months[i].row;
                for (var j = 0; j < row.length; j++) {
                    /** @type {?} */
                    var month = row[j];
                    month.range =
                        (this.utilService.isDateSameOrEarlier(this.selectedDateRange.begin, month.monthObj) &&
                            this.utilService.isDateSameOrEarlier(month.monthObj, cell.monthObj)) ||
                            (this.utilService.isDateSameOrEarlier(month.monthObj, this.selectedDateRange.begin) &&
                                this.utilService.isDateSameOrEarlier(cell.monthObj, month.monthObj));
                }
            }
            this.onMouseEnter.emit(cell);
        }
    };
    /**
     * @return {?}
     */
    MonthViewComponent.prototype.onMonthCellMouseLeave = /**
     * @return {?}
     */
    function () {
        for (var i = 0; i < this.months.length; i++) {
            /** @type {?} */
            var row = this.months[i].row;
            for (var j = 0; j < row.length; j++) {
                /** @type {?} */
                var month = row[j];
                month.range = false;
            }
        }
        this.onMouseLeave.emit();
    };
    /**
     * @param {?} date
     * @return {?}
     */
    MonthViewComponent.prototype.isMonthInRange = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return this.utilService.isDateInRange(date, this.selectedDateRange);
    };
    /**
     * @param {?} date
     * @return {?}
     */
    MonthViewComponent.prototype.isMonthSame = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return this.utilService.isDateSame({
            year: this.selectedDate.year,
            month: this.selectedDate.month
        }, date);
    };
    /**
     * @param {?} date
     * @return {?}
     */
    MonthViewComponent.prototype.isMonthRangeBeginOrEndSame = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return this.utilService.isDateRangeBeginOrEndSame(this.selectedDateRange, date);
    };
    MonthViewComponent.decorators = [
        { type: Component, args: [{
                    selector: 'lib-month-view',
                    template: "<div class=\"f-datepicker-table-wrapper\">\r\n    <table class=\"f-datepicker-table\">\r\n        <tbody>\r\n            <tr *ngFor=\"let mr of months; let mi = index\">\r\n                <td\r\n                    id=\"m_{{ mi }}_{{ i }}\"\r\n                    class=\"m_{{ mi }}_{{ i }}\"\r\n                    *ngFor=\"let m of mr.row; let i = index\"\r\n                    (click)=\"onMonthCellClicked($event, m)\"\r\n                    (keydown)=\"onMonthCellKeyDown($event, m)\"\r\n                    (mouseenter)=\"onMonthCellMouseEnter(m)\"\r\n                    (mouseleave)=\"onMonthCellMouseLeave()\"\r\n                    tabindex=\"0\"\r\n                    style=\"width: 33.3%\"\r\n                >\r\n                    <div class=\"f-datepicker-month\">\r\n                        <span\r\n                            class=\"f-datepicker-month-cell\"\r\n                            [ngClass]=\"{\r\n                                'f-datepicker-current':\r\n                                    m.currMonth && opts.markCurrentMonth,\r\n                                'f-datepicker-selected':\r\n                                    (!this.opts.dateRange &&\r\n                                        isMonthSame(m.monthObj)) ||\r\n                                    (this.opts.dateRange &&\r\n                                        isMonthRangeBeginOrEndSame(m.monthObj)),\r\n                                'f-datepicker-disabled': m.disabled,\r\n                                'f-datepicker-range':\r\n                                    isMonthInRange(m.monthObj) || m.range\r\n                            }\"\r\n                            >{{ m.name }}</span\r\n                        >\r\n                    </div>\r\n                </td>\r\n            </tr>\r\n        </tbody>\r\n    </table>\r\n</div>\r\n",
                    providers: [UtilService],
                    encapsulation: ViewEncapsulation.None
                }] }
    ];
    /** @nocollapse */
    MonthViewComponent.ctorParameters = function () { return [
        { type: UtilService }
    ]; };
    MonthViewComponent.propDecorators = {
        opts: [{ type: Input }],
        months: [{ type: Input }],
        selectedDate: [{ type: Input }],
        selectedDateRange: [{ type: Input }],
        monthCellClicked: [{ type: Output }],
        monthCellKeyDown: [{ type: Output }],
        onMouseEnter: [{ type: Output }],
        onMouseLeave: [{ type: Output }]
    };
    return MonthViewComponent;
}());
export { MonthViewComponent };
if (false) {
    /** @type {?} */
    MonthViewComponent.prototype.opts;
    /** @type {?} */
    MonthViewComponent.prototype.months;
    /** @type {?} */
    MonthViewComponent.prototype.selectedDate;
    /** @type {?} */
    MonthViewComponent.prototype.selectedDateRange;
    /** @type {?} */
    MonthViewComponent.prototype.monthCellClicked;
    /** @type {?} */
    MonthViewComponent.prototype.monthCellKeyDown;
    /** @type {?} */
    MonthViewComponent.prototype.onMouseEnter;
    /** @type {?} */
    MonthViewComponent.prototype.onMouseLeave;
    /**
     * @type {?}
     * @private
     */
    MonthViewComponent.prototype.utilService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9udGgtdmlldy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AZmFycmlzL3VpLWRhdGVwaWNrZXIvIiwic291cmNlcyI6WyJsaWIvY29tcG9uZW50cy9tb250aC12aWV3L21vbnRoLXZpZXcuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQVFBLE9BQU8sRUFDSCxTQUFTLEVBQ1QsWUFBWSxFQUNaLEtBQUssRUFFTCxNQUFNLEVBRU4saUJBQWlCLEVBQ3BCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQVF4RCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDakQsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUV6RDtJQWlCSSw0QkFBb0IsV0FBd0I7UUFBeEIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFUbkMsV0FBTSxHQUF1QixFQUFFLENBQUM7UUFHL0IscUJBQWdCLEdBQW1DLElBQUksWUFBWSxFQUFvQixDQUFDO1FBQ3hGLHFCQUFnQixHQUFtQyxJQUFJLFlBQVksRUFBb0IsQ0FBQztRQUV4RixpQkFBWSxHQUFzQixJQUFJLFlBQVksRUFBTyxDQUFDO1FBQzFELGlCQUFZLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7SUFFcEIsQ0FBQzs7Ozs7SUFFakQsd0NBQVc7Ozs7SUFBWCxVQUFZLE9BQXNCO1FBQzlCLElBQUksT0FBTyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFBRTtZQUM5QixJQUFJLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxZQUFZLENBQUM7U0FDMUM7UUFDRCxJQUFJLE9BQU8sQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDaEMsSUFBSSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMs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QUMxQixvQ0FBeUM7O0lBQ3pDLDBDQUErQjs7SUFDL0IsK0NBQXlDOztJQUN6Qyw4Q0FBa0c7O0lBQ2xHLDhDQUFrRzs7SUFFbEcsMENBQW9FOztJQUNwRSwwQ0FBb0U7Ozs7O0lBRXhELHlDQUFnQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcbiAqIEBBdXRob3I6IOeWr+eLguengOaJjShMdWNhcyBIdWFuZylcclxuICogQERhdGU6IDIwMTktMDgtMTUgMTc6MzE6MDhcclxuICogQExhc3RFZGl0b3JzOiDnlq/ni4Lnp4DmiY0oTHVjYXMgSHVhbmcpXHJcbiAqIEBMYXN0RWRpdFRpbWU6IDIwMTktMDktMDQgMTU6MDE6MTVcclxuICogQFFROiAxMDU1ODE4MjM5XHJcbiAqIEBWZXJzaW9uOiB2MC4wLjFcclxuICovXHJcbmltcG9ydCB7XHJcbiAgICBDb21wb25lbnQsXHJcbiAgICBFdmVudEVtaXR0ZXIsXHJcbiAgICBJbnB1dCxcclxuICAgIE9uQ2hhbmdlcyxcclxuICAgIE91dHB1dCxcclxuICAgIFNpbXBsZUNoYW5nZXMsXHJcbiAgICBWaWV3RW5jYXBzdWxhdGlvblxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBVdGlsU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL3B1YmxpYy1hcGknO1xyXG5pbXBvcnQge1xyXG4gICAgSU15Q2FsZW5kYXJNb250aCxcclxuICAgIElNeU9wdGlvbnMsXHJcbiAgICBJTXlEYXRlLFxyXG4gICAgSU15RGF0ZVJhbmdlLFxyXG4gICAgSU15TW9udGhSb3dcclxufSBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL3B1YmxpYy1hcGknO1xyXG5pbXBvcnQgeyBLZXlDb2RlIH0gZnJvbSAnLi4vLi4vZW51bXMvcHVibGljLWFwaSc7XHJcbmltcG9ydCB7IE9QVFMsIE1PTlRIUyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cy9jb25zdGFudHMnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgICBzZWxlY3RvcjogJ2xpYi1tb250aC12aWV3JyxcclxuICAgIHRlbXBsYXRlVXJsOiAnLi9tb250aC12aWV3LmNvbXBvbmVudC5odG1sJyxcclxuICAgIHByb3ZpZGVyczogW1V0aWxTZXJ2aWNlXSxcclxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmVcclxufSlcclxuZXhwb3J0IGNsYXNzIE1vbnRoVmlld0NvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XHJcbiAgICBASW5wdXQoKSBvcHRzOiBJTXlPcHRpb25zO1xyXG4gICAgQElucHV0KCkgbW9udGhzOiBBcnJheTxJTXlNb250aFJvdz4gPSBbXTtcclxuICAgIEBJbnB1dCgpIHNlbGVjdGVkRGF0ZTogSU15RGF0ZTtcclxuICAgIEBJbnB1dCgpIHNlbGVjdGVkRGF0ZVJhbmdlOiBJTXlEYXRlUmFuZ2U7XHJcbiAgICBAT3V0cHV0KCkgbW9udGhDZWxsQ2xpY2tlZDogRXZlbnRFbWl0dGVyPElNeUNhbGVuZGFyTW9udGg+ID0gbmV3IEV2ZW50RW1pdHRlcjxJTXlDYWxlbmRhck1vbnRoPigpO1xyXG4gICAgQE91dHB1dCgpIG1vbnRoQ2VsbEtleURvd246IEV2ZW50RW1pdHRlcjxJTXlDYWxlbmRhck1vbnRoPiA9IG5ldyBFdmVudEVtaXR0ZXI8SU15Q2FsZW5kYXJNb250aD4oKTtcclxuXHJcbiAgICBAT3V0cHV0KCkgb25Nb3VzZUVudGVyOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xyXG4gICAgQE91dHB1dCgpIG9uTW91c2VMZWF2ZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHV0aWxTZXJ2aWNlOiBVdGlsU2VydmljZSkgeyB9XHJcblxyXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcyk6IHZvaWQge1xyXG4gICAgICAgIGlmIChjaGFuZ2VzLmhhc093blByb3BlcnR5KE9QVFMpKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0cyA9IGNoYW5nZXNbT1BUU10uY3VycmVudFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hhbmdlcy5oYXNPd25Qcm9wZXJ0eShNT05USFMpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW9udGhzID0gY2hhbmdlc1tNT05USFNdLmN1cnJlbnRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25Nb250aENlbGxDbGlja2VkKGV2ZW50OiBhbnksIGNlbGw6IElNeUNhbGVuZGFyTW9udGgpOiB2b2lkIHtcclxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgaWYgKGNlbGwuZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5tb250aENlbGxDbGlja2VkLmVtaXQoY2VsbCk7XHJcbiAgICB9XHJcblxyXG4gICAgb25Nb250aENlbGxLZXlEb3duKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBjZWxsOiBJTXlDYWxlbmRhck1vbnRoKSB7XHJcbiAgICAgICAgY29uc3Qga2V5Q29kZTogbnVtYmVyID0gdGhpcy51dGlsU2VydmljZS5nZXRLZXlDb2RlRnJvbUV2ZW50KGV2ZW50KTtcclxuICAgICAgICBpZiAoa2V5Q29kZSAhPT0gS2V5Q29kZS50YWIpIHtcclxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBLZXlDb2RlLmVudGVyIHx8IGtleUNvZGUgPT09IEtleUNvZGUuc3BhY2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub25Nb250aENlbGxDbGlja2VkKGV2ZW50LCBjZWxsKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdHMubW92ZUZvY3VzQnlBcnJvd0tleXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubW9udGhDZWxsS2V5RG93bi5lbWl0KGNlbGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25Nb250aENlbGxNb3VzZUVudGVyKGNlbGw6IGFueSk6IHZvaWQge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgICAgdGhpcy51dGlsU2VydmljZS5pc0luaXRpYWxpemVkRGF0ZSh0aGlzLnNlbGVjdGVkRGF0ZVJhbmdlLmJlZ2luKSAmJlxyXG4gICAgICAgICAgICAhdGhpcy51dGlsU2VydmljZS5pc0luaXRpYWxpemVkRGF0ZSh0aGlzLnNlbGVjdGVkRGF0ZVJhbmdlLmVuZClcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1vbnRocy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHJvdyA9IHRoaXMubW9udGhzW2ldLnJvdztcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93Lmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1vbnRoID0gcm93W2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vbnRoLnJhbmdlID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMudXRpbFNlcnZpY2UuaXNEYXRlU2FtZU9yRWFybGllcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWREYXRlUmFuZ2UuYmVnaW4sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb250aC5tb250aE9ialxyXG4gICAgICAgICAgICAgICAgICAgICAgICApICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnV0aWxTZXJ2aWNlLmlzRGF0ZVNhbWVPckVhcmxpZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGgubW9udGhPYmosXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5tb250aE9ialxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMudXRpbFNlcnZpY2UuaXNEYXRlU2FtZU9yRWFybGllcihcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vbnRoLm1vbnRoT2JqLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERhdGVSYW5nZS5iZWdpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICApICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnV0aWxTZXJ2aWNlLmlzRGF0ZVNhbWVPckVhcmxpZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5tb250aE9iaixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb250aC5tb250aE9ialxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5vbk1vdXNlRW50ZXIuZW1pdChjZWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgb25Nb250aENlbGxNb3VzZUxlYXZlKCk6IHZvaWQge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tb250aHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHJvdyA9IHRoaXMubW9udGhzW2ldLnJvdztcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3cubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBtb250aCA9IHJvd1tqXTtcclxuICAgICAgICAgICAgICAgIG1vbnRoLnJhbmdlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vbk1vdXNlTGVhdmUuZW1pdCgpO1xyXG4gICAgfVxyXG4gICAgaXNNb250aEluUmFuZ2UoZGF0ZTogSU15RGF0ZSk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnV0aWxTZXJ2aWNlLmlzRGF0ZUluUmFuZ2UoZGF0ZSwgdGhpcy5zZWxlY3RlZERhdGVSYW5nZSk7XHJcbiAgICB9XHJcbiAgICBpc01vbnRoU2FtZShkYXRlOiBJTXlEYXRlKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudXRpbFNlcnZpY2UuaXNEYXRlU2FtZShcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgeWVhcjogdGhpcy5zZWxlY3RlZERhdGUueWVhcixcclxuICAgICAgICAgICAgICAgIG1vbnRoOiB0aGlzLnNlbGVjdGVkRGF0ZS5tb250aFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkYXRlXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuICAgIGlzTW9udGhSYW5nZUJlZ2luT3JFbmRTYW1lKGRhdGU6IElNeURhdGUpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51dGlsU2VydmljZS5pc0RhdGVSYW5nZUJlZ2luT3JFbmRTYW1lKFxyXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGF0ZVJhbmdlLFxyXG4gICAgICAgICAgICBkYXRlXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufVxyXG4iXX0=