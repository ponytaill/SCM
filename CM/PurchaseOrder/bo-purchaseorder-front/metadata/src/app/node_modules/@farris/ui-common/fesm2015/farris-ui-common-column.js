import { Compare, FilterRelation, CompareOperators, SortType } from '@farris/ui-common/types';
import { Injectable, NgModule, defineInjectable, inject } from '@angular/core';
import { DateTimeHelperService, DateHelperModule } from '@farris/ui-common/date';
import { NumberHelperService, NumberHelperModule } from '@farris/ui-common/number';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * @Author: 疯狂秀才(Lucas Huang)
 * @Date: 2019-01-02 14:12:47
 * @LastEditors: 疯狂秀才(Lucas Huang)
 * @LastEditTime: 2019-10-18 13:59:34
 * @Company: Inspur
 * @Version: v0.0.1
 */
class ColumnFormatService {
    /**
     * @param {?} datehelper
     * @param {?} numberhelper
     */
    constructor(datehelper, numberhelper) {
        this.datehelper = datehelper;
        this.numberhelper = numberhelper;
    }
    /**
     * @param {?} value
     * @param {?=} data
     * @param {?=} formatter
     * @param {?=} context
     * @return {?}
     */
    format(value, data, formatter, context) {
        if (formatter) {
            if (typeof (formatter) === 'function') {
                context = context || {};
                return formatter(value, data, Object.assign({ date: this.datehelper, number: this.numberhelper, format: this }, context));
            }
            else {
                if (formatter['type']) {
                    /** @type {?} */
                    const fmt = (/** @type {?} */ (formatter));
                    switch (fmt.type) {
                        case 'datetime':
                            if (fmt.options && fmt.options.format) {
                                return this.dateTimeFormat(value, fmt.options);
                            }
                            return value;
                        case 'number':
                            return this.numberFormat(value, fmt.options);
                        case 'enum':
                            return this.enumFormat(value, fmt.options);
                        case 'image':
                            return this.imageFormat(value, fmt.options);
                        case 'boolean':
                            return this.booleanFormat(value, fmt.options);
                        default:
                            return value;
                    }
                }
            }
        }
        return value;
    }
    /**
     * @private
     * @param {?} value
     * @param {?} opts
     * @return {?}
     */
    dateTimeFormat(value, opts) {
        if (value) {
            /** @type {?} */
            let fmt = 'yyyy-MM-dd';
            if (typeof (opts) === 'string') {
                fmt = opts;
            }
            else if (typeof (opts) === 'object') {
                fmt = opts.format;
            }
            fmt = fmt.replace('YYYY', 'yyyy').replace('-DD', '-dd');
            if (typeof (opts) === 'object' && opts.dateRange) {
                /** @type {?} */
                const splitStr = opts.dateRangeDatesDelimiter || '~';
                let [beginDate, endDate] = value.split(splitStr);
                beginDate = this.datehelper.formatTo(beginDate, fmt);
                endDate = this.datehelper.formatTo(endDate, fmt);
                return beginDate + splitStr + endDate;
            }
            return this.datehelper.formatTo(value, fmt);
        }
        return value;
    }
    /**
     * @private
     * @param {?} value
     * @param {?=} opts
     * @return {?}
     */
    numberFormat(value, opts) {
        return this.numberhelper.formatNumber(value, opts);
        // if (value !== undefined && value !== '' && value !== NaN) {
        //     return this.numberhelper.formatMoney(value, opts);
        // }
        // return value;
    }
    /**
     * @private
     * @param {?} value
     * @param {?=} opts
     * @return {?}
     */
    enumFormat(value, opts) {
        if (value === undefined || value === null) {
            value = '';
        }
        if (opts && opts.data && opts.data.length) {
            /** @type {?} */
            const val = value.toString();
            /** @type {?} */
            let arr = [val];
            if (val.indexOf(',') > -1) { // 多选
                arr = val.split(',');
            }
            /** @type {?} */
            const str = [];
            arr.forEach((/**
             * @param {?} v
             * @return {?}
             */
            v => {
                /** @type {?} */
                const n = opts.data.find((/**
                 * @param {?} item
                 * @return {?}
                 */
                item => item[opts.valueField].toString() == v));
                if (n) {
                    str.push(n[opts.textField]);
                }
            }));
            if (str.length) {
                return str.join(',');
            }
            return value;
        }
        return value;
    }
    /**
     * @private
     * @param {?} value
     * @param {?=} opts
     * @return {?}
     */
    imageFormat(value, opts) {
        if (value) {
            if (opts) {
                /** @type {?} */
                const arrStr = [`<img src="${value}" `];
                if (opts.width) {
                    arrStr.push(`width="${opts.width}"`);
                }
                if (opts.height) {
                    arrStr.push(`height="${opts.height}"`);
                }
                arrStr.push('>');
                return arrStr.join('');
            }
            else {
                return `<img src="${value}">`;
            }
        }
        return value;
    }
    /**
     * @private
     * @param {?} value
     * @param {?=} opts
     * @return {?}
     */
    booleanFormat(value, opts) {
        if (value !== undefined) {
            if (opts) {
                /** @type {?} */
                const val = value ? opts.trueText : opts.falseText;
                if (val === null || val === undefined) {
                    return value;
                }
                return val;
            }
            else {
                return value;
            }
        }
        return '';
    }
    /**
     * @private
     * @param {?} val
     * @return {?}
     */
    convertCompare(val) {
        /** @type {?} */
        const op = CompareOperators.find((/**
         * @param {?} item
         * @return {?}
         */
        (item) => item.value === val));
        if (op) {
            return op.label;
        }
    }
    /**
     * @param {?} sorts
     * @return {?}
     */
    buildSortString(sorts) {
        if (sorts && sorts.length) {
            /** @type {?} */
            let str = sorts.map((/**
             * @param {?} s
             * @return {?}
             */
            s => {
                return `${s.sortField} ${SortType[s.sortType].toString().toLowerCase()},`;
            })).join(' ');
            if (str) {
                str = str.substr(0, str.length - 1);
            }
            return str;
        }
        return '';
    }
    /**
     * @param {?} conditions
     * @return {?}
     */
    buildSqlWhere(conditions) {
        if (conditions && conditions.length) {
            /** @type {?} */
            const result = [];
            /** @type {?} */
            const conditionList = conditions.filter((/**
             * @param {?} c
             * @return {?}
             */
            c => c.filterField !== ''));
            conditionList.forEach((/**
             * @param {?} condition
             * @param {?} index
             * @return {?}
             */
            (condition, index) => {
                if (!condition.filterField) {
                    return;
                }
                result.push(condition.lbracket);
                result.push(condition.filterField);
                /** @type {?} */
                const opCode = parseInt(condition.compare.toString(), 10);
                /** @type {?} */
                const op = this.convertCompare(opCode);
                result.push(' ' + op.replace(/\%/g, '').replace('...', ''));
                if (opCode === Compare.Like || opCode === Compare.NotLike
                    || opCode === Compare.NotLikeEndWith
                    || opCode === Compare.LikeEndWith) {
                    result.push('\'');
                    result.push('%');
                }
                else {
                    result.push(' ');
                    result.push('\'');
                }
                if (opCode === Compare.In || opCode === Compare.NotIn) {
                    result.push(condition.value.replace(/\r\n/g, ','));
                }
                else {
                    result.push(condition.value);
                }
                if (opCode === Compare.Like || opCode === Compare.NotLike
                    || opCode === Compare.LikeStartWith || opCode === Compare.NotLikeStartWith) {
                    result.push('%');
                }
                result.push('\'');
                result.push(condition.rbracket);
                result.push(' ');
                if (index !== conditionList.length - 1) {
                    result.push(condition.relation === FilterRelation.Empty ? '' :
                        FilterRelation[condition.relation].toString().toLowerCase());
                    result.push(' ');
                }
            }));
            return result.join('');
        }
        return '';
    }
}
ColumnFormatService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
ColumnFormatService.ctorParameters = () => [
    { type: DateTimeHelperService },
    { type: NumberHelperService }
];
/** @nocollapse */ ColumnFormatService.ngInjectableDef = defineInjectable({ factory: function ColumnFormatService_Factory() { return new ColumnFormatService(inject(DateTimeHelperService), inject(NumberHelperService)); }, token: ColumnFormatService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DataColumnModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: DataColumnModule,
            providers: [
                ColumnFormatService
            ]
        };
    }
}
DataColumnModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    DateHelperModule.forRoot(),
                    NumberHelperModule.forRoot()
                ],
                exports: [],
                declarations: [],
                providers: [],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { ColumnFormatService, DataColumnModule };

//# sourceMappingURL=farris-ui-common-column.js.map